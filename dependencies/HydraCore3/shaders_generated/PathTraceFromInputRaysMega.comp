#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_buffer_reference : require

#include "common_generated.h"
layout (constant_id = 1) const int KSPEC_MAT_TYPE_GLTF = 1;
layout (constant_id = 10) const int KSPEC_BLEND_STACK_SIZE = 10;
layout (constant_id = 11) const int KSPEC_BUMP_MAPPING = 11;
layout (constant_id = 12) const int KSPEC_MAT_TYPE_DIELECTRIC = 12;
layout (constant_id = 13) const int KSPEC_MAT_FOUR_TEXTURES = 13;
layout (constant_id = 14) const int KSPEC_LIGHT_IES = 14;
layout (constant_id = 15) const int KSPEC_LIGHT_ENV = 15;
layout (constant_id = 16) const int KSPEC_MOTION_BLUR = 16;
layout (constant_id = 17) const int KSPEC_OPTIC_SIM = 17;
layout (constant_id = 18) const int KSPEC_LIGHT_PROJECTIVE = 18;
layout (constant_id = 19) const int KSPEC_SPD_TEX = 19;
layout (constant_id = 2) const int KSPEC_MAT_TYPE_GLASS = 2;
layout (constant_id = 3) const int KSPEC_MAT_TYPE_CONDUCTOR = 3;
layout (constant_id = 4) const int KSPEC_MAT_TYPE_DIFFUSE = 4;
layout (constant_id = 5) const int KSPEC_MAT_TYPE_PLASTIC = 5;
layout (constant_id = 6) const int KSPEC_FILMS_STACK_SIZE = 6;
layout (constant_id = 7) const int KSPEC_MAT_TYPE_THIN_FILM = 7;
layout (constant_id = 8) const int KSPEC_SPECTRAL_RENDERING = 8;
layout (constant_id = 9) const int KSPEC_MAT_TYPE_BLEND = 9;

struct GeomDataTriangle
{
  uint m_tag;
  uint geomId;
};

struct GeomDataSdfGrid
{
  uint m_tag;
  uint geomId;
};

struct GeomDataSdfNode
{
  uint m_tag;
  uint geomId;
};

struct GeomDataSdfBrick
{
  uint m_tag;
  uint geomId;
};

struct GeomDataRF
{
  uint m_tag;
  uint geomId;
};

struct GeomDataGS
{
  uint m_tag;
  uint geomId;
};

struct GeomDataSdfAdaptBrick
{
  uint m_tag;
  uint geomId;
};

struct GeomDataNURBS
{
  uint m_tag;
  uint geomId;
};

struct GeomDataGraphicsPrim
{
  uint m_tag;
  uint geomId;
};

struct GeomDataCOctreeSimple
{
  uint m_tag;
  uint geomId;
};

struct GeomDataCOctreeBricked
{
  uint m_tag;
  uint geomId;
};

struct GeomDataCatmulClark
{
  uint m_tag;
  uint geomId;
};

struct GeomDataRibbon
{
  uint m_tag;
  uint geomId;
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer GeomDataTriangleBuffer
{
	GeomDataTriangle m_pAccelStruct_m_abstractObjectPtrs[];
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer GeomDataSdfGridBuffer
{
	GeomDataSdfGrid m_pAccelStruct_m_abstractObjectPtrs[];
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer GeomDataSdfNodeBuffer
{
	GeomDataSdfNode m_pAccelStruct_m_abstractObjectPtrs[];
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer GeomDataSdfBrickBuffer
{
	GeomDataSdfBrick m_pAccelStruct_m_abstractObjectPtrs[];
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer GeomDataRFBuffer
{
	GeomDataRF m_pAccelStruct_m_abstractObjectPtrs[];
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer GeomDataGSBuffer
{
	GeomDataGS m_pAccelStruct_m_abstractObjectPtrs[];
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer GeomDataSdfAdaptBrickBuffer
{
	GeomDataSdfAdaptBrick m_pAccelStruct_m_abstractObjectPtrs[];
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer GeomDataNURBSBuffer
{
	GeomDataNURBS m_pAccelStruct_m_abstractObjectPtrs[];
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer GeomDataGraphicsPrimBuffer
{
	GeomDataGraphicsPrim m_pAccelStruct_m_abstractObjectPtrs[];
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer GeomDataCOctreeSimpleBuffer
{
	GeomDataCOctreeSimple m_pAccelStruct_m_abstractObjectPtrs[];
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer GeomDataCOctreeBrickedBuffer
{
	GeomDataCOctreeBricked m_pAccelStruct_m_abstractObjectPtrs[];
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer GeomDataCatmulClarkBuffer
{
	GeomDataCatmulClark m_pAccelStruct_m_abstractObjectPtrs[];
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer GeomDataRibbonBuffer
{
	GeomDataRibbon m_pAccelStruct_m_abstractObjectPtrs[];
};

struct AllBufferReferences
{
  GeomDataTriangleBuffer GeomDataTriangle_buffer;
  GeomDataSdfGridBuffer GeomDataSdfGrid_buffer;
  GeomDataSdfNodeBuffer GeomDataSdfNode_buffer;
  GeomDataSdfBrickBuffer GeomDataSdfBrick_buffer;
  GeomDataRFBuffer GeomDataRF_buffer;
  GeomDataGSBuffer GeomDataGS_buffer;
  GeomDataSdfAdaptBrickBuffer GeomDataSdfAdaptBrick_buffer;
  GeomDataNURBSBuffer GeomDataNURBS_buffer;
  GeomDataGraphicsPrimBuffer GeomDataGraphicsPrim_buffer;
  GeomDataCOctreeSimpleBuffer GeomDataCOctreeSimple_buffer;
  GeomDataCOctreeBrickedBuffer GeomDataCOctreeBricked_buffer;
  GeomDataCatmulClarkBuffer GeomDataCatmulClark_buffer;
  GeomDataRibbonBuffer GeomDataRibbon_buffer;
  uint dummy[2];
};
layout(binding = 0, set = 0) buffer data0 { RayPosAndW in_rayPosAndNear[]; }; // 
layout(binding = 1, set = 0) buffer data1 { RayDirAndT in_rayDirAndFar[]; }; // 
layout(binding = 2, set = 0) buffer data2 { float out_color[]; }; // 
layout(binding = 3, set = 0) buffer data3 { uint m_packedXY[]; }; // 
layout(binding = 4, set = 0) buffer data4 { RandomGenT m_randomGens[]; }; // 
layout(binding = 5, set = 0) buffer data5 { float m_pdfLightData[]; }; // 
layout(binding = 6, set = 0) buffer data6 { uint m_pAccelStruct_m_primIndices[]; }; // 
layout(binding = 7, set = 0) buffer data7 { vec4 m_vTang4f[]; }; // 
layout(binding = 8, set = 0) buffer data8 { uint m_matIdOffsets[]; }; // 
layout(binding = 9, set = 0) buffer data9 { vec4 m_vNorm4f[]; }; // 
layout(binding = 10, set = 0) buffer data10 { int m_remapInst[]; }; // 
layout(binding = 11, set = 0) buffer data11 { uint m_matIdByPrimId[]; }; // 
layout(binding = 12, set = 0) buffer data12 { uvec2 m_pAccelStruct_m_abstractObjectPtrs[]; }; // 
layout(binding = 13, set = 0) buffer data13 { uint m_triIndices[]; }; // 
layout(binding = 14, set = 0) buffer data14 { mat4 m_normMatrices2[]; }; // 
layout(binding = 15, set = 0) buffer data15 { float m_films_eta_k_vec[]; }; // 
layout(binding = 16, set = 0) buffer data16 { uvec2 m_spec_offset_sz[]; }; // 
layout(binding = 17, set = 0) buffer data17 { AllBufferReferences all_references; }; // 
layout(binding = 18, set = 0) buffer data18 { uvec2 m_spec_tex_offset_sz[]; }; // 
layout(binding = 19, set = 0) buffer data19 { float m_spec_values[]; }; // 
layout(binding = 20, set = 0) buffer data20 { BVHNode m_pAccelStruct_m_origNodes[]; }; // 
layout(binding = 21, set = 0) buffer data21 { vec4 m_pAccelStruct_m_vertPos[]; }; // 
layout(binding = 22, set = 0) buffer data22 { SdfFrameOctreeNode m_pAccelStruct_m_SdfFrameOctreeNodes[]; }; // 
layout(binding = 23, set = 0) buffer data23 { vec4 m_pAccelStruct_m_vertNorm[]; }; // 
layout(binding = 24, set = 0) buffer data24 { uint m_pAccelStruct_m_SdfCompactOctreeV2Data[]; }; // 
layout(binding = 25, set = 0) buffer data25 { ivec4 m_pAccelStruct_m_SdfCompactOctreeRotModifiers[]; }; // 
layout(binding = 26, set = 0) buffer data26 { SdfSBSHeader m_pAccelStruct_m_SdfSBSHeaders[]; }; // 
layout(binding = 27, set = 0) buffer data27 { float m_pAccelStruct_m_SdfSBSDataF[]; }; // 
layout(binding = 28, set = 0) buffer data28 { LightSource m_lights[]; }; // 
layout(binding = 29, set = 0) buffer data29 { CatmulClarkHeader m_pAccelStruct_m_CatmulClarkHeaders[]; }; // 
layout(binding = 30, set = 0) buffer data30 { uint m_pAccelStruct_m_SdfFrameOctreeRoots[]; }; // 
layout(binding = 31, set = 0) buffer data31 { uvec2 m_spec_tex_ids_wavelengths[]; }; // 
layout(binding = 32, set = 0) buffer data32 { uint m_pAccelStruct_m_primIdCount[]; }; // 
layout(binding = 33, set = 0) buffer data33 { SdfSVSNode m_pAccelStruct_m_SdfSVSNodes[]; }; // 
layout(binding = 34, set = 0) buffer data34 { BVHNodePair m_pAccelStruct_m_allNodePairs[]; }; // 
layout(binding = 35, set = 0) buffer data35 { uint m_pAccelStruct_m_SdfSVSRoots[]; }; // 
layout(binding = 36, set = 0) buffer data36 { GeomData m_pAccelStruct_m_geomData[]; }; // 
layout(binding = 37, set = 0) buffer data37 { uint m_vertOffset[]; }; // 
layout(binding = 38, set = 0) buffer data38 { uint m_films_spec_id_vec[]; }; // 
layout(binding = 39, set = 0) buffer data39 { uint m_pAccelStruct_m_SdfSBSData[]; }; // 
layout(binding = 40, set = 0) buffer data40 { float m_pAccelStruct_m_NURBS_approxes[]; }; // 
layout(binding = 41, set = 0) buffer data41 { uvec2 m_pAccelStruct_startEnd[]; }; // 
layout(binding = 42, set = 0) buffer data42 { int m_allRemapLists[]; }; // 
layout(binding = 43, set = 0) buffer data43 { float m_pAccelStruct_m_NURBSData[]; }; // 
layout(binding = 44, set = 0) buffer data44 { int m_allRemapListsOffsets[]; }; // 
layout(binding = 45, set = 0) buffer data45 { RibbonHeader m_pAccelStruct_m_RibbonHeaders[]; }; // 
layout(binding = 46, set = 0) buffer data46 { uint m_pAccelStruct_m_SdfCompactOctreeV3Data[]; }; // 
layout(binding = 47, set = 0) buffer data47 { SdfSBSNode m_pAccelStruct_m_SdfSBSNodes[]; }; // 
layout(binding = 48, set = 0) buffer data48 { uint m_instIdToLightInstId[]; }; // 
layout(binding = 49, set = 0) buffer data49 { mat4 m_normMatrices[]; }; // 
layout(binding = 50, set = 0) uniform sampler2D m_textures[]; //
layout(binding = 51, set = 0) buffer data51 { uint m_pAccelStruct_m_SdfSBSRoots[]; }; // 
layout(binding = 52, set = 0) buffer data52 { Material m_materials[]; }; // 
layout(binding = 53, set = 0) buffer data53 { uint m_pAccelStruct_m_indices[]; }; // 
layout(binding = 54, set = 0) buffer data54 { InstanceData m_pAccelStruct_m_instanceData[]; }; // 
layout(binding = 55, set = 0) buffer data55 { float m_precomp_thin_films[]; }; // 
layout(binding = 56, set = 0) buffer data56 { float m_precomp_coat_transmittance[]; }; // 
layout(binding = 57, set = 0) buffer data57 { BVHNode m_pAccelStruct_m_nodesTLAS[]; }; // 
layout(binding = 58, set = 0) buffer data58 { NURBSHeader m_pAccelStruct_m_NURBSHeaders[]; }; // 
layout(binding = 59, set = 0) buffer dataUBO { Integrator_Generated_UBO_Data ubo; };


uint BinarySearchU2_m_spec_tex_ids_wavelengths(uint arrayOffset, uint array_sz, float val) {
  int last = int(array_sz) - 2, first = 1;
  while (last > 0) 
  {
    uint half = uint(last) >> 1, middle = uint(first) + half;
    bool predResult = float(m_spec_tex_ids_wavelengths[middle + arrayOffset].y) <= val;
    first = predResult ? int(middle + 1) : first;
    last = predResult ? last - int(half + 1) : int(half);
  }
  return uint(clamp(int(first - 1), 0, int(array_sz - 2)));
}

LightSample pointLightSampleRev_m_lights(uint a_pLightOffset) {
  LightSample res;
  res.pos    = m_lights[0 + a_pLightOffset].pos.xyz;
  res.norm   = m_lights[0 + a_pLightOffset].norm.xyz;
  res.isOmni = (m_lights[0 + a_pLightOffset].distType == LIGHT_DIST_OMNI);
  res.hasIES = (m_lights[0 + a_pLightOffset].iesId != uint(-1));
  res.pdf    = 1.0f; // evaluated later 
  return res;
}

LightSample sphereLightSampleRev_m_lights(uint a_pLightOffset, vec2 rands) {
  const float theta = 2.0f * M_PI * rands.x;
  const float phi   = acos(1.0f - 2.0f * rands.y);
  const float x     = sin(phi) * cos(theta);
  const float y     = sin(phi) * sin(theta);
  const float z     = cos(phi);
  const vec3 lcenter = m_lights[0 + a_pLightOffset].pos.xyz;
  const float  lradius   = m_lights[0 + a_pLightOffset].size.x;
  const vec3 samplePos = lcenter + (lradius*1.000001f)*vec3(x, y, z);
  LightSample res;
  res.pos  = samplePos;
  res.norm = normalize(samplePos - lcenter);
  res.isOmni = false;
  res.hasIES = (m_lights[0 + a_pLightOffset].iesId != uint(-1));
  res.pdf    = 1.0f; // evaluated later 
  return res;
}

LightSample directLightSampleRev_m_lights(uint a_pLightOffset, vec2 rands, vec3 illuminationPoint) {
  const vec3 norm = m_lights[0 + a_pLightOffset].norm.xyz;
  LightSample res;
  res.pos    = illuminationPoint - norm*100000.0f;
  res.norm   = norm;
  res.isOmni = false;
  res.hasIES = false;
  res.pdf    = 1.0f; // evaluated later 
  return res;
}

vec4 SampleUniformSpectrum_m_spec_values(uint a_spec_valuesOffset, vec4 a_wavelengths, uint a_sz) {
  const int  WAVESN = int(LAMBDA_MAX-LAMBDA_MIN);
  const ivec4 index1 = ivec4(min(max(a_wavelengths - vec4(LAMBDA_MIN), vec4(0.0f)), vec4(WAVESN - 1)));   
  const ivec4 index2 = min(index1 + ivec4(1), ivec4(WAVESN-1));

  // const float4 mask = {index1.x >= WAVESN ? 0 : 1, index1.y >= WAVESN ? 0 : 1, index1.z >= WAVESN ? 0 : 1, index1.w >= WAVESN ? 0 : 1};
  

  const vec4 x1 = vec4(LAMBDA_MIN) + vec4(index1);
  const vec4 y1 = vec4(m_spec_values[index1[0] + a_spec_valuesOffset],m_spec_values[index1[1] + a_spec_valuesOffset],m_spec_values[index1[2] + a_spec_valuesOffset],m_spec_values[index1[3] + a_spec_valuesOffset]); // TODO: reorder mem access for better cache: (index1[0], index2[0])
  const vec4 y2 = vec4(m_spec_values[index2[0] + a_spec_valuesOffset],m_spec_values[index2[1] + a_spec_valuesOffset],m_spec_values[index2[2] + a_spec_valuesOffset],m_spec_values[index2[3] + a_spec_valuesOffset]); // TODO: reorder mem access for better cache: (index1[1], index2[1])

  vec4 res = (y1 + (a_wavelengths - x1) * (y2 - y1));
  // if(std::isinf(res.x) || std::isnan(res.x) || res.x < 0)
  // {
  //   int a = 2;
  // }

  return res;
}

void dielectricSmoothSampleAndEval_m_materials(uint a_materialsOffset, const vec4 etaSpec, const float _extIOR, vec4 rands, vec3 v, vec3 n, vec2 tc, inout BsdfSample pRes) {
  const float extIOR = m_materials[0 + a_materialsOffset].data[DIELECTRIC_ETA_EXT];

  // if we hit the reverse side of the polygon, reverse the normal back (it was reversed in the RayTrace func.)
  // for correct computations in FrDielectricDetailed
  if ((pRes.flags & RAY_FLAG_HAS_INV_NORMAL) != 0) 
  {
    n = -1 * n;
  }

  vec3 s, t = n;
  CoordinateSystemV2(n, s, t);
  vec3 wi = vec3(dot(v, s),dot(v, t),dot(v, n));

  float eta = etaSpec.x / extIOR; // take IOR from the first wavelength


  vec4 fr = FrDielectricDetailedV2(wi.z, eta); 

  const float R = fr.x;
  const float cos_theta_t = fr.y;
  const float eta_it = fr.z;
  const float eta_ti = fr.w;  
  const float T = 1 - R;

  if(rands.x < R) // perfect specular reflection
  {
    vec3 wo = vec3(-wi.x,-wi.y,wi.z);
    pRes.val = vec4(R);
    pRes.pdf = R;
    pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
    pRes.flags |= RAY_EVENT_S;
    pRes.ior = _extIOR;
  }
  else // perfect specular transmission
  {
    vec3 wo = refract(wi, cos_theta_t, eta_ti);
    pRes.val = vec4((eta_ti * eta_ti) * T);
    pRes.pdf = T;
    pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
    pRes.flags |= (RAY_EVENT_S | RAY_EVENT_T);
    pRes.ior = (_extIOR == etaSpec.x) ? extIOR : etaSpec.x;
  }

  pRes.val /= max(abs(dot(pRes.dir, n)), 1e-6f);
}

void filmRoughSampleAndEval_m_materials_m_precomp_thin_films(uint a_materialsOffset, const float extIOR, const complex filmIOR, const complex intIOR, const float thickness, const vec4 a_wavelengths, const float _extIOR, vec4 rands, vec3 v, vec3 n, vec2 tc, vec3 alpha_tex, inout BsdfSample pRes, uint precomputed_dataOffset, const bool spectral_mode, const bool precomputed) {
  const uint transparFlag = floatBitsToUint(m_materials[0 + a_materialsOffset].data[FILM_TRANSPARENT]);
  bool reversed = false;
  uint32_t refl_offset;
  uint32_t refr_offset;
  if ((pRes.flags & RAY_FLAG_HAS_INV_NORMAL) != 0) // inside of object
  {
    n = -1 * n;
  }

  if (dot(v, n) < 0.f && intIOR.im < 0.001f)
  {
    reversed = true;
    refl_offset = FILM_ANGLE_RES * 2;
    refr_offset = FILM_ANGLE_RES * 3;
  }
  else
  {
    refl_offset = 0;
    refr_offset = FILM_ANGLE_RES;
  }

  const vec2 alpha = vec2(min(m_materials[0 + a_materialsOffset].data[FILM_ROUGH_V], alpha_tex.x),min(m_materials[0 + a_materialsOffset].data[FILM_ROUGH_U], alpha_tex.y));

  vec3 s, t = n;
  CoordinateSystemV2(n, s, t);
  vec3 wi = vec3(dot(v, s),dot(v, t),dot(v, n));

  float ior = intIOR.re / extIOR;
  if (reversed)
  {
    wi = -1 * wi;
    ior = 1.f / ior;
  }

  const vec3 wm = trSample(wi, vec2(rands.x,rands.y), alpha);

  float cosThetaI = clamp(abs(dot(wi, wm)), 0.00001f, 1.0f);
  vec4 R = vec4(0.0f), T = vec4(0.0f);

  if (spectral_mode)
  {
    if (precomputed)
    {
      float w = clamp((a_wavelengths[0] - LAMBDA_MIN) / (LAMBDA_MAX - LAMBDA_MIN), 0.f, 1.f);
      float theta = clamp(acos(cosThetaI) * 2.f / M_PI, 0.f, 1.f);
      w *= FILM_LENGTH_RES - 1;
      theta *= FILM_ANGLE_RES - 1;
      uint index1 = min(uint32_t(w), uint32_t(FILM_LENGTH_RES - 2));
      uint index2 = min(uint32_t(theta), uint32_t(FILM_ANGLE_RES - 2));

      float alpha = w - float(index1);
      float beta = theta - float(index2);

      float v0 = mix(m_precomp_thin_films[refl_offset * FILM_LENGTH_RES + index1 * FILM_ANGLE_RES + index2 + precomputed_dataOffset], m_precomp_thin_films[refl_offset * FILM_LENGTH_RES + (index1 + 1) * FILM_ANGLE_RES + index2 + precomputed_dataOffset], alpha);
      float v1 = mix(m_precomp_thin_films[refl_offset * FILM_LENGTH_RES + index1 * FILM_ANGLE_RES + index2 + 1 + precomputed_dataOffset], m_precomp_thin_films[refl_offset * FILM_LENGTH_RES + (index1 + 1) * FILM_ANGLE_RES + index2 + 1 + precomputed_dataOffset], alpha);
      R[0] = mix(v0, v1, beta);

      v0 = mix(m_precomp_thin_films[refr_offset * FILM_LENGTH_RES + index1 * FILM_ANGLE_RES + index2 + precomputed_dataOffset], m_precomp_thin_films[refr_offset * FILM_LENGTH_RES + (index1 + 1) * FILM_ANGLE_RES + index2 + precomputed_dataOffset], alpha);
      v1 = mix(m_precomp_thin_films[refr_offset * FILM_LENGTH_RES + index1 * FILM_ANGLE_RES + index2 + 1 + precomputed_dataOffset], m_precomp_thin_films[refr_offset * FILM_LENGTH_RES + (index1 + 1) * FILM_ANGLE_RES + index2 + 1 + precomputed_dataOffset], alpha);
      T[0] = mix(v0, v1, beta);
    }
    else 
    {
      if (!reversed)
      {
        FrReflRefr result = FrFilm(cosThetaI, to_complex(extIOR), filmIOR, intIOR, thickness, a_wavelengths[0]);
        R[0] = result.refl;
        T[0] = result.refr;
      }
      else
      {
        FrReflRefr result = FrFilm(cosThetaI, intIOR, filmIOR, to_complex(extIOR), thickness, a_wavelengths[0]);
        R[0] = result.refl;
        T[0] = result.refr;
      }
    }
  }
  else
  {
    float theta = clamp(acos(cosThetaI) * 2.f / M_PI, 0.f, 1.f);
    theta *= FILM_ANGLE_RES - 1;
    if (floatBitsToUint((m_materials[0 + a_materialsOffset].data[FILM_THICKNESS_MAP])) == 1u)
    {
      float thickness_min = m_materials[0 + a_materialsOffset].data[FILM_THICKNESS_MIN];
      float thickness_max = m_materials[0 + a_materialsOffset].data[FILM_THICKNESS_MAX];
      float t = clamp((thickness - thickness_min) / (thickness_max - thickness_min), 0.f, 1.f);
      t *= FILM_THICKNESS_RES - 1;
      uint index1 = min(uint32_t(t), uint32_t(FILM_THICKNESS_RES - 2));
      uint index2 = min(uint32_t(theta), uint32_t(FILM_ANGLE_RES - 2));

      float alpha = t - float(index1);
      float beta = theta - float(index2);

      uint a = (refl_offset * FILM_THICKNESS_RES + index1 * FILM_ANGLE_RES + index2) * 3;
      uint b = (refl_offset * FILM_THICKNESS_RES + (index1 + 1) * FILM_ANGLE_RES + index2) * 3;
      uint c = (refl_offset * FILM_THICKNESS_RES + index1 * FILM_ANGLE_RES + index2 + 1) * 3;
      uint d = (refl_offset * FILM_THICKNESS_RES + (index1 + 1) * FILM_ANGLE_RES + index2 + 1) * 3;

      float v0 = mix(m_precomp_thin_films[a + precomputed_dataOffset], m_precomp_thin_films[b + precomputed_dataOffset], alpha);
      float v1 = mix(m_precomp_thin_films[c + precomputed_dataOffset], m_precomp_thin_films[d + precomputed_dataOffset], alpha);
      R[0] = mix(v0, v1, beta);

      v0 = mix(m_precomp_thin_films[a + 1 + precomputed_dataOffset], m_precomp_thin_films[b + 1 + precomputed_dataOffset], alpha);
      v1 = mix(m_precomp_thin_films[c + 1 + precomputed_dataOffset], m_precomp_thin_films[d + 1 + precomputed_dataOffset], alpha);
      R[1] = mix(v0, v1, beta);

      v0 = mix(m_precomp_thin_films[a + 2 + precomputed_dataOffset], m_precomp_thin_films[b + 2 + precomputed_dataOffset], alpha);
      v1 = mix(m_precomp_thin_films[c + 2 + precomputed_dataOffset], m_precomp_thin_films[d + 2 + precomputed_dataOffset], alpha);
      R[2] = mix(v0, v1, beta);

      a = (refr_offset * FILM_THICKNESS_RES + index1 * FILM_ANGLE_RES + index2) * 3;
      b = (refr_offset * FILM_THICKNESS_RES + (index1 + 1) * FILM_ANGLE_RES + index2) * 3;
      c = (refr_offset * FILM_THICKNESS_RES + index1 * FILM_ANGLE_RES + index2 + 1) * 3;
      d = (refr_offset * FILM_THICKNESS_RES + (index1 + 1) * FILM_ANGLE_RES + index2 + 1) * 3;

      v0 = mix(m_precomp_thin_films[a + precomputed_dataOffset], m_precomp_thin_films[b + precomputed_dataOffset], alpha);
      v1 = mix(m_precomp_thin_films[c + precomputed_dataOffset], m_precomp_thin_films[d + precomputed_dataOffset], alpha);
      T[0] = mix(v0, v1, beta);

      v0 = mix(m_precomp_thin_films[a + 1 + precomputed_dataOffset], m_precomp_thin_films[b + 1 + precomputed_dataOffset], alpha);
      v1 = mix(m_precomp_thin_films[c + 1 + precomputed_dataOffset], m_precomp_thin_films[d + 1 + precomputed_dataOffset], alpha);
      T[1] = mix(v0, v1, beta);

      v0 = mix(m_precomp_thin_films[a + 2 + precomputed_dataOffset], m_precomp_thin_films[b + 2 + precomputed_dataOffset], alpha);
      v1 = mix(m_precomp_thin_films[c + 2 + precomputed_dataOffset], m_precomp_thin_films[d + 2 + precomputed_dataOffset], alpha);
      T[2] = mix(v0, v1, beta);
    }
    else
    {
      uint index = min(uint32_t(theta), uint32_t(FILM_ANGLE_RES - 2));

      float alpha = theta - float(index);

      R[0] = mix(m_precomp_thin_films[(refl_offset + index) * 3 + precomputed_dataOffset], m_precomp_thin_films[(refl_offset + index + 1) * 3 + precomputed_dataOffset], alpha);
      R[1] = mix(m_precomp_thin_films[(refl_offset + index) * 3 + 1 + precomputed_dataOffset], m_precomp_thin_films[(refl_offset + index + 1) * 3 + 1 + precomputed_dataOffset], alpha);
      R[2] = mix(m_precomp_thin_films[(refl_offset + index) * 3 + 2 + precomputed_dataOffset], m_precomp_thin_films[(refl_offset + index + 1) * 3 + 2 + precomputed_dataOffset], alpha);

      T[0] = mix(m_precomp_thin_films[(refr_offset + index) * 3 + precomputed_dataOffset], m_precomp_thin_films[(refr_offset + index + 1) * 3 + precomputed_dataOffset], alpha);
      T[1] = mix(m_precomp_thin_films[(refr_offset + index) * 3 + 1 + precomputed_dataOffset], m_precomp_thin_films[(refr_offset + index + 1) * 3 + 1 + precomputed_dataOffset], alpha);
      T[2] = mix(m_precomp_thin_films[(refr_offset + index) * 3 + 2 + precomputed_dataOffset], m_precomp_thin_films[(refr_offset + index + 1) * 3 + 2 + precomputed_dataOffset], alpha);
    }
  }
  
  if (intIOR.im > 0.001f || transparFlag == 0)
  {
    vec3 wo = reflect((-1.0f) * wi, wm);
    if (wi.z < 0.f || wo.z <= 0.f)
    {
      return;
    }
    const float cos_theta_i = max(wi.z, EPSILON_32);
    const float cos_theta_o = max(wo.z, EPSILON_32);
    pRes.pdf = trPDF(wi, wm, alpha) / (4.0f * abs(dot(wi, wm)));
    pRes.val = trD(wm, alpha) * microfacet_G(wi, wo, wm, alpha) * R / (4.0f * cos_theta_i * cos_theta_o);
    if (reversed)
    {
      wo = -1 * wo;
    }
    pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
    pRes.flags = RAY_FLAG_HAS_NON_SPEC;
    pRes.ior = _extIOR;
  }
  else
  {
    if (rands.w * (sum(R) + sum(T)) < sum(R))
    {
      vec3 wo = reflect((-1.0f) * wi, wm);
      if (wi.z < 0.f || wo.z <= 0.f)
      {
        return;
      }
      const float cos_theta_i = max(wi.z, EPSILON_32);
      const float cos_theta_o = max(wo.z, EPSILON_32);
      pRes.pdf = trPDF(wi, wm, alpha) / (4.0f * abs(dot(wi, wm))) * sum(R) / (sum(R) + sum(T));
      pRes.val = trD(wm, alpha) * microfacet_G(wi, wo, wm, alpha) * R / (4.0f * cos_theta_i * cos_theta_o);
      if (reversed)
      {
        wo = -1 * wo;
      }
      pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
      pRes.flags = RAY_FLAG_HAS_NON_SPEC;
      pRes.ior = _extIOR;
    }
    else
    {
      vec4 fr = FrDielectricDetailedV2(dot(wi, wm), ior);
      const float cosThetaT = fr.y;
      const float eta_it = fr.z;
      const float eta_ti = fr.w;  

      vec3 ws,  wt;
      CoordinateSystemV2(wm, ws, wt);
      const vec3 local_wi = vec3(dot(ws, wi),dot(wt, wi),dot(wm, wi));
      const vec3 local_wo = refract(local_wi, cosThetaT, eta_ti);
      vec3 wo = local_wo.x * ws + local_wo.y * wt + local_wo.z * wm;
      if (wo.z > 0.f)
      {
        return;
      }
      const float cos_theta_i = max(wi.z, EPSILON_32);
      const float cos_theta_o = min(wo.z, -EPSILON_32);
      if (abs(eta_it - 1.f) <= 1e-6f)
      {
        pRes.pdf = trPDF(wi, wm, alpha) / (4.0f * abs(dot(wi, wm))) * sum(T) / (sum(R) + sum(T));
        pRes.val = trD(wm, alpha) * microfacet_G(wi, wo, wm, alpha) * T / (4.0f * -cos_theta_i * cos_theta_o);
      }
      else
      {
        float denom = sqr(dot(wo, wm) + dot(wi, wm) / eta_it);
        float dwm_dwi = abs(dot(wo, wm)) / denom;
        pRes.pdf = trPDF(wi, wm, alpha) * dwm_dwi * sum(T) / (sum(R) + sum(T));
        pRes.val = trD(wm, alpha) * microfacet_G(wi, wo, wm, alpha) * T * abs(dot(wi, wm) * dot(wo, wm) / (cos_theta_i * cos_theta_o * denom));
      }
      if (reversed)
      {
        wo = -1 * wo;
      }
      pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
      pRes.flags = RAY_FLAG_HAS_NON_SPEC;
      pRes.ior = (_extIOR == intIOR.re) ? extIOR : intIOR.re;
    }
  }
}

void filmSmoothSampleAndEval_m_materials_m_precomp_thin_films(uint a_materialsOffset, const float extIOR, const complex filmIOR, const complex intIOR, const float thickness, const vec4 a_wavelengths, const float _extIOR, vec4 rands, vec3 v, vec3 n, vec2 tc, inout BsdfSample pRes, uint precomputed_dataOffset, const bool spectral_mode, const bool precomputed) {
  const uint transparFlag = floatBitsToUint((m_materials[0 + a_materialsOffset].data[FILM_TRANSPARENT]));
  bool reversed = false;
  uint32_t refl_offset;
  uint32_t refr_offset;
  if ((pRes.flags & RAY_FLAG_HAS_INV_NORMAL) != 0) // inside of object
  {
    n = -1 * n;
  }
  if (dot(n, v) < 0.f && intIOR.im < 0.001f)
  {
    reversed = true;
    refl_offset = FILM_ANGLE_RES * 2;
    refr_offset = FILM_ANGLE_RES * 3;
  }
  else
  {
    refl_offset = 0;
    refr_offset = FILM_ANGLE_RES;
  }

  vec3 s, t = n;
  CoordinateSystemV2(n, s, t);
  vec3 wi = vec3(dot(v, s),dot(v, t),dot(v, n));

  float cosThetaI = clamp(abs(wi.z), 0.0001f, 1.0f);
  float ior = intIOR.re / extIOR;
  vec4 R = vec4(0.0f), T = vec4(0.0f);

  if (spectral_mode)
  {
    if (precomputed)
    {
      float w = clamp((a_wavelengths[0] - LAMBDA_MIN) / (LAMBDA_MAX - LAMBDA_MIN), 0.f, 1.f);
      float theta = clamp(acos(cosThetaI) * 2.f / M_PI, 0.f, 1.f);
      w *= FILM_LENGTH_RES - 1;
      theta *= FILM_ANGLE_RES - 1;
      uint index1 = min(uint32_t(w), uint32_t(FILM_LENGTH_RES - 2));
      uint index2 = min(uint32_t(theta), uint32_t(FILM_ANGLE_RES - 2));

      float alpha = w - float(index1);
      float beta = theta - float(index2);

      float v0 = mix(m_precomp_thin_films[refl_offset * FILM_LENGTH_RES + index1 * FILM_ANGLE_RES + index2 + precomputed_dataOffset], m_precomp_thin_films[refl_offset * FILM_LENGTH_RES + (index1 + 1) * FILM_ANGLE_RES + index2 + precomputed_dataOffset], alpha);
      float v1 = mix(m_precomp_thin_films[refl_offset * FILM_LENGTH_RES + index1 * FILM_ANGLE_RES + index2 + 1 + precomputed_dataOffset], m_precomp_thin_films[refl_offset * FILM_LENGTH_RES + (index1 + 1) * FILM_ANGLE_RES + index2 + 1 + precomputed_dataOffset], alpha);
      R[0] = mix(v0, v1, beta);

      v0 = mix(m_precomp_thin_films[refr_offset * FILM_LENGTH_RES + index1 * FILM_ANGLE_RES + index2 + precomputed_dataOffset], m_precomp_thin_films[refr_offset * FILM_LENGTH_RES + (index1 + 1) * FILM_ANGLE_RES + index2 + precomputed_dataOffset], alpha);
      v1 = mix(m_precomp_thin_films[refr_offset * FILM_LENGTH_RES + index1 * FILM_ANGLE_RES + index2 + 1 + precomputed_dataOffset], m_precomp_thin_films[refr_offset * FILM_LENGTH_RES + (index1 + 1) * FILM_ANGLE_RES + index2 + 1 + precomputed_dataOffset], alpha);
      T[0] = mix(v0, v1, beta);
    }
    else 
    {
      if (!reversed)
      {
        FrReflRefr result = FrFilm(cosThetaI, to_complex(extIOR), filmIOR, intIOR, thickness, a_wavelengths[0]);
        R[0] = result.refl;
        T[0] = result.refr;
      }
      else
      {
        FrReflRefr result = FrFilm(cosThetaI, intIOR, filmIOR, to_complex(extIOR), thickness, a_wavelengths[0]);
        R[0] = result.refl;
        T[0] = result.refr;
      }
    }
  }
  else
  {
    float theta = clamp(acos(cosThetaI) * 2.f / M_PI, 0.f, 1.f);
    theta *= FILM_ANGLE_RES - 1;
    if (floatBitsToUint((m_materials[0 + a_materialsOffset].data[FILM_THICKNESS_MAP])) == 1u)
    {
      float thickness_min = m_materials[0 + a_materialsOffset].data[FILM_THICKNESS_MIN];
      float thickness_max = m_materials[0 + a_materialsOffset].data[FILM_THICKNESS_MAX];
      float t = clamp((thickness - thickness_min) / (thickness_max - thickness_min), 0.f, 1.f);
      t *= FILM_THICKNESS_RES - 1;
      uint index1 = min(uint32_t(t), uint32_t(FILM_THICKNESS_RES - 2));
      uint index2 = min(uint32_t(theta), uint32_t(FILM_ANGLE_RES - 2));

      float alpha = t - float(index1);
      float beta = theta - float(index2);

      uint a = (refl_offset * FILM_THICKNESS_RES + index1 * FILM_ANGLE_RES + index2) * 3;
      uint b = (refl_offset * FILM_THICKNESS_RES + (index1 + 1) * FILM_ANGLE_RES + index2) * 3;
      uint c = (refl_offset * FILM_THICKNESS_RES + index1 * FILM_ANGLE_RES + index2 + 1) * 3;
      uint d = (refl_offset * FILM_THICKNESS_RES + (index1 + 1) * FILM_ANGLE_RES + index2 + 1) * 3;

      float v0 = mix(m_precomp_thin_films[a + precomputed_dataOffset], m_precomp_thin_films[b + precomputed_dataOffset], alpha);
      float v1 = mix(m_precomp_thin_films[c + precomputed_dataOffset], m_precomp_thin_films[d + precomputed_dataOffset], alpha);
      R[0] = mix(v0, v1, beta);

      v0 = mix(m_precomp_thin_films[a + 1 + precomputed_dataOffset], m_precomp_thin_films[b + 1 + precomputed_dataOffset], alpha);
      v1 = mix(m_precomp_thin_films[c + 1 + precomputed_dataOffset], m_precomp_thin_films[d + 1 + precomputed_dataOffset], alpha);
      R[1] = mix(v0, v1, beta);

      v0 = mix(m_precomp_thin_films[a + 2 + precomputed_dataOffset], m_precomp_thin_films[b + 2 + precomputed_dataOffset], alpha);
      v1 = mix(m_precomp_thin_films[c + 2 + precomputed_dataOffset], m_precomp_thin_films[d + 2 + precomputed_dataOffset], alpha);
      R[2] = mix(v0, v1, beta);

      a = (refr_offset * FILM_THICKNESS_RES + index1 * FILM_ANGLE_RES + index2) * 3;
      b = (refr_offset * FILM_THICKNESS_RES + (index1 + 1) * FILM_ANGLE_RES + index2) * 3;
      c = (refr_offset * FILM_THICKNESS_RES + index1 * FILM_ANGLE_RES + index2 + 1) * 3;
      d = (refr_offset * FILM_THICKNESS_RES + (index1 + 1) * FILM_ANGLE_RES + index2 + 1) * 3;

      v0 = mix(m_precomp_thin_films[a + precomputed_dataOffset], m_precomp_thin_films[b + precomputed_dataOffset], alpha);
      v1 = mix(m_precomp_thin_films[c + precomputed_dataOffset], m_precomp_thin_films[d + precomputed_dataOffset], alpha);
      T[0] = mix(v0, v1, beta);

      v0 = mix(m_precomp_thin_films[a + 1 + precomputed_dataOffset], m_precomp_thin_films[b + 1 + precomputed_dataOffset], alpha);
      v1 = mix(m_precomp_thin_films[c + 1 + precomputed_dataOffset], m_precomp_thin_films[d + 1 + precomputed_dataOffset], alpha);
      T[1] = mix(v0, v1, beta);

      v0 = mix(m_precomp_thin_films[a + 2 + precomputed_dataOffset], m_precomp_thin_films[b + 2 + precomputed_dataOffset], alpha);
      v1 = mix(m_precomp_thin_films[c + 2 + precomputed_dataOffset], m_precomp_thin_films[d + 2 + precomputed_dataOffset], alpha);
      T[2] = mix(v0, v1, beta);
    }
    else
    {
      uint index = min(uint32_t(theta), uint32_t(FILM_ANGLE_RES - 2));

      float alpha = theta - float(index);

      R[0] = mix(m_precomp_thin_films[(refl_offset + index) * 3 + precomputed_dataOffset], m_precomp_thin_films[(refl_offset + index + 1) * 3 + precomputed_dataOffset], alpha);
      R[1] = mix(m_precomp_thin_films[(refl_offset + index) * 3 + 1 + precomputed_dataOffset], m_precomp_thin_films[(refl_offset + index + 1) * 3 + 1 + precomputed_dataOffset], alpha);
      R[2] = mix(m_precomp_thin_films[(refl_offset + index) * 3 + 2 + precomputed_dataOffset], m_precomp_thin_films[(refl_offset + index + 1) * 3 + 2 + precomputed_dataOffset], alpha);

      T[0] = mix(m_precomp_thin_films[(refr_offset + index) * 3 + precomputed_dataOffset], m_precomp_thin_films[(refr_offset + index + 1) * 3 + precomputed_dataOffset], alpha);
      T[1] = mix(m_precomp_thin_films[(refr_offset + index) * 3 + 1 + precomputed_dataOffset], m_precomp_thin_films[(refr_offset + index + 1) * 3 + 1 + precomputed_dataOffset], alpha);
      T[2] = mix(m_precomp_thin_films[(refr_offset + index) * 3 + 2 + precomputed_dataOffset], m_precomp_thin_films[(refr_offset + index + 1) * 3 + 2 + precomputed_dataOffset], alpha);
    }
  }

  if (intIOR.im > 0.001f || transparFlag == 0)
  {
    vec3 wo = vec3(-wi.x,-wi.y,wi.z);
    pRes.val = R;
    pRes.pdf = 1.f;
    pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
    pRes.flags |= RAY_EVENT_S;
    pRes.ior = _extIOR;
  }
  else
  {
    if (rands.x * (sum(R) + sum(T)) < sum(R))
    {
      vec3 wo = vec3(-wi.x,-wi.y,wi.z);
      pRes.val = R;
      pRes.pdf = sum(R) / (sum(R) + sum(T));
      pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
      pRes.flags |= RAY_EVENT_S;
      pRes.ior = _extIOR;
    }
    else
    {
      vec4 fr = FrDielectricDetailedV2(wi.z, ior);
      const float cosThetaT = fr.y;
      const float eta_ti = fr.w;  

      vec3 wo = refract(wi, cosThetaT, eta_ti);
      pRes.val = T;
      pRes.pdf = sum(T) / (sum(R) + sum(T));
      pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
      pRes.flags |= (RAY_EVENT_S | RAY_EVENT_T);
      pRes.ior = (_extIOR == intIOR.re) ? extIOR : intIOR.re;
    }
  }

  pRes.val /= max(abs(dot(pRes.dir, n)), 1e-6f);
}

void plasticSampleAndEval_m_materials_m_precomp_coat_transmittance(uint a_materialsOffset, vec4 a_reflSpec, vec4 rands, vec3 v, vec3 n, vec2 tc, inout BsdfSample pRes, uint transmittanceOffset) {
  const float alpha         = m_materials[0 + a_materialsOffset].data[PLASTIC_ROUGHNESS];
  const float eta           = m_materials[0 + a_materialsOffset].data[PLASTIC_IOR_RATIO];
  const float spec_weight   = m_materials[0 + a_materialsOffset].data[PLASTIC_SPEC_SAMPLE_WEIGHT];
  const uint  nonlinear     = m_materials[0 + a_materialsOffset].nonlinear;
  const float internal_refl = m_materials[0 + a_materialsOffset].data[PLASTIC_PRECOMP_REFLECTANCE];
  const vec2 alpha2 = vec2(alpha,alpha);

  vec3 s = n;
  vec3 t = n;
  CoordinateSystemV2(n, s, t);
  
  const vec3 wi = vec3(dot(v, s),dot(v, t),dot(v, n));
  if(wi.z <= 0)
    return;

  const float cos_theta_i = max(wi.z, EPSILON_32);

  // float t_i = lerp_gather(transmittance, cos_theta_i, MI_ROUGH_TRANSMITTANCE_RES);
  float t_i = 0.0f;
  {
    float x = cos_theta_i;
    x *= float(MI_ROUGH_TRANSMITTANCE_RES - 1);
    uint index = min(uint32_t(x), uint32_t(MI_ROUGH_TRANSMITTANCE_RES - 2));

    float v0 = m_precomp_coat_transmittance[index + transmittanceOffset];
    float v1 = m_precomp_coat_transmittance[index + 1 + transmittanceOffset];

    t_i = mix(v0, v1, x - float(index));
  }

  float prob_specular = (1.f - t_i) * spec_weight;
  float prob_diffuse  = t_i * (1.f - spec_weight);

  if(prob_diffuse != 0.0f && prob_specular != 0.0f)
  {
    prob_specular = prob_specular / (prob_specular + prob_diffuse);
    prob_diffuse  = 1.f - prob_specular;
  }
  else
  {
    prob_diffuse  = 1.0f;
    prob_specular = 0.0f;
  }

  const bool sample_specular = rands.z < prob_specular;
  const bool sample_diffuse = !sample_specular;

  vec3 wo = vec3(0.0f,0.0f,0.0f);
  if(sample_specular)
  {
    const vec3 wm = (sample_visible_normal(wi, vec2(rands.x,rands.y), alpha2)).xyz;
    wo = reflect((-1.0f) * wi, wm);
  }

  if(sample_diffuse)
  {
    wo = square_to_cosine_hemisphere(vec2(rands.x,rands.y));
  }

  if(cos_theta_i * wo.z <= 0)
  {
    return;
  }

  const float cos_theta_o = max(wo.z, EPSILON_32);

  vec3 H = normalize(wo + wi);
  float  D = eval_microfacet(H, alpha2, 1);

  float pdf = D * smith_g1(wi, H, alpha2) / (4.f * cos_theta_i);
  pdf *= prob_specular;
  pdf += prob_diffuse * INV_PI * cos_theta_o;

  const float F = FrDielectric(dot(wi, H), eta); 
  float G = microfacet_G(wi, wo, H, alpha2);
  float val = F * D * G / (4.f * cos_theta_i * cos_theta_o);

  // float t_o = lerp_gather(transmittance, cos_theta_o, MI_ROUGH_TRANSMITTANCE_RES); 
  float t_o = 0.0f;
  {
    float x = cos_theta_o;
    x *= float(MI_ROUGH_TRANSMITTANCE_RES - 1);
    uint index = min(uint32_t(x), uint32_t(MI_ROUGH_TRANSMITTANCE_RES - 2));

    float v0 = m_precomp_coat_transmittance[index + transmittanceOffset];
    float v1 = m_precomp_coat_transmittance[index + 1 + transmittanceOffset];

    t_o = mix(v0, v1, x - float(index));
  }

  vec4 diffuse = a_reflSpec / (1.f - (nonlinear > 0 ? (a_reflSpec * internal_refl) : vec4(internal_refl)));
  const float inv_eta_2 = 1.f / (eta * eta);

  pRes.dir   = normalize(wo.x * s + wo.y * t + wo.z * n);
  pRes.val   = vec4(val) + diffuse * (INV_PI * inv_eta_2 * /*cos_theta_o **/ t_i * t_o );
  pRes.pdf   = pdf;
  pRes.flags = RAY_FLAG_HAS_NON_SPEC;
}

float evalMap2DPdf_m_pdfLightData(vec2 texCoordT, uint intervalsOffset, const int sizeX, const int sizeY) {  
  const float fw = float(sizeX);
  const float fh = float(sizeY);
  
  //texCoordT.x = WrapVal(texCoordT.x);
  //texCoordT.y = WrapVal(texCoordT.y);

  if (texCoordT.x < 0.0f || texCoordT.x > 1.0f) texCoordT.x -= float((int((texCoordT.x))));
  if (texCoordT.y < 0.0f || texCoordT.x > 1.0f) texCoordT.y -= float((int((texCoordT.y))));

  int pixelX = int((fw*texCoordT.x - 0.5f));
  int pixelY = int((fh*texCoordT.y - 0.5f));

  if (pixelX >= sizeX) pixelX = sizeX - 1;
  if (pixelY >= sizeY) pixelY = sizeY - 1;

  if (pixelX < 0) pixelX += sizeX;
  if (pixelY < 0) pixelY += sizeY;

  const int pixelOffset = pixelY*sizeX + pixelX;
  const int maxSize     = sizeX*sizeY;
  const int offset0     = (pixelOffset + 0 < maxSize+0) ? pixelOffset + 0 : maxSize - 1;
  const int offset1     = (pixelOffset + 1 < maxSize+1) ? pixelOffset + 1 : maxSize;

  const vec2 interval = vec2(m_pdfLightData[offset0 + intervalsOffset], m_pdfLightData[offset1 + intervalsOffset]);
  
  return (interval.y - interval.x)*(fw*fh)/m_pdfLightData[sizeX*sizeY + intervalsOffset];
}

int SelectIndexPropToOpt_m_pdfLightData(const float a_r, uint a_accumOffset, const int N, inout float pPDF) {
  int leftBound  = 0;
  int rightBound = N - 2; // because a_accum[N-1] == summ(a_accum[0 .. N-2]).
  int counter    = 0;
  int currPos    = -1;

  const int maxStep = 50;
  const float x = a_r*m_pdfLightData[N - 1 + a_accumOffset];

  while (rightBound - leftBound > 1 && counter < maxStep)
  {
    const int currSize = rightBound + leftBound;
    const int currPos1 = (currSize % 2 == 0) ? (currSize + 1) / 2 : (currSize + 0) / 2;

    const float a = m_pdfLightData[currPos1 + 0 + a_accumOffset];
    const float b = m_pdfLightData[currPos1 + 1 + a_accumOffset];

    if (a < x && x <= b)
    {
      currPos = currPos1;
      break;
    }
    else if (x <= a)
      rightBound = currPos1;
    else if (x > b)
      leftBound = currPos1;

    counter++;
  }

  if (currPos < 0) // check the rest intervals
  {
    const float a1 = m_pdfLightData[leftBound + 0 + a_accumOffset];
    const float b1 = m_pdfLightData[leftBound + 1 + a_accumOffset];
    const float a2 = m_pdfLightData[rightBound + 0 + a_accumOffset];
    const float b2 = m_pdfLightData[rightBound + 1 + a_accumOffset];
    if (a1 < x && x <= b1)
      currPos = leftBound;
    if (a2 < x && x <= b2)
      currPos = rightBound;
  }

  if (x == 0.0f)
    currPos = 0;
  else if (currPos < 0)
    currPos = (rightBound + leftBound + 1) / 2;

  (pPDF) = (m_pdfLightData[currPos + 1 + a_accumOffset] - m_pdfLightData[currPos + a_accumOffset]) / m_pdfLightData[N - 1 + a_accumOffset];
  return currPos;
}

void glassSampleAndEval_m_materials(uint a_materialsOffset, const vec4 a_rands, const vec3 a_viewDir, const vec3 a_normal, const vec2 a_tc, inout BsdfSample a_pRes, inout MisData a_misPrev) {
  // PLEASE! use 'a_materials[0].' for a while ... , not a_materials-> and not *(a_materials).
  const vec4 colorReflect = m_materials[0 + a_materialsOffset].colors[GLASS_COLOR_REFLECT];   
  const vec4 colorTransp = m_materials[0 + a_materialsOffset].colors[GLASS_COLOR_TRANSP];
  const float  ior                  = m_materials[0 + a_materialsOffset].data[GLASS_FLOAT_IOR];

  const vec3 rayDir = (-1.0f) * a_viewDir;
  float relativeIor   = ior / a_misPrev.ior;

  if ((a_pRes.flags & RAY_FLAG_HAS_INV_NORMAL) != 0) // hit the reverse side of the polygon from the volume
  {
    if (a_misPrev.ior == ior) // in the previous hit there was material with a equal IOR
      relativeIor = 1.0f / ior;
  }

  const float fresnel = fresnel2(a_viewDir, a_normal, relativeIor);

  vec3 dir;

  if (a_rands.w < fresnel) // reflection
  {
    dir            = reflect2(rayDir, a_normal);
    a_pRes.val    =  colorReflect;
    a_pRes.flags |= RAY_EVENT_S;
  }
  else
  {
    dir            = refract2(rayDir, a_normal, relativeIor);
    a_pRes.val    = colorTransp;
    a_misPrev.ior = ior;
    a_pRes.flags |= (RAY_EVENT_S | RAY_EVENT_T);
  }

  const float cosThetaOut = abs(dot(dir, a_normal));
  
  a_pRes.val      /= max(cosThetaOut, 1e-6f);// BSDF is multiplied (outside) by cosThetaOut. For mirrors this shouldn't be done, so we pre-divide here instead.
  a_pRes.dir       = dir;
  a_pRes.pdf       = 1.0f;
}

void gltfEval_m_materials(uint a_materialsOffset, vec3 l, vec3 v, vec3 n, vec2 tc, vec4 baseColor, vec4 fourParams, inout BsdfEval res) {
  const uint   cflags     = m_materials[0 + a_materialsOffset].cflags;
  const vec4 metalCol = m_materials[0 + a_materialsOffset].colors[GLTF_COLOR_METAL]*baseColor;
  const vec4 coatCol = m_materials[0 + a_materialsOffset].colors[GLTF_COLOR_COAT];
  const float  roughness  = clamp(1.0f - m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_GLOSINESS]*fourParams.x, 0.0f, 1.0f);
        float  metalness  = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_ALPHA]*fourParams.y;
  const float  coatValue  = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_REFL_COAT]*fourParams.z;      
  const float  fresnelIOR = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_IOR];

  if(cflags == GLTF_COMPONENT_METAL) // assume only GGX-based metal
    metalness = 1.0f;
      
  float ggxVal, ggxPdf, VdotH; 
  if(roughness != 0.0f) // perfect specular reflection in coating layer
  {
    ggxVal = ggxEvalBSDF(l, v, n, roughness);
    ggxPdf = ggxEvalPDF (l, v, n, roughness);
    VdotH  = dot(v,normalize(v + l));
  }
  else
  {
    ggxVal = 0.0f;
    ggxPdf = 0.0f;
    VdotH  = dot(v,n);
  }

  float lambertVal       = lambertEvalBSDF(l, v, n);
  const float lambertPdf = lambertEvalPDF (l, v, n);
  float f_i              = 1.0f;
  float coeffLambertPdf  = 1.0f;
      
  if(coatValue > 0.0f && metalness < 1.0f && fresnelIOR > 0.0f) // Plastic, account for retroreflection between surface and coating layer
  {
    f_i                   = FrDielectricPBRT(abs(dot(v,n)), 1.0f, fresnelIOR);
    const float f_o       = FrDielectricPBRT(abs(dot(l,n)), 1.0f, fresnelIOR);  
    const float m_fdr_int = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_MI_FDR_INT];
    const float coeff     = mix(1.0f, (1.f - f_i) * (1.f - f_o) / (fresnelIOR*fresnelIOR*(1.f - m_fdr_int)), coatValue);
    lambertVal           *= coeff;
    coeffLambertPdf       = coeff; 
  }
  
  const vec4 fConductor = hydraFresnelCond(metalCol, VdotH, fresnelIOR, roughness); // (1) eval metal component      
  const vec4 specularColor = ggxVal*fConductor;                                        // eval metal specular component

  const float prob_specular = 0.5f*coatValue;
  const float prob_diffuse  = 1.0f-prob_specular;

  const vec4 dielectricVal = lambertVal * baseColor + ggxVal * coatCol * f_i * coatValue;
  const float  dielectricPdf = lambertPdf * prob_diffuse + ggxPdf*prob_specular; 

  res.val = metalness * specularColor + (1.0f - metalness) * dielectricVal; // (3) accumulate final color and pdf
  res.pdf = metalness * ggxPdf        + (1.0f - metalness) * dielectricPdf; // (3) accumulate final color and pdf
}

LightSample areaLightSampleRev_m_lights(uint a_pLightOffset, vec2 rands) {
  vec2 sampleOff = 2.0f * (vec2(-0.5f,-0.5f) + rands) * m_lights[0 + a_pLightOffset].size;  // PLEASE! use 'a_pLight[0].' for a while ... , not a_pLight-> and not *(a_pLight[0])
  if(m_lights[0 + a_pLightOffset].geomType == LIGHT_GEOM_DISC)
  {
    const float offsetX = rands.x * 2.0f - 1.0f;
    const float offsetY = rands.y * 2.0f - 1.0f;
    sampleOff = MapSamplesToDisc(vec2(offsetX,offsetY))*m_lights[0 + a_pLightOffset].size.x; 
  }
  const vec3 samplePos = mul3x3(m_lights[0 + a_pLightOffset].matrix, vec3(sampleOff.x,0.0f,sampleOff.y)) + m_lights[0 + a_pLightOffset].pos.xyz + epsilonOfPos(m_lights[0 + a_pLightOffset].pos.xyz) * m_lights[0 + a_pLightOffset].norm.xyz;
  LightSample res;
  res.pos    = samplePos;
  res.norm   = m_lights[0 + a_pLightOffset].norm.xyz;
  res.isOmni = false;
  res.hasIES = (m_lights[0 + a_pLightOffset].iesId != uint(-1));
  res.pdf    = 1.0f; // evaluated later 
  return res;
}

void glassEval_m_materials(uint a_materialsOffset, vec3 l, vec3 v, vec3 n, vec2 tc, vec3 color, inout BsdfEval res) {
  // because we don't want to sample this material with shadow rays
  res.val   = vec4(0.0f);
  res.pdf   = 0.0f;
}

void diffuseEval_m_materials(uint a_materialsOffset, vec4 a_reflSpec, vec3 l, vec3 v, vec3 n, vec2 tc, inout BsdfEval res) {
  const uint cflags = m_materials[0 + a_materialsOffset].cflags;
 
  float lambertVal       = lambertEvalBSDF(l, v, n);
  const float lambertPdf = lambertEvalPDF (l, v, n);

  if ((cflags & GLTF_COMPONENT_ORENNAYAR) != 0)
    lambertVal *= orennayarFunc(l, v, n, m_materials[0 + a_materialsOffset].data[DIFFUSE_ROUGHNESS]);

  res.val = lambertVal * a_reflSpec; 
  res.pdf = lambertPdf; 
}

void conductorRoughEval_m_materials(uint a_materialsOffset, const vec4 etaSpec, const vec4 kSpec, vec3 l, vec3 v, vec3 n, vec2 tc, vec3 alpha_tex, inout BsdfEval pRes) {
  const vec2 alpha = vec2(min(m_materials[0 + a_materialsOffset].data[CONDUCTOR_ROUGH_U], alpha_tex.x),min(m_materials[0 + a_materialsOffset].data[CONDUCTOR_ROUGH_V], alpha_tex.y));

  const vec4 rgb_reflectance = m_materials[0 + a_materialsOffset].colors[CONDUCTOR_COLOR];

  vec3 nx,  ny, nz = n;
  CoordinateSystemV2(nz, nx, ny);

  // v = (-1.0f) * v;
  const vec3 wo = vec3(dot(v, nx),dot(v, ny),dot(v, nz));
  const vec3 wi = vec3(dot(l, nx),dot(l, ny),dot(l, nz));

  if(wo.z * wi.z < 0.0f)
    return;

  vec3 wm = wo + wi;
  if (dot(wm, wm) == 0)
      return;

  wm = normalize(wm);
  vec4 val;
  for(uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i)
  {
    val[int(i)] = conductorRoughEvalInternal(wo, wi, wm, alpha, make_complex(etaSpec[int(i)],kSpec[int(i)]));
  }

  pRes.val = val * rgb_reflectance;

  wm        = FaceForward(wm, vec3(0.0f,0.0f,1.0f));
  pRes.pdf = trPDF(wo, wm, alpha) / (4.0f * abs(dot(wo, wm)));
}

void conductorRoughSampleAndEval_m_materials(uint a_materialsOffset, const vec4 etaSpec, const vec4 kSpec, vec4 rands, vec3 v, vec3 n, vec2 tc, vec3 alpha_tex, inout BsdfSample pRes) {
  if(v.z == 0)
    return;

  const vec4 rgb_reflectance = m_materials[0 + a_materialsOffset].colors[CONDUCTOR_COLOR];

  const vec2 alpha = vec2(min(m_materials[0 + a_materialsOffset].data[CONDUCTOR_ROUGH_U], alpha_tex.x),min(m_materials[0 + a_materialsOffset].data[CONDUCTOR_ROUGH_V], alpha_tex.y));

  vec3 nx,  ny, nz = n;
  CoordinateSystemV2(nz, nx, ny);
  const vec3 wo = vec3(dot(v, nx),dot(v, ny),dot(v, nz));
  if(wo.z == 0)
    return;

  if(wo.z == 0)
    return;

  vec3 wm = trSample(wo, vec2(rands.x,rands.y), alpha);
  vec3 wi = reflect((-1.0f) * wo, wm);

  if(wo.z * wi.z < 0) // not in the same hemisphere
  {
    return;
  }

  vec4 val;
  for(uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i)
  {
    val[int(i)] = conductorRoughEvalInternal(wo, wi, wm, alpha, make_complex(etaSpec[int(i)],kSpec[int(i)]));
  }

  pRes.val   = val * rgb_reflectance; 
  pRes.dir   = normalize(wi.x * nx + wi.y * ny + wi.z * nz);
  pRes.pdf   = trPDF(wo, wm, alpha) / (4.0f * abs(dot(wo, wm)));
  pRes.flags = RAY_FLAG_HAS_NON_SPEC;
}

void filmRoughEval_m_materials_m_precomp_thin_films(uint a_materialsOffset, const float extIOR, const complex filmIOR, const complex intIOR, const float thickness, const vec4 a_wavelengths, vec3 l, vec3 v, vec3 n, vec2 tc, vec3 alpha_tex, inout BsdfEval pRes, uint precomputed_dataOffset, const bool spectral_mode, const bool precomputed) {
  if (intIOR.im < 0.001f)
  {
    return;
  }

  uint32_t refl_offset;
  uint32_t refr_offset;

  bool reversed = false;
  if (dot(v, n) < 0.f && intIOR.im < 0.001f)
  {
    reversed = true;
    refl_offset = FILM_ANGLE_RES * 2;
    refr_offset = FILM_ANGLE_RES * 3;
  }
  else
  {
    refl_offset = 0;
    refr_offset = FILM_ANGLE_RES;
  }

  const vec2 alpha = vec2(min(m_materials[0 + a_materialsOffset].data[FILM_ROUGH_V], alpha_tex.x),min(m_materials[0 + a_materialsOffset].data[FILM_ROUGH_U], alpha_tex.y));

  vec3 s, t = n;
  CoordinateSystemV2(n, s, t);
  const vec3 wo = vec3(dot(l, s),dot(l, t),dot(l, n));
  const vec3 wi = vec3(dot(v, s),dot(v, t),dot(v, n));
  const vec3 wm = normalize(wo + wi);

  if (wi.z * wo.z < 0.f)
  {
    return;
  }

  float ior = intIOR.re / extIOR;
  if (reversed)
  {
    ior = 1.f / ior;
  }

  float cosThetaI = clamp(abs(dot(wo, wm)), 0.00001f, 1.0f);
  
  vec4 R = vec4(0.0f);
  if (spectral_mode)
  {
    if (precomputed)
    {
      float w = clamp((a_wavelengths[0] - LAMBDA_MIN) / (LAMBDA_MAX - LAMBDA_MIN), 0.f, 1.f);
      float theta = clamp(acos(cosThetaI) * 2.f / M_PI, 0.f, 1.f);
      //result.refl = lerp_gather_2d(reflectance, w, theta, FILM_LENGTH_RES, FILM_ANGLE_RES);
      w *= FILM_LENGTH_RES - 1;
      theta *= FILM_ANGLE_RES - 1;
      uint index1 = min(uint32_t(w), uint32_t(FILM_LENGTH_RES - 2));
      uint index2 = min(uint32_t(theta), uint32_t(FILM_ANGLE_RES - 2));

      float alpha = w - float(index1);
      float beta = theta - float(index2);

      float v0 = mix(m_precomp_thin_films[refl_offset * FILM_LENGTH_RES + index1 * FILM_ANGLE_RES + index2 + precomputed_dataOffset], m_precomp_thin_films[refl_offset * FILM_LENGTH_RES + (index1 + 1) * FILM_ANGLE_RES + index2 + precomputed_dataOffset], alpha);
      float v1 = mix(m_precomp_thin_films[refl_offset * FILM_LENGTH_RES + index1 * FILM_ANGLE_RES + index2 + 1 + precomputed_dataOffset], m_precomp_thin_films[refl_offset * FILM_LENGTH_RES + (index1 + 1) * FILM_ANGLE_RES + index2 + 1 + precomputed_dataOffset], alpha);
      R[0] = mix(v0, v1, beta);
    }
    else
    {
      if (!reversed)
      {
        R[0] = FrFilmRefl(cosThetaI, to_complex(extIOR), filmIOR, intIOR, thickness, a_wavelengths[0]);
      }
      else
      {
        R[0] = FrFilmRefl(cosThetaI, intIOR, filmIOR, to_complex(extIOR), thickness, a_wavelengths[0]); 
      }
    }
  }
  else
  {
    float theta = clamp(acos(cosThetaI) * 2.f / M_PI, 0.f, 1.f);
    theta *= FILM_ANGLE_RES - 1;
    if (floatBitsToUint((m_materials[0 + a_materialsOffset].data[FILM_THICKNESS_MAP])) == 1u)
    {
      float thickness_min = m_materials[0 + a_materialsOffset].data[FILM_THICKNESS_MIN];
      float thickness_max = m_materials[0 + a_materialsOffset].data[FILM_THICKNESS_MAX];
      float t = clamp((thickness - thickness_min) / (thickness_max - thickness_min), 0.f, 1.f);
      t *= FILM_THICKNESS_RES - 1;
      uint index1 = min(uint32_t(t), uint32_t(FILM_THICKNESS_RES - 2));
      uint index2 = min(uint32_t(theta), uint32_t(FILM_ANGLE_RES - 2));

      float alpha = t - float(index1);
      float beta = theta - float(index2);

      uint a = (refl_offset * FILM_THICKNESS_RES + index1 * FILM_ANGLE_RES + index2) * 3;
      uint b = (refl_offset * FILM_THICKNESS_RES + (index1 + 1) * FILM_ANGLE_RES + index2) * 3;
      uint c = (refl_offset * FILM_THICKNESS_RES + index1 * FILM_ANGLE_RES + index2 + 1) * 3;
      uint d = (refl_offset * FILM_THICKNESS_RES + (index1 + 1) * FILM_ANGLE_RES + index2 + 1) * 3;

      float v0 = mix(m_precomp_thin_films[a + precomputed_dataOffset], m_precomp_thin_films[b + precomputed_dataOffset], alpha);
      float v1 = mix(m_precomp_thin_films[c + precomputed_dataOffset], m_precomp_thin_films[d + precomputed_dataOffset], alpha);
      R[0] = mix(v0, v1, beta);

      v0 = mix(m_precomp_thin_films[a + 1 + precomputed_dataOffset], m_precomp_thin_films[b + 1 + precomputed_dataOffset], alpha);
      v1 = mix(m_precomp_thin_films[c + 1 + precomputed_dataOffset], m_precomp_thin_films[d + 1 + precomputed_dataOffset], alpha);
      R[1] = mix(v0, v1, beta);

      v0 = mix(m_precomp_thin_films[a + 2 + precomputed_dataOffset], m_precomp_thin_films[b + 2 + precomputed_dataOffset], alpha);
      v1 = mix(m_precomp_thin_films[c + 2 + precomputed_dataOffset], m_precomp_thin_films[d + 2 + precomputed_dataOffset], alpha);
      R[2] = mix(v0, v1, beta);
    }
    else
    {
      uint index = min(uint32_t(theta), uint32_t(FILM_ANGLE_RES - 2));

      float alpha = theta - float(index);

      R[0] = mix(m_precomp_thin_films[(refl_offset + index) * 3 + precomputed_dataOffset], m_precomp_thin_films[(refl_offset + index + 1) * 3 + precomputed_dataOffset], alpha);
      R[1] = mix(m_precomp_thin_films[(refl_offset + index) * 3 + 1 + precomputed_dataOffset], m_precomp_thin_films[(refl_offset + index + 1) * 3 + 1 + precomputed_dataOffset], alpha);
      R[2] = mix(m_precomp_thin_films[(refl_offset + index) * 3 + 2 + precomputed_dataOffset], m_precomp_thin_films[(refl_offset + index + 1) * 3 + 2 + precomputed_dataOffset], alpha);
    }
  }

  const float cos_theta_i = max(wi.z, EPSILON_32);
  const float cos_theta_o = max(wo.z, EPSILON_32);

  float D = eval_microfacet(wm, alpha, 1);
  float G = microfacet_G(wi, wo, wm, alpha);
  pRes.pdf = trPDF(wi, wm, alpha) / (4.0f * abs(dot(wi, wm)));
  pRes.val = trD(wm, alpha) * microfacet_G(wi, wo, wm, alpha) * R / (4.0f * cos_theta_i * cos_theta_o);
}

void diffuseSampleAndEval_m_materials(uint a_materialsOffset, vec4 a_reflSpec, vec4 rands, vec3 v, vec3 n, vec2 tc, inout BsdfSample pRes) {
  const uint   cflags     = m_materials[0 + a_materialsOffset].cflags;
  const vec3 lambertDir = lambertSample(vec2(rands.x,rands.y), v, n);
  const float  lambertPdf = lambertEvalPDF(lambertDir, v, n);
  const float  lambertVal = lambertEvalBSDF(lambertDir, v, n);

  pRes.dir   = lambertDir;
  pRes.val   = lambertVal * a_reflSpec;
  pRes.pdf   = lambertPdf;
  pRes.flags = RAY_FLAG_HAS_NON_SPEC;
        
  if ((cflags & GLTF_COMPONENT_ORENNAYAR) != 0)
    pRes.val *= orennayarFunc(lambertDir, (-1.0f) * v, n, m_materials[0 + a_materialsOffset].data[DIFFUSE_ROUGHNESS]);
            
}

void plasticEval_m_materials_m_precomp_coat_transmittance(uint a_materialsOffset, vec4 a_reflSpec, vec3 l, vec3 v, vec3 n, vec2 tc, inout BsdfEval pRes, uint transmittanceOffset) {
  const float alpha     = m_materials[0 + a_materialsOffset].data[PLASTIC_ROUGHNESS];
  const float eta       = m_materials[0 + a_materialsOffset].data[PLASTIC_IOR_RATIO];
  const float spec_weight = m_materials[0 + a_materialsOffset].data[PLASTIC_SPEC_SAMPLE_WEIGHT];
  const uint  nonlinear   = m_materials[0 + a_materialsOffset].nonlinear;
  const float internal_refl = m_materials[0 + a_materialsOffset].data[PLASTIC_PRECOMP_REFLECTANCE];

  const vec2 alpha2 = vec2(alpha,alpha);
  
  vec3 s = n;
  vec3 t = n;
  CoordinateSystemV2(n, s, t);
  
  const vec3 wo = vec3(dot(l, s),dot(l, t),dot(l, n));
  const vec3 wi = vec3(dot(v, s),dot(v, t),dot(v, n));
  if(wi.z * wo.z <= 0)
  {
    return;
  }
  const float cos_theta_i = max(wi.z, EPSILON_32);
  const float cos_theta_o = max(wo.z, EPSILON_32);

  // float t_i = lerp_gather(transmittance, cos_theta_i, MI_ROUGH_TRANSMITTANCE_RES);
  float t_i = 0.0f;
  {
    float x = cos_theta_i;
    x *= float(MI_ROUGH_TRANSMITTANCE_RES - 1);
    uint index = min(uint32_t(x), uint32_t(MI_ROUGH_TRANSMITTANCE_RES - 2));

    float v0 = m_precomp_coat_transmittance[index + transmittanceOffset];
    float v1 = m_precomp_coat_transmittance[index + 1 + transmittanceOffset];

    t_i = mix(v0, v1, x - float(index));
  }

  float prob_specular = (1.f - t_i) * spec_weight;
  float prob_diffuse  = t_i * (1.f - spec_weight);

  if(prob_diffuse != 0.0f && prob_specular != 0.0f)
  {
    prob_specular = prob_specular / (prob_specular + prob_diffuse);
    prob_diffuse  = 1.f - prob_specular;
  }
  else
  {
    prob_diffuse  = 1.0f;
    prob_specular = 0.0f;
  }

 
  vec3 H = normalize(wo + wi);
  float  D = eval_microfacet(H, alpha2, 1);
  float smith_g1_wi = smith_g1(wi, H, alpha2);

  float pdf = D * smith_g1_wi / (4.f * cos_theta_i);
  pdf *= prob_specular;
  pdf += prob_diffuse * INV_PI * cos_theta_o;


  const float F = FrDielectric(dot(wi, H), eta); 
  float G = smith_g1(wo, H, alpha2) * smith_g1_wi;
  float val = F * D * G / (4.f * cos_theta_i * cos_theta_o);

  // float t_o = lerp_gather(transmittance, cos_theta_o, MI_ROUGH_TRANSMITTANCE_RES); 
  float t_o = 0.0f;
  {
    float x = cos_theta_o;
    x *= float(MI_ROUGH_TRANSMITTANCE_RES - 1);
    uint index = min(uint32_t(x), uint32_t(MI_ROUGH_TRANSMITTANCE_RES - 2));

    float v0 = m_precomp_coat_transmittance[index + transmittanceOffset];
    float v1 = m_precomp_coat_transmittance[index + 1 + transmittanceOffset];

    t_o = mix(v0, v1, x - float(index));
  }

  vec4 diffuse = a_reflSpec / (1.f - (nonlinear > 0 ? (a_reflSpec * internal_refl) : vec4(internal_refl)));
  const float inv_eta_2 = 1.f / (eta * eta);

  pRes.val   = vec4(val) + diffuse * (INV_PI * inv_eta_2 * /*cos_theta_o **/ t_i * t_o );
  pRes.pdf   = pdf;
}

void gltfSampleAndEval_m_materials(uint a_materialsOffset, vec4 rands, vec3 v, vec3 n, vec2 tc, vec4 baseColor, vec4 fourParams, inout BsdfSample pRes) {
  // PLEASE! use 'a_materials[0].' for a while ... , not a_materials-> and not *(a_materials).
  const uint   cflags     = m_materials[0 + a_materialsOffset].cflags;
  const vec4 metalCol = m_materials[0 + a_materialsOffset].colors[GLTF_COLOR_METAL]*baseColor; 
  const vec4 coatCol = m_materials[0 + a_materialsOffset].colors[GLTF_COLOR_COAT];  
  const float  roughness  = clamp(1.0f - m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_GLOSINESS]*fourParams.x, 0.0f, 1.0f);   
  float        metalness  = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_ALPHA]*fourParams.y;
  const float  coatValue  = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_REFL_COAT]*fourParams.z;                 
  const float  fresnelIOR = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_IOR];
  
  if(cflags == GLTF_COMPONENT_METAL) // assume only GGX-based metal component set
    metalness = 1.0f;

  vec3 ggxDir;
  float  ggxPdf; 
  float  ggxVal;

  if(roughness == 0.0f) // perfect specular reflection in coating or metal layer
  {
    const vec3 pefReflDir = reflect((-1.0f) * v, n);
    const float cosThetaOut = dot(pefReflDir, n);
    ggxDir                  = pefReflDir;
    ggxVal                  = (cosThetaOut <= 1e-6f) ? 0.0f : (1.0f/max(cosThetaOut, 1e-6f));  // BSDF is multiplied (outside) by cosThetaOut. For mirrors this shouldn't be done, so we pre-divide here instead.
    ggxPdf                  = 1.0f;
  }
  else
  {
    ggxDir                  = ggxSample(vec2(rands.x,rands.y), v, n, roughness);
    ggxPdf                  = ggxEvalPDF (ggxDir, v, n, roughness); 
    ggxVal                  = ggxEvalBSDF(ggxDir, v, n, roughness);
  }

  const vec3 lambertDir = lambertSample(vec2(rands.x,rands.y), v, n);
  const float  lambertPdf   = lambertEvalPDF(lambertDir, v, n);
  const float  lambertVal   = lambertEvalBSDF(lambertDir, v, n);

  // (1) select between metal and dielectric via rands.z
  //
  float pdfSelect = 1.0f;
  if(rands.z < metalness) // select metall
  {
    pdfSelect         *= metalness;
    const float  VdotH = dot(v,normalize(v + ggxDir));
    pRes.dir          = ggxDir;
    pRes.val          = ggxVal * metalness * hydraFresnelCond(metalCol, VdotH, fresnelIOR, roughness); //TODO: disable fresnel here for mirrors
    pRes.pdf          = ggxPdf;
    pRes.flags        = (roughness == 0.0f) ? RAY_EVENT_S : RAY_FLAG_HAS_NON_SPEC;
  }
  else                // select dielectric
  {
    pdfSelect *= 1.0f - metalness;
    
    // (2) now select between specular and diffise via rands.w
    //
    const float f_i           = FrDielectricPBRT(abs(dot(v,n)), 1.0f, fresnelIOR); 
    const float prob_specular = 0.5f*coatValue;
    const float prob_diffuse  = 1.0f-prob_specular;
    
    if(rands.w < prob_specular) // specular
    {
      pdfSelect      *= prob_specular;
      pRes.dir       = ggxDir;
      pRes.val       = ggxVal*coatCol*(1.0f - metalness)*f_i*coatValue;
      pRes.pdf       = ggxPdf;
      pRes.flags     = (roughness == 0.0f) ? RAY_EVENT_S : RAY_FLAG_HAS_NON_SPEC;
    } 
    else
    {
      pdfSelect      *= prob_diffuse; // lambert
      pRes.dir       = lambertDir;
      pRes.val       = lambertVal * baseColor * (1.0f - metalness);
      pRes.pdf       = lambertPdf;
      pRes.flags     = RAY_FLAG_HAS_NON_SPEC;
            
      if(coatValue > 0.0f && fresnelIOR > 0.0f) // Plastic, account for retroreflection between surface and coating layer
      {
        const float m_fdr_int = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_MI_FDR_INT];
        const float f_o       = FrDielectricPBRT(abs(dot(lambertDir, n)), 1.0f, fresnelIOR);
        pRes.val            *= mix(1.0f, (1.0f - f_i) * (1.0f - f_o) / (fresnelIOR * fresnelIOR * (1.0f - m_fdr_int)), coatValue);
      }
    }
  }   
  pRes.pdf *= pdfSelect;
}

void conductorSmoothSampleAndEval_m_materials(uint a_materialsOffset, const vec4 etaSpec, const vec4 kSpec, vec4 rands, vec3 v, vec3 n, vec2 tc, inout BsdfSample pRes) {
  const vec4 rgb_reflectance = m_materials[0 + a_materialsOffset].colors[CONDUCTOR_COLOR];
  const vec3 pefReflDir = reflect((-1.0f)*v, n);
  const float cosThetaOut = dot(pefReflDir, n);
  vec3 dir = pefReflDir;
  float  pdf              = 1.0f;
  
  vec4 val;
  for(uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i)
  {
    val[int(i)] = FrComplexConductor(cosThetaOut, make_complex(etaSpec[int(i)],kSpec[int(i)]));
    val[int(i)] = (cosThetaOut <= 1e-6f) ? 0.0f : (val[int(i)] / max(cosThetaOut, 1e-6f));  
  }
  
  pRes.val = val * rgb_reflectance; 
  pRes.dir = dir;
  pRes.pdf = pdf;
  pRes.flags = RAY_EVENT_S;
}

bool isOutOfScene(uint a_flags) ;
vec4 EnvironmentColor(vec3 a_dir, inout float outPdf) ;
bool m_pAccelStruct_RayQuery_AnyHit(vec4 posAndNear, vec4 dirAndFar) ;
Map2DPiecewiseSample SampleMap2D(vec3 rands, uint a_tableOffset, int sizeX, int sizeY) ;
bool m_pAccelStruct_RayQuery_AnyHitMotion(vec4 posAndNear, vec4 dirAndFar, float time) ;
BsdfEval MaterialEval(uint a_materialId, vec4 wavelengths, vec3 l, vec3 v, vec3 n, vec3 tan, vec2 tc) ;
uint RemapMaterialId(uint a_mId, int a_instId) ;
void m_pAccelStruct_BVH2TraverseF32(const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, bool stopOnFirstHit, inout CRT_Hit pHit) ;
CRT_Hit m_pAccelStruct_RayQuery_NearestHit(vec4 posAndNear, vec4 dirAndFar) ;
uint packMatId(uint a_flags, uint a_matId) ;
vec4 m_pAccelStruct_rbezier_grid_point(float u, float v, NURBSHeader h) ;
float m_pAccelStruct_eval_distance_sdf_sbs(uint sbs_id, vec3 pos) ;
float m_pAccelStruct_COctreeV3_LoadDistanceValues(uint leafType, uint brickOffset, vec3 voxelPos, uint v_size, float sz_inv, in COctreeV3Header header, uint transform_code, inout float values[8]) ;
float GetRandomNumbersMatB(uint tid, inout RandomGen a_gen, int a_bounce, int a_layer) ;
void m_pAccelStruct_OctreeIntersectV3(uint type, const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint bvhNodeId, uint a_count, inout CRT_Hit pHit) ;
vec4 m_pAccelStruct_rbezier_grid_vder(float u, float v, in vec4 Sw, NURBSHeader h) ;
float m_pAccelStruct_tricubicInterpolation(const float grid[64], const float dp[3]) ;
float m_pAccelStruct_eval_dist_trilinear(const float values[8], vec3 dp) ;
float m_pAccelStruct_eval_distance_sdf(uint type, uint sdf_id, vec3 pos) ;
void RecordBlendRndNeeded(uint bounceId, uint layer, float rand) ;
void m_pAccelStruct_LocalSurfaceIntersection(uint type, const vec3 ray_dir, uint instId, uint geomId, inout float values[8], uint nodeId, uint primId, float d, float qNear, float qFar, vec2 fNearFar, vec3 start_q, inout CRT_Hit pHit) ;
void m_pAccelStruct_OctreeIntersect(uint type, const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint a_start, uint a_count, inout CRT_Hit pHit) ;
uint extractMatId(uint a_flags) ;
void m_pAccelStruct_OctreeNodeIntersect(uint type, const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint a_start, uint a_count, inout CRT_Hit pHit) ;
void m_pAccelStruct_OctreeBrickIntersect(uint type, const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint bvhNodeId, uint a_count, inout CRT_Hit pHit) ;
vec2 m_pAccelStruct_encode_normal(vec3 v) ;
void RecordShadowHitIfNeeded(uint bounceId, bool inShadow) ;
vec2 m_pAccelStruct_box_intersects(in vec3 min_pos, in vec3 max_pos, in vec3 origin, in vec3 dir) ;
bool isDeadRay(uint a_flags) ;
float m_pAccelStruct_knot(uint i, int knots_offset) ;
void m_pAccelStruct_TricubicLocalSurfaceIntersection(uint type, const vec3 ray_dir, uint instId, uint geomId, inout float values[64], uint nodeId, uint primId, float d, float qNear, float qFar, vec2 fNearFar, vec3 start_q, inout CRT_Hit pHit) ;
vec4 GetRandomNumbersLgts(uint tid, inout RandomGen a_gen, int a_bounce) ;
vec4 m_pAccelStruct_control_point(uint i, int offset) ;
MatIdWeightPair BlendEval(MatIdWeight a_mat, vec4 wavelengths, vec3 l, vec3 v, vec3 n, vec2 tc) ;
CRT_Hit m_pAccelStruct_RayQuery_NearestHitMotion(vec4 posAndNear, vec4 dirAndFar, float time) ;
void m_pAccelStruct_IntersectRibbon(in vec3 ray_pos, in vec3 ray_dir, float tNear, uint instId, uint geomId, inout CRT_Hit pHit) ;
float m_pAccelStruct_load_distance_values(uint nodeId, vec3 voxelPos, uint v_size, float sz_inv, in SdfSBSHeader header, inout float values[8]) ;
void m_pAccelStruct_COctreeV3_BrickIntersect(uint type, const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, in COctreeV3Header header, uint brickOffset, vec3 p, float sz, uint transform_code_leaf_type, inout CRT_Hit pHit) ;
uint m_pAccelStruct_eval_distance_traverse_bvh(uint geomId, vec3 pos) ;
vec4 m_pAccelStruct_rbezier_curve_der(float u, int p, int offset) ;
BsdfSample MaterialSampleAndEval(uint a_materialId, uint tid, uint bounce, vec4 wavelengths, inout RandomGen a_gen, vec3 v, vec3 n, vec3 tan, vec2 tc, inout MisData a_misPrev, const uint a_currRayFlags) ;
vec4 m_pAccelStruct_rbezier_curve_point(float u, int p, int offset) ;
void m_pAccelStruct_IntersectGraphicPrims(in vec3 ray_pos, in vec3 ray_dir, float tNear, uint instId, uint geomId, uint a_start, uint a_count, inout CRT_Hit pHit) ;
float m_pAccelStruct_COctreeV3_LoadDistanceValuesLeafBitPack(uint brickOffset, vec3 voxelPos, uint v_size, float sz_inv, in COctreeV3Header header, uint transform_code, inout float values[8]) ;
void m_pAccelStruct_IntersectNURBS(in vec3 ray_pos, in vec3 ray_dir, float tNear, uint approx_offset, uint instId, uint geomId, inout CRT_Hit pHit) ;
vec4 m_pAccelStruct_rbezier_surface_point(float u, float v, int points_offset, NURBSHeader h) ;
bool m_pAccelStruct_need_normal() ;
void RecordRayHitIfNeeded(uint bounceId, CRT_Hit hit) ;
void m_pAccelStruct_IntersectAllTrianglesInLeaf(const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint a_start, uint a_count, inout CRT_Hit pHit) ;
vec4 SampleFilmsSpectrum(uint matId, vec4 a_wavelengths, uint paramId, uint paramSpecId, uint layer) ;
float LightEvalPDF(int a_lightId, vec3 illuminationPoint, vec3 ray_dir, const vec3 lpos, const vec3 lnorm, float a_envPdf) ;
vec4 m_pAccelStruct_rbezier_surface_uder(float u, float v, in vec4 Sw, int points_offset, NURBSHeader h) ;
int m_pAccelStruct_find_span(float t, int knots_offset, int knots_count, NURBSHeader h) ;
vec4 LightIntensity(uint a_lightId, vec4 a_wavelengths, vec3 a_rayPos, vec3 a_rayDir) ;
float m_pAccelStruct_COctreeV3_LoadDistanceValuesLeafSlices(uint brickOffset, vec3 voxelPos, uint v_size, float sz_inv, in COctreeV3Header header, uint transform_code, inout float values[8]) ;
vec4 m_pAccelStruct_rbezier_surface_vder(float u, float v, in vec4 Sw, int points_offset, NURBSHeader h) ;
void m_pAccelStruct_RayNodeIntersection(uint type, const vec3 ray_pos, const vec3 ray_dir, float tNear, uint geomId, uint bvhNodeId, inout float values[8], inout uint primId, inout uint nodeId, inout float d, inout float qNear, inout float qFar, inout vec2 fNearFar, inout vec3 start_q) ;
float m_pAccelStruct_COctreeV3_LoadDistanceValuesLeafGrid(uint brickOffset, vec3 voxelPos, uint v_size, float sz_inv, in COctreeV3Header header, uint transform_code, inout float values[8]) ;
void m_pAccelStruct_IntersectCatmulClark(in vec3 ray_pos, in vec3 ray_dir, float tNear, uint instId, uint geomId, inout CRT_Hit pHit) ;
void RecordLightRndIfNeeded(uint bounceId, vec4 rands) ;
vec3 BumpMapping(uint normalMapId, uint currMatId, vec3 n, vec3 tan, vec2 tc) ;
uint RandomGenId(uint tid) ;
void RecordMatRndNeeded(uint bounceId, vec4 rands) ;
float LightPdfSelectRev(int a_lightId) ;
LightSample LightSampleRev(int a_lightId, vec3 rands, vec3 illiminationPoint) ;
void m_pAccelStruct_OctreeAdaptBrickIntersect(uint type, const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint bvhNodeId, uint a_count, inout CRT_Hit pHit) ;
void m_pAccelStruct_IntersectAllSdfsInLeaf(const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint a_start, uint a_count, inout CRT_Hit pHit) ;
bool hasNonSpecular(uint a_flags) ;
uint BlendSampleAndEval(uint a_materialId, uint tid, uint bounce, uint layer, vec4 wavelengths, inout RandomGen a_gen, vec3 v, vec3 n, vec2 tc, inout MisData a_misPrev, inout BsdfSample a_pRes) ;
float m_pAccelStruct_load_tricubic_distance_values(uint nodeId, vec3 voxelPos, uint v_size, float sz_inv, in SdfSBSHeader header, inout float values[64]) ;
vec4 SampleMatParamSpectrum(uint matId, vec4 a_wavelengths, uint paramId, uint paramSpecId) ;
vec4 SampleMatColorSpectrumTexture(uint matId, vec4 a_wavelengths, uint paramId, uint paramSpecId, vec2 texCoords) ;
SdfHit m_pAccelStruct_sdf_sphere_tracing(uint type, uint sdf_id, in vec3 min_pos, in vec3 max_pos, float tNear, in vec3 pos, in vec3 dir, bool need_norm) ;
vec4 GetRandomNumbersMats(uint tid, inout RandomGen a_gen, int a_bounce) ;
NURBS_HitInfo m_pAccelStruct_ray_nurbs_newton_intersection(in vec3 pos, in vec3 ray, vec2 uv, NURBSHeader h) ;
vec4 m_pAccelStruct_rbezier_grid_uder(float u, float v, in vec4 Sw, NURBSHeader h) ;

// Virtual Functions of AbstractObject:
const uint TAG_NONE = 0;
const uint TAG_TRIANGLE = 1;
const uint TAG_SDF_GRID = 2;
const uint TAG_SDF_NODE = 3;
const uint TAG_SDF_BRICK = 4;
const uint TAG_RF = 5;
const uint TAG_GS = 6;
const uint TAG_SDF_ADAPT_BRICK = 7;
const uint TAG_NURBS = 8;
const uint TAG_GRAPHICS_PRIM = 9;
const uint TAG_COCTREE_SIMPLE = 10;
const uint TAG_COCTREE_BRICKED = 11;
const uint TAG_CATMUL_CLARK = 12;
const uint TAG_RIBBON = 13;
const uint TAG_OPENVDB_GRID = 14;



uint EmptyGeomData_Intersect_m_pAccelStruct_m_abstractObjectPtrs(uint selfId, vec4 rayPosAndNear, vec4 rayDirAndFar, CRT_LeafInfo info, inout CRT_Hit pHit  ) {
    return TAG_NONE;
  }
uint GeomDataTriangle_Intersect_m_pAccelStruct_m_abstractObjectPtrs(uint selfId, vec4 rayPosAndNear, vec4 rayDirAndFar, CRT_LeafInfo info, inout CRT_Hit pHit  ) {
    vec3 ray_pos = rayPosAndNear.xyz;
    vec3 ray_dir = rayDirAndFar.xyz;
    float tNear    = rayPosAndNear.w;
    float tPrev     = pHit.t;
    uint geometryId = all_references.GeomDataTriangle_buffer.m_pAccelStruct_m_abstractObjectPtrs[selfId].geomId;
    uint globalAABBId = m_pAccelStruct_startEnd[geometryId].x + info.aabbId;
    uint start_count_packed = m_pAccelStruct_m_primIdCount[globalAABBId];
    uint a_start = EXTRACT_START(start_count_packed);
    uint a_count = EXTRACT_COUNT(start_count_packed);

    m_pAccelStruct_IntersectAllTrianglesInLeaf(ray_pos,ray_dir,tNear,info.instId,geometryId,a_start,a_count,pHit);
    return pHit.t >= tPrev  ? TAG_NONE : TAG_TRIANGLE;
  }

uint GeomDataSdfGrid_Intersect_m_pAccelStruct_m_abstractObjectPtrs(uint selfId, vec4 rayPosAndNear, vec4 rayDirAndFar, CRT_LeafInfo info, inout CRT_Hit pHit  ) {
    vec3 ray_pos = rayPosAndNear.xyz;
    vec3 ray_dir = rayDirAndFar.xyz;
    float tNear    = rayPosAndNear.w;
    float tPrev     = pHit.t;
    uint geometryId = all_references.GeomDataSdfGrid_buffer.m_pAccelStruct_m_abstractObjectPtrs[selfId].geomId;
    uint globalAABBId = m_pAccelStruct_startEnd[geometryId].x + info.aabbId;
    uint start_count_packed = m_pAccelStruct_m_primIdCount[globalAABBId];
    uint a_start = EXTRACT_START(start_count_packed);
    uint a_count = EXTRACT_COUNT(start_count_packed);

    m_pAccelStruct_IntersectAllSdfsInLeaf(ray_pos,ray_dir,tNear,info.instId,geometryId,a_start,a_count,pHit);
    return pHit.t >= tPrev  ? TAG_NONE : TAG_SDF_GRID;
  }

uint GeomDataSdfNode_Intersect_m_pAccelStruct_m_abstractObjectPtrs(uint selfId, vec4 rayPosAndNear, vec4 rayDirAndFar, CRT_LeafInfo info, inout CRT_Hit pHit  ) {
    vec3 ray_pos = rayPosAndNear.xyz;
    vec3 ray_dir = rayDirAndFar.xyz;
    float tNear    = rayPosAndNear.w;
    float tPrev     = pHit.t;
    uint geometryId = all_references.GeomDataSdfNode_buffer.m_pAccelStruct_m_abstractObjectPtrs[selfId].geomId;
    uint globalAABBId = m_pAccelStruct_startEnd[geometryId].x + info.aabbId;
    uint start_count_packed = m_pAccelStruct_m_primIdCount[globalAABBId];
    uint a_start = EXTRACT_START(start_count_packed);
    uint a_count = EXTRACT_COUNT(start_count_packed);
    uint type = m_pAccelStruct_m_geomData[geometryId].type;

    m_pAccelStruct_OctreeNodeIntersect(type,ray_pos,ray_dir,tNear,info.instId,geometryId,a_start,a_count,pHit);
    return pHit.t >= tPrev  ? TAG_NONE : TAG_SDF_NODE;
  }

uint GeomDataSdfBrick_Intersect_m_pAccelStruct_m_abstractObjectPtrs(uint selfId, vec4 rayPosAndNear, vec4 rayDirAndFar, CRT_LeafInfo info, inout CRT_Hit pHit  ) {
    vec3 ray_pos = rayPosAndNear.xyz;
    vec3 ray_dir = rayDirAndFar.xyz;
    float tNear    = rayPosAndNear.w;
    float tPrev     = pHit.t;
    uint geometryId = all_references.GeomDataSdfBrick_buffer.m_pAccelStruct_m_abstractObjectPtrs[selfId].geomId;
    uint globalAABBId = m_pAccelStruct_startEnd[geometryId].x + info.aabbId;
    uint start_count_packed = m_pAccelStruct_m_primIdCount[globalAABBId];
    uint a_start = EXTRACT_START(start_count_packed);
    uint a_count = EXTRACT_COUNT(start_count_packed);
    uint type = m_pAccelStruct_m_geomData[geometryId].type;

    m_pAccelStruct_OctreeBrickIntersect(type,ray_pos,ray_dir,tNear,info.instId,geometryId,a_start,a_count,pHit);
    return pHit.t >= tPrev  ? TAG_NONE : TAG_SDF_BRICK;
  }

uint GeomDataRF_Intersect_m_pAccelStruct_m_abstractObjectPtrs(uint selfId, vec4 rayPosAndNear, vec4 rayDirAndFar, CRT_LeafInfo info, inout CRT_Hit pHit  ) {
    float tPrev     = pHit.t;
#ifndef DISABLE_RF_GRID
    float3 ray_pos = to_float3(rayPosAndNear);
    float3 ray_dir = to_float3(rayDirAndFar);
    float tNear    = rayPosAndNear.w;
    uint32_t geometryId = geomId;
    uint32_t globalAABBId = bvhrt->startEnd[geometryId].x + info.aabbId;
    uint32_t start_count_packed = bvhrt->m_primIdCount[globalAABBId];
    uint32_t a_start = EXTRACT_START(start_count_packed);
    uint32_t a_count = EXTRACT_COUNT(start_count_packed);

    bvhrt->IntersectRFInLeaf(ray_pos, ray_dir, tNear, info.instId, geometryId, a_start, a_count, pHit);
#endif
    return pHit.t >= tPrev  ? TAG_NONE : TAG_RF;
  }

uint GeomDataGS_Intersect_m_pAccelStruct_m_abstractObjectPtrs(uint selfId, vec4 rayPosAndNear, vec4 rayDirAndFar, CRT_LeafInfo info, inout CRT_Hit pHit  ) {
    float tPrev     = pHit.t;
#ifndef DISABLE_GS_PRIMITIVE
    float3 ray_pos = to_float3(rayPosAndNear);
    float3 ray_dir = to_float3(rayDirAndFar);
    float tNear    = rayPosAndNear.w;
    uint32_t geometryId = geomId;
    uint32_t globalAABBId = bvhrt->startEnd[geometryId].x + info.aabbId;
    uint32_t start_count_packed = bvhrt->m_primIdCount[globalAABBId];
    uint32_t a_start = EXTRACT_START(start_count_packed);
    uint32_t a_count = EXTRACT_COUNT(start_count_packed);

    bvhrt->IntersectGSInLeaf(ray_pos, ray_dir, tNear, info.instId, geometryId, a_start, a_count, pHit);
#endif
    return pHit.t >= tPrev  ? TAG_NONE : TAG_GS;
  }

uint GeomDataSdfAdaptBrick_Intersect_m_pAccelStruct_m_abstractObjectPtrs(uint selfId, vec4 rayPosAndNear, vec4 rayDirAndFar, CRT_LeafInfo info, inout CRT_Hit pHit  ) {
    vec3 ray_pos = rayPosAndNear.xyz;
    vec3 ray_dir = rayDirAndFar.xyz;
    float tNear    = rayPosAndNear.w;
    float tPrev     = pHit.t;
    uint geometryId = all_references.GeomDataSdfAdaptBrick_buffer.m_pAccelStruct_m_abstractObjectPtrs[selfId].geomId;
    uint globalAABBId = m_pAccelStruct_startEnd[geometryId].x + info.aabbId;
    uint start_count_packed = m_pAccelStruct_m_primIdCount[globalAABBId];
    uint a_start = EXTRACT_START(start_count_packed);
    uint a_count = EXTRACT_COUNT(start_count_packed);
    uint type = m_pAccelStruct_m_geomData[geometryId].type;

    m_pAccelStruct_OctreeAdaptBrickIntersect(type,ray_pos,ray_dir,tNear,info.instId,geometryId,a_start,a_count,pHit);
    return pHit.t >= tPrev  ? TAG_NONE : TAG_SDF_ADAPT_BRICK;
  }

uint GeomDataNURBS_Intersect_m_pAccelStruct_m_abstractObjectPtrs(uint selfId, vec4 rayPosAndNear, vec4 rayDirAndFar, CRT_LeafInfo info, inout CRT_Hit pHit  ) {
    vec3 ray_pos = rayPosAndNear.xyz;
    vec3 ray_dir = rayDirAndFar.xyz;
    float tNear    = rayPosAndNear.w;
    float tPrev     = pHit.t;
    uint geometryId = all_references.GeomDataNURBS_buffer.m_pAccelStruct_m_abstractObjectPtrs[selfId].geomId;
    uint globalAABBId = m_pAccelStruct_startEnd[geometryId].x + info.aabbId;
    uint start_count_packed = m_pAccelStruct_m_primIdCount[globalAABBId];
    uint offset = EXTRACT_START(start_count_packed) * 2;

    m_pAccelStruct_IntersectNURBS(ray_pos,ray_dir,tNear,offset,info.instId,geometryId,pHit);
    return pHit.t >= tPrev  ? TAG_NONE : TAG_GS;
  }

uint GeomDataGraphicsPrim_Intersect_m_pAccelStruct_m_abstractObjectPtrs(uint selfId, vec4 rayPosAndNear, vec4 rayDirAndFar, CRT_LeafInfo info, inout CRT_Hit pHit  ) {
    vec3 ray_pos = rayPosAndNear.xyz;
    vec3 ray_dir = rayDirAndFar.xyz;
    float tNear    = rayPosAndNear.w;
    float tPrev     = pHit.t;
    uint geometryId = all_references.GeomDataGraphicsPrim_buffer.m_pAccelStruct_m_abstractObjectPtrs[selfId].geomId;
    uint globalAABBId = m_pAccelStruct_startEnd[geometryId].x + info.aabbId;
    uint start_count_packed = m_pAccelStruct_m_primIdCount[globalAABBId];
    uint a_start = EXTRACT_START(start_count_packed);
    uint a_count = EXTRACT_COUNT(start_count_packed);

    m_pAccelStruct_IntersectGraphicPrims(ray_pos,ray_dir,tNear,info.instId,geometryId,a_start,a_count,pHit);
    return pHit.t >= tPrev  ? TAG_NONE : TAG_GRAPHICS_PRIM;
  }

uint GeomDataCOctreeSimple_Intersect_m_pAccelStruct_m_abstractObjectPtrs(uint selfId, vec4 rayPosAndNear, vec4 rayDirAndFar, CRT_LeafInfo info, inout CRT_Hit pHit  ) {
    vec3 ray_pos = rayPosAndNear.xyz;
    vec3 ray_dir = rayDirAndFar.xyz;
    float tNear    = rayPosAndNear.w;
    float tPrev     = pHit.t;
    uint geometryId = all_references.GeomDataCOctreeSimple_buffer.m_pAccelStruct_m_abstractObjectPtrs[selfId].geomId;
    uint globalAABBId = m_pAccelStruct_startEnd[geometryId].x + info.aabbId;
    uint start_count_packed = m_pAccelStruct_m_primIdCount[globalAABBId];
    uint a_start = EXTRACT_START(start_count_packed);
    uint a_count = EXTRACT_COUNT(start_count_packed);
    uint type = m_pAccelStruct_m_geomData[geometryId].type;

    m_pAccelStruct_OctreeIntersect(type,ray_pos,ray_dir,tNear,info.instId,geometryId,a_start,a_count,pHit);
    return pHit.t >= tPrev  ? TAG_NONE : TAG_COCTREE_SIMPLE;
  }

uint GeomDataCOctreeBricked_Intersect_m_pAccelStruct_m_abstractObjectPtrs(uint selfId, vec4 rayPosAndNear, vec4 rayDirAndFar, CRT_LeafInfo info, inout CRT_Hit pHit  ) {
    vec3 ray_pos = rayPosAndNear.xyz;
    vec3 ray_dir = rayDirAndFar.xyz;
    float tNear    = rayPosAndNear.w;
    float tPrev     = pHit.t;
    uint geometryId = all_references.GeomDataCOctreeBricked_buffer.m_pAccelStruct_m_abstractObjectPtrs[selfId].geomId;
    uint globalAABBId = m_pAccelStruct_startEnd[geometryId].x + info.aabbId;
    uint start_count_packed = m_pAccelStruct_m_primIdCount[globalAABBId];
    uint a_start = EXTRACT_START(start_count_packed);
    uint a_count = EXTRACT_COUNT(start_count_packed);
    uint type = m_pAccelStruct_m_geomData[geometryId].type;

    m_pAccelStruct_OctreeIntersectV3(type,ray_pos,ray_dir,tNear,info.instId,geometryId,a_start,a_count,pHit);
    return pHit.t >= tPrev  ? TAG_NONE : TAG_COCTREE_BRICKED;
  }

uint GeomDataCatmulClark_Intersect_m_pAccelStruct_m_abstractObjectPtrs(uint selfId, vec4 rayPosAndNear, vec4 rayDirAndFar, CRT_LeafInfo info, inout CRT_Hit pHit  ) {
    vec3 ray_pos = rayPosAndNear.xyz;
    vec3 ray_dir = rayDirAndFar.xyz;
    float tNear    = rayPosAndNear.w;
    float tPrev     = pHit.t;
    uint geometryId = all_references.GeomDataCatmulClark_buffer.m_pAccelStruct_m_abstractObjectPtrs[selfId].geomId;
    uint globalAABBId = m_pAccelStruct_startEnd[geometryId].x + info.aabbId;

    /* 
    * OPTIONAL
    * If you write some data for bvh leave, you need to get offset of this data from m_primIdCount
    * So, when you add geometry (AddGeom_CatmulClark), you have to write offset to m_primIdCount
    * 
    * You can access this offset form IntersectCatmulClark by passing it as parameter 
    * To do this change IntersectCatmulClark signature
    * 
    * You can use this offset in any array you've defined as member in BVHRT
    * 
    * Example of getting offset:
    *   uint32_t start_count_packed = bvhrt->m_primIdCount[globalAABBId];
    *   uint32_t offset = EXTRACT_START(start_count_packed);
    */

    m_pAccelStruct_IntersectCatmulClark(ray_pos,ray_dir,tNear,info.instId,geometryId,pHit);
    return pHit.t >= tPrev  ? TAG_NONE : TAG_GS;
  }

uint GeomDataRibbon_Intersect_m_pAccelStruct_m_abstractObjectPtrs(uint selfId, vec4 rayPosAndNear, vec4 rayDirAndFar, CRT_LeafInfo info, inout CRT_Hit pHit  ) {
    vec3 ray_pos = rayPosAndNear.xyz;
    vec3 ray_dir = rayDirAndFar.xyz;
    float tNear    = rayPosAndNear.w;
    float tPrev     = pHit.t;
    uint geometryId = all_references.GeomDataRibbon_buffer.m_pAccelStruct_m_abstractObjectPtrs[selfId].geomId;
    uint globalAABBId = m_pAccelStruct_startEnd[geometryId].x + info.aabbId;

    /* 
    * OPTIONAL
    * If you write some data for bvh leave, you need to get offset of this data from m_primIdCount
    * So, when you add geometry (AddGeom_CatmulClark), you have to write offset to m_primIdCount
    * 
    * You can access this offset form IntersectRibbon by passing it as parameter 
    * To do this change IntersectRibbon signature
    * 
    * You can use this offset in any array you've defined as member in BVHRT
    * 
    * Example of getting offset:
    *   uint32_t start_count_packed = bvhrt->m_primIdCount[globalAABBId];
    *   uint32_t offset = EXTRACT_START(start_count_packed);
    */

    m_pAccelStruct_IntersectRibbon(ray_pos,ray_dir,tNear,info.instId,geometryId,pHit);
    return pHit.t >= tPrev  ? TAG_NONE : TAG_GS;
  }

uint AbstractObject_Intersect_m_pAccelStruct_m_abstractObjectPtrs(uint selfId, vec4 rayPosAndNear, vec4 rayDirAndFar, CRT_LeafInfo info, inout CRT_Hit pHit  )  
{
  const uvec2 tableVal = m_pAccelStruct_m_abstractObjectPtrs[selfId];
  const uint tag = tableVal.x;
  selfId         = tableVal.y;
  switch(tag) 
  {
    case TAG_TRIANGLE: return GeomDataTriangle_Intersect_m_pAccelStruct_m_abstractObjectPtrs(selfId,rayPosAndNear,rayDirAndFar,info,pHit);
    case TAG_SDF_GRID: return GeomDataSdfGrid_Intersect_m_pAccelStruct_m_abstractObjectPtrs(selfId,rayPosAndNear,rayDirAndFar,info,pHit);
    case TAG_SDF_NODE: return GeomDataSdfNode_Intersect_m_pAccelStruct_m_abstractObjectPtrs(selfId,rayPosAndNear,rayDirAndFar,info,pHit);
    case TAG_SDF_BRICK: return GeomDataSdfBrick_Intersect_m_pAccelStruct_m_abstractObjectPtrs(selfId,rayPosAndNear,rayDirAndFar,info,pHit);
    case TAG_RF: return GeomDataRF_Intersect_m_pAccelStruct_m_abstractObjectPtrs(selfId,rayPosAndNear,rayDirAndFar,info,pHit);
    case TAG_GS: return GeomDataGS_Intersect_m_pAccelStruct_m_abstractObjectPtrs(selfId,rayPosAndNear,rayDirAndFar,info,pHit);
    case TAG_SDF_ADAPT_BRICK: return GeomDataSdfAdaptBrick_Intersect_m_pAccelStruct_m_abstractObjectPtrs(selfId,rayPosAndNear,rayDirAndFar,info,pHit);
    case TAG_NURBS: return GeomDataNURBS_Intersect_m_pAccelStruct_m_abstractObjectPtrs(selfId,rayPosAndNear,rayDirAndFar,info,pHit);
    case TAG_GRAPHICS_PRIM: return GeomDataGraphicsPrim_Intersect_m_pAccelStruct_m_abstractObjectPtrs(selfId,rayPosAndNear,rayDirAndFar,info,pHit);
    case TAG_COCTREE_SIMPLE: return GeomDataCOctreeSimple_Intersect_m_pAccelStruct_m_abstractObjectPtrs(selfId,rayPosAndNear,rayDirAndFar,info,pHit);
    case TAG_COCTREE_BRICKED: return GeomDataCOctreeBricked_Intersect_m_pAccelStruct_m_abstractObjectPtrs(selfId,rayPosAndNear,rayDirAndFar,info,pHit);
    case TAG_CATMUL_CLARK: return GeomDataCatmulClark_Intersect_m_pAccelStruct_m_abstractObjectPtrs(selfId,rayPosAndNear,rayDirAndFar,info,pHit);
    case TAG_RIBBON: return GeomDataRibbon_Intersect_m_pAccelStruct_m_abstractObjectPtrs(selfId,rayPosAndNear,rayDirAndFar,info,pHit);
    default: return EmptyGeomData_Intersect_m_pAccelStruct_m_abstractObjectPtrs(selfId,rayPosAndNear,rayDirAndFar,info,pHit);
  };
}

bool isOutOfScene(uint a_flags) { return (a_flags & RAY_FLAG_OUT_OF_SCENE)   != 0; }

vec4 EnvironmentColor(vec3 a_dir, inout float outPdf) {
  vec4 color = ubo.m_envColor;
  
  // apply tex color
  //
  const uint envTexId = ubo.m_envTexId;
  if(KSPEC_LIGHT_ENV != 0 && envTexId != uint(-1))
  {
    float sinTheta  = 1.0f;
    const vec2 tc = sphereMapTo2DTexCoord(a_dir, sinTheta);
    const vec2 texCoordT = mulRows2x4(ubo.m_envSamRow0, ubo.m_envSamRow1, tc);
    
    if (sinTheta != 0.f && ubo.m_envEnableSam != 0 && ubo.m_intergatorType == INTEGRATOR_MIS_PT && ubo.m_envLightId != uint(-1))
    {
      const uint offset = m_lights[ubo.m_envLightId].pdfTableOffset;
      const uint sizeX = m_lights[ubo.m_envLightId].pdfTableSizeX;
      const uint sizeY = m_lights[ubo.m_envLightId].pdfTableSizeY;

      // apply inverse texcoord transform to get phi and theta and than get correct pdf from table 
      //
      const float mapPdf = evalMap2DPdf_m_pdfLightData(texCoordT, offset, int(sizeX), int(sizeY));
      outPdf = (mapPdf * 1.0f) / (2.f * M_PI * M_PI * max(abs(sinTheta), 1e-20f));  
    }

    const vec4 texColor = texture(m_textures[envTexId], texCoordT); 
    color *= texColor; 
  }

  return color;
}

bool m_pAccelStruct_RayQuery_AnyHit(vec4 posAndNear, vec4 dirAndFar) {
  dirAndFar.w *= -1.0f;
  CRT_Hit hit = m_pAccelStruct_RayQuery_NearestHit(posAndNear, dirAndFar);
  return (hit.geomId != uint32_t(-1));
}

Map2DPiecewiseSample SampleMap2D(vec3 rands, uint a_tableOffset, int sizeX, int sizeY) {
  const float fw = float(sizeX);
  const float fh = float(sizeY);
  const float fN = fw*fh;

  float pdf = 1.0f;
  int pixelOffset = SelectIndexPropToOpt_m_pdfLightData(rands.z, a_tableOffset, sizeX*sizeY+1, pdf);

  if (pixelOffset >= sizeX*sizeY)
    pixelOffset = sizeX*sizeY - 1;

  const int yPos = pixelOffset / sizeX;
  const int xPos = pixelOffset - yPos*sizeX;

  const float texX = (1.0f / fw)*((float((xPos)) + 0.5f) + (rands.x*2.0f - 1.0f)*0.5f);
  const float texY = (1.0f / fh)*((float((yPos)) + 0.5f) + (rands.y*2.0f - 1.0f)*0.5f);

  Map2DPiecewiseSample result;
  result.mapPdf   = pdf*fN; 
  result.texCoord = vec2(texX, texY);
  return result;
}

bool m_pAccelStruct_RayQuery_AnyHitMotion(vec4 posAndNear, vec4 dirAndFar, float time) { return m_pAccelStruct_RayQuery_AnyHit(posAndNear, dirAndFar); }

BsdfEval MaterialEval(uint a_materialId, vec4 wavelengths, vec3 l, vec3 v, vec3 n, vec3 tan, vec2 tc) {
  BsdfEval res;
  {
    res.val = vec4(0,0,0,0);
    res.pdf   = 0.0f;
  }

  MatIdWeight currMat = make_id_weight(a_materialId, 1.0f);
  MatIdWeight material_stack[KSPEC_BLEND_STACK_SIZE];
  if(KSPEC_MAT_TYPE_BLEND != 0)
    material_stack[0] = currMat;
  int top = 0;
  bool needPop = false;

  do
  {
    if(KSPEC_MAT_TYPE_BLEND != 0)
    {
      if(needPop)
      {
        top--;
        currMat = material_stack[max(top, 0)];
      }
      else
        needPop = true; // if not blend, pop on next iter
    } 
    
    // BSDF is multiplied (outside) by old cosThetaOut.
    // When normal map is enables this becames wrong because normal is changed;
    // First : return cosThetaOut in sam;
    // Second: apply cos(theta2)/cos(theta1) to cos(theta1) to get cos(theta2)
    //
    const vec3 geomNormal = n;
          vec3 shadeNormal = n;
    float bumpCosMult = 1.0f; 
    const uint normalMapId = m_materials[currMat.id].texid[1];
    if(KSPEC_BUMP_MAPPING != 0 && normalMapId != 0xFFFFFFFF) 
    {
      shadeNormal = BumpMapping(normalMapId, currMat.id, geomNormal, tan, tc);
      const vec3 lDir = l;     
      const float  clampVal = 1e-6f;  
      const float cosThetaOut1 = max(dot(lDir, geomNormal), 0.0f);
      const float cosThetaOut2 = max(dot(lDir, shadeNormal), 0.0f);
      bumpCosMult              = cosThetaOut2 / max(cosThetaOut1, clampVal);
      if (cosThetaOut1 <= 0.0f)
        bumpCosMult = 0.0f;
    }

    const vec2 texCoordT = mulRows2x4(m_materials[currMat.id].row0[0], m_materials[currMat.id].row1[0], tc);
    const uint   texId     = m_materials[currMat.id].texid[0];
    const vec4 texColor = texture(m_textures[texId], texCoordT);
    const uint   mtype     = m_materials[currMat.id].mtype;
    const uint   cflags    = m_materials[currMat.id].cflags;

    vec4 fourScalarMatParams = vec4(1,1,1,1);
    if(KSPEC_MAT_FOUR_TEXTURES != 0 && (cflags & FLAG_FOUR_TEXTURES) != 0)
    {
      const uint texId2  = m_materials[currMat.id].texid[2];
      const uint texId3  = m_materials[currMat.id].texid[3];

      const vec2 texCoord2T = mulRows2x4(m_materials[currMat.id].row0[2], m_materials[currMat.id].row1[2], tc);
      const vec2 texCoord3T = mulRows2x4(m_materials[currMat.id].row0[3], m_materials[currMat.id].row1[3], tc);

      const vec4 color2 = texture(m_textures[texId2], texCoord2T);
      const vec4 color3 = texture(m_textures[texId3], texCoord3T);
    
      if((cflags & FLAG_PACK_FOUR_PARAMS_IN_TEXTURE) != 0)
        fourScalarMatParams = color2;
      else
        fourScalarMatParams = vec4(color2.x,color3.x,1,1);
    }

    BsdfEval currVal;
    {
      currVal.val = vec4(0,0,0,0);
      currVal.pdf   = 0.0f;
    }
    switch(mtype)
    {
      case MAT_TYPE_GLTF:
      if(KSPEC_MAT_TYPE_GLTF != 0)
      {
        const vec4 color = (m_materials[currMat.id].colors[GLTF_COLOR_BASE]) * texColor;
        gltfEval_m_materials(currMat.id, l, v, shadeNormal, tc, color, fourScalarMatParams, currVal);
        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
      }
      break;
      case MAT_TYPE_GLASS:
      if(KSPEC_MAT_TYPE_GLASS != 0)
      {
        glassEval_m_materials(currMat.id, l, v, geomNormal, tc, vec3(0,0,0), currVal);
        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
      }
      break;
      case MAT_TYPE_CONDUCTOR: 
      if(KSPEC_MAT_TYPE_CONDUCTOR != 0)
      {
        const vec3 alphaTex = texColor.xyz;
        const vec2 alpha = vec2(m_materials[currMat.id].data[CONDUCTOR_ROUGH_V],m_materials[currMat.id].data[CONDUCTOR_ROUGH_U]);

        if(!trEffectivelySmooth(alpha))
        {
          const vec4 etaSpec = SampleMatParamSpectrum(currMat.id, wavelengths, CONDUCTOR_ETA, 0);
          const vec4 kSpec = SampleMatParamSpectrum(currMat.id, wavelengths, CONDUCTOR_K,   1);
          conductorRoughEval_m_materials(currMat.id, etaSpec, kSpec, l, v, shadeNormal, tc, alphaTex, currVal);
        }

        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
      }
      break;
      case MAT_TYPE_THIN_FILM: 
      if(KSPEC_MAT_TYPE_THIN_FILM != 0)
      {
        const vec3 alphaTex = texColor.xyz;  
        const vec2 alpha = vec2(m_materials[currMat.id].data[FILM_ROUGH_V],m_materials[currMat.id].data[FILM_ROUGH_U]);

        if(!trEffectivelySmooth(alpha))
        {
          uint t_offset = floatBitsToUint(m_materials[currMat.id].data[FILM_THICKNESS_OFFSET]);
          uint layers = floatBitsToUint(m_materials[currMat.id].data[FILM_LAYERS_COUNT]);
          const bool spectral_mode = wavelengths[0] > 0.0f;
          // sampling 3 wavelengths for naive RGB method
          vec4 wavelengths_spec = spectral_mode? vec4(wavelengths[0],0.0f,0.0f,0.0f) : vec4(700.f,525.f,450.f,0.0f);
          vec4 wavelengths_sample = spectral_mode? vec4(wavelengths[0],0.0f,0.0f,0.0f) : vec4(525.f,0.f,0.f,0.0f);
          float extIOR = m_materials[currMat.id].data[FILM_ETA_EXT];
          complex intIOR = make_complex(SampleFilmsSpectrum(currMat.id, wavelengths_sample, FILM_ETA_OFFSET, FILM_ETA_SPECID_OFFSET, layers - 1)[0],SampleFilmsSpectrum(currMat.id, wavelengths_sample, FILM_K_OFFSET, FILM_K_SPECID_OFFSET, layers - 1)[0]);      
          complex filmIOR = make_complex(SampleFilmsSpectrum(currMat.id, wavelengths, FILM_ETA_OFFSET, FILM_ETA_SPECID_OFFSET, 0)[0],SampleFilmsSpectrum(currMat.id, wavelengths, FILM_K_OFFSET, FILM_K_SPECID_OFFSET, 0)[0]);

          float thickness;
          if (floatBitsToUint(m_materials[currMat.id].data[FILM_THICKNESS_MAP]) > 0u)
          {
            const uint texId  = m_materials[currMat.id].texid[2];
            const vec2 texCoord = mulRows2x4(m_materials[currMat.id].row0[2], m_materials[currMat.id].row1[2], tc);
            const vec4 thickness_val = texture(m_textures[texId], texCoord);
            float thickness_max = m_materials[currMat.id].data[FILM_THICKNESS_MAX];
            float thickness_min = m_materials[currMat.id].data[FILM_THICKNESS_MIN];
            thickness = (thickness_max - thickness_min) * thickness_val.x + thickness_min;
          }
          else
          {
            thickness = m_materials[currMat.id].data[FILM_THICKNESS];
          }

          bool precomp_flag = floatBitsToUint(m_materials[currMat.id].data[FILM_PRECOMP_FLAG]) > 0u;
          uint precomp_offset = precomp_flag ? floatBitsToUint(m_materials[currMat.id].data[FILM_PRECOMP_OFFSET]) : 0;
          filmRoughEval_m_materials_m_precomp_thin_films(currMat.id, extIOR, filmIOR, intIOR, thickness, wavelengths_spec, l, v, n, tc, alphaTex, currVal, precomp_offset, spectral_mode, precomp_flag);
        }

        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
      }
      break;
      case MAT_TYPE_DIFFUSE:
      if(KSPEC_MAT_TYPE_DIFFUSE != 0)
      {
        const vec4 color = texColor;
        vec4 reflSpec = SampleMatColorSpectrumTexture(currMat.id, wavelengths, DIFFUSE_COLOR, 0, tc);
        if(ubo.m_spectral_mode == 0)
          reflSpec *= color;        
        diffuseEval_m_materials(currMat.id, reflSpec, l, v, shadeNormal, tc, currVal);

        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
      }
      break;
      case MAT_TYPE_PLASTIC:
      if(KSPEC_MAT_TYPE_PLASTIC != 0)
      {
        const vec4 color = texColor;
        vec4 reflSpec = SampleMatColorSpectrumTexture(currMat.id, wavelengths, PLASTIC_COLOR, 0, tc);
        // float4 reflSpec    = SampleMatColorParamSpectrum(currMat.id, wavelengths, PLASTIC_COLOR, 0);
        if(ubo.m_spectral_mode == 0)
          reflSpec *= color;
        const uint precomp_id = m_materials[currMat.id].datai[0];
        plasticEval_m_materials_m_precomp_coat_transmittance(currMat.id, reflSpec, l, v, shadeNormal, tc, currVal, precomp_id * MI_ROUGH_TRANSMITTANCE_RES);

        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
      }
      break;
      case MAT_TYPE_DIELECTRIC:
      if(KSPEC_MAT_TYPE_DIELECTRIC != 0)
      {
        dielectricSmoothEval(res); // val and pdf are always zero
      }
      break;
      case MAT_TYPE_BLEND:
      if(KSPEC_MAT_TYPE_BLEND != 0)
      {
        MatIdWeightPair childMats = BlendEval(currMat, wavelengths, l, v, geomNormal, tc);
        currMat = childMats.first;
        needPop = false;                        // we already put 'childMats.first' in 'currMat'
        if(top + 1 <= KSPEC_BLEND_STACK_SIZE)
        {
          material_stack[top] = childMats.second; // remember second mat in stack
          top++;
        }
      }
      break;
      default:
        break;
    }

  } while(KSPEC_MAT_TYPE_BLEND != 0 && top > 0);

  return res;
}

uint RemapMaterialId(uint a_mId, int a_instId) {
  const int remapListId  = m_remapInst[a_instId];
  if(remapListId == -1)
    return a_mId;

  const int r_offset     = m_allRemapListsOffsets[remapListId];
  const int r_size       = m_allRemapListsOffsets[remapListId+1] - r_offset;
  const ivec2 offsAndSize = ivec2(r_offset,r_size);
  
  uint res = a_mId;
  
  // for (int i = 0; i < offsAndSize.y; i++) // linear search version
  // {
  //   int idRemapFrom = m_allRemapLists[offsAndSize.x + i * 2 + 0];
  //   int idRemapTo   = m_allRemapLists[offsAndSize.x + i * 2 + 1];
  //   if (idRemapFrom == a_mId) {
  //     res = idRemapTo;
  //     break;
  //   }
  // }

  int low  = 0;
  int high = offsAndSize.y - 1;              // binary search version
  
  while (low <= high)
  {
    const int mid         = low + ((high - low) / 2);
    const int idRemapFrom = m_allRemapLists[offsAndSize.x + mid * 2 + 0];
    if (uint(idRemapFrom) >= a_mId)
      high = mid - 1;
    else //if(a[mid]<i)
      low = mid + 1;
  }

  if (high+1 < offsAndSize.y)
  {
    const int idRemapFrom = m_allRemapLists[offsAndSize.x + (high + 1) * 2 + 0];
    const int idRemapTo   = m_allRemapLists[offsAndSize.x + (high + 1) * 2 + 1];
    res                   = (uint(idRemapFrom) == a_mId) ? uint(idRemapTo) : a_mId;
  }

  return res;
}

void m_pAccelStruct_BVH2TraverseF32(const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, bool stopOnFirstHit, inout CRT_Hit pHit) {
  const uint bvhOffset = m_pAccelStruct_m_geomData[geomId].bvhOffset;

  uint32_t stack[STACK_SIZE];
  int top = 0;
  uint leftNodeOffset = 0;
  bool hitFound = false; //set to true if we found a hit with an opaque object
                         //1) if stopOnFirstHit = true, it is some hit, not closest
                         //2) if we hit and object of some specific type (i.e. octree)
                         //   we can guarantee that the first hit will be the closest

  const vec3 rayDirInv = SafeInverse(ray_dir);
  while (top >= 0 && !hitFound)
  {
#ifndef DISABLE_RF_GRID
    if (m_RFGridFlags.size() > 0 && pHit->coords[0] <= 0.01f)
      break;
#endif

    while (top >= 0 && ((leftNodeOffset & LEAF_BIT) == 0))
    {
      const BVHNodePair fatNode = m_pAccelStruct_m_allNodePairs[bvhOffset + leftNodeOffset];

      const uint node0_leftOffset = fatNode.left.leftOffset;
      const uint node1_leftOffset = fatNode.right.leftOffset;

      const vec2 tm0 = RayBoxIntersection2(ray_pos, rayDirInv, fatNode.left.boxMin, fatNode.left.boxMax);
      const vec2 tm1 = RayBoxIntersection2(ray_pos, rayDirInv, fatNode.right.boxMin, fatNode.right.boxMax);

#ifndef DISABLE_RF_GRID
      const bool hitChild0 = (tm0.x <= tm0.y) && (tm0.y >= tNear) && (tm0.x <= pHit->t || !stopOnFirstHit);
      const bool hitChild1 = (tm1.x <= tm1.y) && (tm1.y >= tNear) && (tm1.x <= pHit->t || !stopOnFirstHit);
#else
      const bool hitChild0 = (tm0.x <= tm0.y) && (tm0.y >= tNear) && (tm0.x <= pHit.t);
      const bool hitChild1 = (tm1.x <= tm1.y) && (tm1.y >= tNear) && (tm1.x <= pHit.t);
#endif
      // traversal decision
      leftNodeOffset = hitChild0 ? node0_leftOffset : node1_leftOffset;

      if (hitChild0 && hitChild1)
      {
        leftNodeOffset = (tm0.x <= tm1.x) ? node0_leftOffset : node1_leftOffset; // GPU style branch
        stack[top]     = (tm0.x <= tm1.x) ? node1_leftOffset : node0_leftOffset; // GPU style branch
        top++;
      }

      if (!hitChild0 && !hitChild1) // both miss, stack.pop()
      {
        top--;
        leftNodeOffset = stack[max(top, 0)];
      }

    } // end while (searchingForLeaf)

    // leaf node, intersect triangles
    //
    if (top >= 0 && leftNodeOffset != 0xFFFFFFFF)
    {
      CRT_LeafInfo leafInfo;
      leafInfo.aabbId = EXTRACT_START(leftNodeOffset);
      leafInfo.instId = instId;

      const float SDF_BIAS = 0.01f;
      const float tNearSdf = max(tNear, SDF_BIAS);
  
      // if (debug_cur_pixel)
      //  printf("intersecting with leaf %u, inst %u\n", leafInfo.aabbId, leafInfo.instId);
      uint hitTag = AbstractObject_Intersect_m_pAccelStruct_m_abstractObjectPtrs(geomId,vec4(ray_pos, tNearSdf),vec4(ray_dir, 1e9f),leafInfo,pHit );
      hitFound = (hitTag != 0 /*TAG_NONE*/) && (first_hit_is_closest(hitTag) || stopOnFirstHit);
    }

    // continue BVH traversal
    //
    top--;
    leftNodeOffset = stack[max(top, 0)];

  } // end while (top >= 0)

}

CRT_Hit m_pAccelStruct_RayQuery_NearestHit(vec4 posAndNear, vec4 dirAndFar) {
  bool stopOnFirstHit = (dirAndFar.w <= 0.0f);
  if(stopOnFirstHit)
    dirAndFar.w *= -1.0f;
  const vec3 rayDirInv = SafeInverse(dirAndFar.xyz);

  CRT_Hit hit;
  hit.t      = dirAndFar.w;
  hit.primId = uint32_t(-1);
  hit.instId = uint32_t(-1);
  hit.geomId = uint32_t(-1);
  hit.coords[0] = 1.0f;
  hit.coords[1] = 0.0f;
  hit.coords[2] = 0.0f;
  hit.coords[3] = 0.0f;

  {
    uint nodeIdx = 0;
    do
    {
#ifndef DISABLE_RF_GRID
      if (m_RFGridFlags.size() > 0 && hit.coords[0] <= 0.01f)
        break;
#endif

      uint travFlags = 0;
      uint leftOffset = 0;
      do
      {
        const BVHNode currNode = m_pAccelStruct_m_nodesTLAS[nodeIdx];
        const vec2 boxHit = RayBoxIntersection2(posAndNear.xyz, rayDirInv, currNode.boxMin, currNode.boxMax);
        const bool intersects = (boxHit.x <= boxHit.y) && (boxHit.y > posAndNear.w) && (boxHit.x < hit.t); // (tmin <= tmax) && (tmax > 0.f) && (tmin < curr_t)

        travFlags  = (currNode.leftOffset & LEAF_BIT) | uint32_t(intersects); // travFlags  = (((currNode.leftOffset & LEAF_BIT) == 0) ? 0 : LEAF_BIT) | (intersects ? 1 : 0);
        leftOffset = currNode.leftOffset;
        nodeIdx    = isLeafOrNotIntersect(travFlags) ? currNode.escapeIndex : leftOffset;

      } while (notLeafAndIntersect(travFlags) && nodeIdx != 0 && nodeIdx < 0xFFFFFFFE); 
      
      if(isLeafAndIntersect(travFlags)) 
      {
        const uint instId = EXTRACT_START(leftOffset);
        const uint geomId = m_pAccelStruct_m_instanceData[instId].geomId;
    
        // transform ray with matrix to local space
        //
        const vec3 ray_pos = matmul4x3(m_pAccelStruct_m_instanceData[instId].transformInv, posAndNear.xyz);
        const vec3 ray_dir = matmul3x3(m_pAccelStruct_m_instanceData[instId].transformInv, dirAndFar.xyz); // DON'float NORMALIZE IT !!!! When we transform to local space of node, ray_dir must be unnormalized!!!
    
        // if (debug_cur_pixel)
        // {
        //   printf("intersect %u %u (stopOnFirstHit = %u)\n", instId, geomId, (unsigned)stopOnFirstHit);
        //   printf("ray_pos before = %f %f %f, after = %f %f %f\n", posAndNear.x, posAndNear.y, posAndNear.z, ray_pos.x, ray_pos.y, ray_pos.z);
        // }
        m_pAccelStruct_BVH2TraverseF32(ray_pos, ray_dir, posAndNear.w, instId, geomId, stopOnFirstHit, hit);
      }
    } while (nodeIdx < 0xFFFFFFFE && !(stopOnFirstHit && hit.primId != uint32_t(-1))); //
  }

#ifndef DISABLE_MESH
  if(hit.geomId < uint32_t(-1) && ((hit.geomId >> SH_TYPE) == TYPE_MESH_TRIANGLE)) 
  {
    const uvec2 geomOffsets = m_pAccelStruct_m_geomData[hit.geomId & GEOM_ID_MASK].offset;
    hit.primId = m_pAccelStruct_m_primIndices[geomOffsets.x/3 + hit.primId];
  }
#endif
  
  return hit;
}

uint packMatId(uint a_flags, uint a_matId) { return (a_flags & 0xFF000000) | (a_matId & 0x00FFFFFF); }

vec4 m_pAccelStruct_rbezier_grid_point(float u, float v, NURBSHeader h) {
  int uoffset = uknots_offset(h);
  int voffset = vknots_offset(h);
  int uspan = m_pAccelStruct_find_span(u, uoffset, h.uknots_cnt, h);
  int vspan = m_pAccelStruct_find_span(v, voffset, h.vknots_cnt, h);
  float umin = m_pAccelStruct_knot(uspan, uoffset), umax = m_pAccelStruct_knot(uspan+1, uoffset);
  float vmin = m_pAccelStruct_knot(vspan, voffset), vmax = m_pAccelStruct_knot(vspan+1, voffset);
  u = (u-umin)/(umax-umin);
  v = (v-vmin)/(vmax-vmin);
  return m_pAccelStruct_rbezier_surface_point(u, v, pts_offset(h, uspan, vspan), h);
}

float m_pAccelStruct_eval_distance_sdf_sbs(uint sbs_id, vec3 pos) {
  uint type = m_pAccelStruct_m_geomData[sbs_id].type;
  // assert (type == TYPE_SDF_SBS); // || type == TYPE_SDF_SBS_COL || type == TYPE_SDF_SBS_TEX
  uint leftNodeOffset = m_pAccelStruct_eval_distance_traverse_bvh(sbs_id, pos);

  if (leftNodeOffset == 0xFFFFFFFF)
    return 11.f; // cannot be used for ST
  // printf("NodeOffset: %d\n", leftNodeOffset);

  uint globalAABBId = m_pAccelStruct_startEnd[sbs_id].x + EXTRACT_START(leftNodeOffset); // + aabbId
  uint start_count_packed = m_pAccelStruct_m_primIdCount[globalAABBId];
  uint a_start = EXTRACT_START(start_count_packed);
  uint a_count = EXTRACT_COUNT(start_count_packed);

  #ifdef USE_TRICUBIC
  float values[64];
  #else
  float values[8];
  #endif

  uint nodeId,  primId;
  float d, qNear, qFar;
  vec2 fNearFar;
  vec3 start_q;

  qNear = 1.0f;

  uint sdfId = m_pAccelStruct_m_geomData[sbs_id].offset.x;
  primId = a_start; //id of bbox in BLAS
  nodeId = primId + m_pAccelStruct_m_SdfSBSRoots[sdfId];
  SdfSBSHeader header = m_pAccelStruct_m_SdfSBSHeaders[sdfId];
  uint v_size = header.brick_size + 2*header.brick_pad + 1;

  float px = m_pAccelStruct_m_SdfSBSNodes[nodeId].pos_xy >> 16;
  float py = m_pAccelStruct_m_SdfSBSNodes[nodeId].pos_xy & 0x0000FFFF;
  float pz = m_pAccelStruct_m_SdfSBSNodes[nodeId].pos_z_lod_size >> 16;
  float sz = m_pAccelStruct_m_SdfSBSNodes[nodeId].pos_z_lod_size & 0x0000FFFF;
  float sz_inv = 2.0f/sz;
  
  d = 2.0f/(sz*float(header.brick_size));

  vec3 brick_min_pos = vec3(-1,-1,-1) + sz_inv*vec3(px,py,pz);
  vec3 brick_max_pos = brick_min_pos + sz_inv*vec3(1,1,1);

  float res_dist = 10.0f;
  if (pos.x >= brick_min_pos.x && pos.x <= brick_max_pos.x &&
      pos.y >= brick_min_pos.y && pos.y <= brick_max_pos.y &&
      pos.z >= brick_min_pos.z && pos.z <= brick_max_pos.z)
  {
    // hit

    vec3 local_pos = (pos - brick_min_pos) * (0.5f*sz*float(header.brick_size));
    vec3 voxelPos = floor(clamp(local_pos, 1e-6f, float(header.brick_size)-1e-6f));

    vec3 min_pos = brick_min_pos + d*voxelPos;
    vec3 max_pos = min_pos + d*vec3(1,1,1);
    start_q = (pos - min_pos) * (0.5f*sz*float(header.brick_size));

    m_pAccelStruct_load_distance_values(nodeId, voxelPos, v_size, sz_inv, header, values);

#ifdef USE_TRICUBIC
    float point[3] = {start_q.x, start_q.y, start_q.z};
    res_dist = tricubicInterpolation(values, point);
#else
    res_dist = m_pAccelStruct_eval_dist_trilinear(values, start_q);
#endif
  }
  return res_dist;
}

float m_pAccelStruct_COctreeV3_LoadDistanceValues(uint leafType, uint brickOffset, vec3 voxelPos, uint v_size, float sz_inv, in COctreeV3Header header, uint transform_code, inout float values[8]) {
  switch (leafType)
  {
  case COCTREE_LEAF_TYPE_GRID:
    return m_pAccelStruct_COctreeV3_LoadDistanceValuesLeafGrid(brickOffset, voxelPos, v_size, sz_inv, header, transform_code, values);
  case COCTREE_LEAF_TYPE_BIT_PACK:
    return m_pAccelStruct_COctreeV3_LoadDistanceValuesLeafBitPack(brickOffset, voxelPos, v_size, sz_inv, header, transform_code, values);
  case COCTREE_LEAF_TYPE_SLICES:
    return m_pAccelStruct_COctreeV3_LoadDistanceValuesLeafSlices(brickOffset, voxelPos, v_size, sz_inv, header, transform_code, values);
  }
  return 1e6f;
}

float GetRandomNumbersMatB(uint tid, inout RandomGen a_gen, int a_bounce, int a_layer) { return rndFloat1_Pseudo(a_gen); }

void m_pAccelStruct_OctreeIntersectV3(uint type, const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint bvhNodeId, uint a_count, inout CRT_Hit pHit) {
#if ON_CPU==1
  assert(COctreeV3::VERSION == 5); //if version is changed, this function should be revisited, as some changes may be needed
#endif

#ifndef DISABLE_SDF_COCTREE_V3
  vec3 pos_ray_pos = ray_pos;
  vec3 pos_ray_dir = ray_dir;

  //assume octree is box [-1,1]^3
  uint a = 0;
  if (ray_dir.x < 0)
  {
    pos_ray_pos.x *= -1;
    pos_ray_dir.x *= -1;
    a |= 4;
  }

  if (ray_dir.y < 0)
  {
    pos_ray_pos.y *= -1;
    pos_ray_dir.y *= -1;
    a |= 2;
  }

  if (ray_dir.z < 0)
  {
    pos_ray_pos.z *= -1;
    pos_ray_dir.z *= -1;
    a |= 1;
  }

  vec3 min_pos = m_pAccelStruct_m_origNodes[bvhNodeId].boxMin;
  vec3 max_pos = m_pAccelStruct_m_origNodes[bvhNodeId].boxMax;
  vec3 center = 0.5f * (min_pos + max_pos);

  uint start_sz = uint32_t(2.0f / (max_pos.x - min_pos.x));
  uvec3 start_p_orig = uvec3(float(start_sz)*0.5f*(min_pos - vec3(-1,-1,-1)));
  uint p_mask = start_sz - 1;
  uvec3 start_p = uvec3(((a & 4) > 0) ? (~start_p_orig.x & p_mask) : start_p_orig.x,((a & 2) > 0) ? (~start_p_orig.y & p_mask) : start_p_orig.y,((a & 1) > 0) ? (~start_p_orig.z & p_mask) : start_p_orig.z);

  uint startNodeOffset = m_pAccelStruct_m_origNodes[bvhNodeId].leftOffset;

  pos_ray_pos *= -1;
  const vec3 pos_ray_dir_inv = SafeInverse(pos_ray_dir);
  const vec3 _t0 = pos_ray_pos * pos_ray_dir_inv - pos_ray_dir_inv;
  const vec3 _t1 = pos_ray_pos * pos_ray_dir_inv + pos_ray_dir_inv;
  const vec3 _l = _t1 - _t0;

  const uvec3 nn_indices[8] = {uvec3(4,2,1), uvec3(5,3,8), uvec3(6,8,3), uvec3(7,8,8),
                               uvec3(8,6,5), uvec3(8,7,8), uvec3(8,8,7), uvec3(8,8,8)};

  OTStackElement stack[32];
  OTStackElement tmp_buf[4];

  int top = 0;
  int buf_top = 0;
  uvec3 p;
  vec3 p_f,  t0,  t1,  tm;
  int currNode;
  uint32_t level_sz;
  float d;
  const float old_t = pHit.t;

  stack[top].nodeId = startNodeOffset;
  stack[top].info = 0;
  stack[top].p_size = uvec2((start_p.x << 16) | start_p.y,(start_p.z << 16) | start_sz);

    while (top >= 0)
    {
      level_sz = stack[top].p_size.y & 0xFFFF;
      p = uvec3(stack[top].p_size.x >> 16,stack[top].p_size.x & 0xFFFF,stack[top].p_size.y >> 16);
      d = 1.0f/float(level_sz);
      p_f = vec3(p);
      t0 = _t0 + d*p_f * _l;
      t1 = _t0 + d*(p_f + 1) * _l;

      float t_out = min(min(t1.x, t1.y), t1.z);
      if (t_out < tNear)
      {
        top--;
        continue;
      }

      bool is_leaf = (stack[top].info & COCTREE_LEAF_TYPE_MASK) != COCTREE_LEAF_TYPE_NOT_A_LEAF;
      if (ubo.m_pAccelStruct_coctree_v3_header.lods > 0 && !is_leaf)
      {
        float t = ubo.m_pAccelStruct_m_preset.fixed_lod > 0 ? 1.0f : max(t0.x, max(t0.y, t0.z));
        float target_lod_size = (pow(2.0f, ubo.m_pAccelStruct_m_preset.level_of_detail) - 0.01f)/t;
        if (float(level_sz*ubo.m_pAccelStruct_coctree_v3_header.brick_size) > target_lod_size)
        {
          uint lodLeafId = m_pAccelStruct_m_SdfCompactOctreeV3Data[stack[top].nodeId + 1];
          uint type = (m_pAccelStruct_m_SdfCompactOctreeV3Data[stack[top].nodeId + 0] >> COCTREE_LOD_LEAF_TYPE_SHIFT) & COCTREE_LEAF_TYPE_MASK;
          uint infoOffset = stack[top].nodeId + 1 + ubo.m_pAccelStruct_coctree_v3_header.trans_off;
          stack[top].nodeId = lodLeafId;
          stack[top].info = (m_pAccelStruct_m_SdfCompactOctreeV3Data[infoOffset] << COCTREE_LEAF_TYPE_BITS) | type;
          is_leaf = true;

          //we should stop on this LOD level, but this node is empty, so just skip it
          if (type == COCTREE_LEAF_TYPE_NOT_A_LEAF)
          {
            top--;
            continue; //
          }
        }
      }

      if (is_leaf)
      {
        uint p_mask = level_sz - 1;
        uvec3 real_p = uvec3(((a & 4) > 0) ? (~p.x & p_mask) : p.x,((a & 2) > 0) ? (~p.y & p_mask) : p.y,((a & 1) > 0) ? (~p.z & p_mask) : p.z);

        uint leafOffset = (stack[top].nodeId & ubo.m_pAccelStruct_coctree_v3_header.idx_mask) >> ubo.m_pAccelStruct_coctree_v3_header.idx_sh;
        m_pAccelStruct_COctreeV3_BrickIntersect(TYPE_SDF_FRAME_OCTREE, ray_pos, ray_dir, tNear, instId, geomId, ubo.m_pAccelStruct_coctree_v3_header, leafOffset, vec3(real_p), float(level_sz), stack[top].info, pHit);

        if (pHit.t < old_t)
        {
          top = -1;
          if (ubo.m_pAccelStruct_m_preset.render_mode == MULTI_RENDER_MODE_LOD)
            pHit.primId = uint32_t(log2(float(level_sz*ubo.m_pAccelStruct_coctree_v3_header.brick_size)));
        }
        else
          top--;
      }
      else
      { 
        buf_top = 0;
        tm = 0.5f*(t0 + t1);

        currNode = first_node(t0, tm);
        do
        {
          //0-7 bits are child_is_active flags, next 8-15 bits are child_is_leaf flags
          uint childrenInfo = m_pAccelStruct_m_SdfCompactOctreeV3Data[stack[top].nodeId + 0];
          uint childNode = uint(currNode) ^ a; //child node number, from 0 to 8

          // if child is active
          if ((childrenInfo & (1u << childNode)) > 0)
          {
            uint localChildPos = ubo.m_pAccelStruct_coctree_v3_header.lods + bitCount(childrenInfo & ((1u << childNode) - 1));
            uint childPos = 1 + ubo.m_pAccelStruct_coctree_v3_header.uints_per_child_info*localChildPos;
            uint childOffset = m_pAccelStruct_m_SdfCompactOctreeV3Data[stack[top].nodeId + childPos];
            uint childType = (childrenInfo >> (8 + COCTREE_LEAF_TYPE_BITS*childNode)) & COCTREE_LEAF_TYPE_MASK;
            uint childInfoOffset = stack[top].nodeId + childPos + ubo.m_pAccelStruct_coctree_v3_header.trans_off;
            uint childInfo = (m_pAccelStruct_m_SdfCompactOctreeV3Data[childInfoOffset] << COCTREE_LEAF_TYPE_BITS) | childType;

            tmp_buf[buf_top].nodeId = childOffset;
            tmp_buf[buf_top].info = childInfo;
            tmp_buf[buf_top].p_size = (stack[top].p_size << 1) | uvec2(((currNode & 4) << (16-2)) | ((currNode & 2) >> 1),(currNode & 1) << 16);
            buf_top++;
          }
          currNode = new_node(((currNode & 4) > 0) ? t1.x : tm.x, int(nn_indices[currNode].x),
                              ((currNode & 2) > 0) ? t1.y : tm.y, int(nn_indices[currNode].y),
                              ((currNode & 1) > 0) ? t1.z : tm.z, int(nn_indices[currNode].z));
        } while (currNode<8);

        for (int i = 0; i < buf_top; i++)
        {
          stack[top+i] = tmp_buf[buf_top-i-1];
        }
        top += buf_top - 1;
      }
    }
#endif
}

vec4 m_pAccelStruct_rbezier_grid_vder(float u, float v, in vec4 Sw, NURBSHeader h) {
  int uoffset = uknots_offset(h);
  int voffset = vknots_offset(h);
  int uspan = m_pAccelStruct_find_span(u, uoffset, h.uknots_cnt, h);
  int vspan = m_pAccelStruct_find_span(v, voffset, h.vknots_cnt, h);
  float umin = m_pAccelStruct_knot(uspan, uoffset), umax = m_pAccelStruct_knot(uspan+1, uoffset);
  float vmin = m_pAccelStruct_knot(vspan, voffset), vmax = m_pAccelStruct_knot(vspan+1, voffset);
  u = (u-umin)/(umax-umin);
  v = (v-vmin)/(vmax-vmin);
  vec4 surf_der = m_pAccelStruct_rbezier_surface_vder(u, v, Sw, pts_offset(h, uspan, vspan), h);
  return surf_der * (1.0f/(vmax-vmin));
}

float m_pAccelStruct_tricubicInterpolation(const float grid[64], const float dp[3]) {
  float res = 0;
  float values_yz[16];
  float values_z[4];

  for (uint j = 0; j < 4; ++j)
  {
    for (uint k = 0; k < 4; ++k)
    {
      //m_SdfGridData[off + (vox_u.z)*size.x*size.y + (vox_u.y)*size.x + (vox_u.x)]
      values_yz[4*j + k] = 
        tricubic_spline(
            grid[k*4*4 + (j)*4 + (0)],
            grid[k*4*4 + (j)*4 + (1)],
            grid[k*4*4 + (j)*4 + (2)],
            grid[k*4*4 + (j)*4 + (3)], 
            dp[0]
      );
    }
  }

  for (uint k = 0; k < 4; ++k)
  {
    values_z[k] = 
      tricubic_spline(
          values_yz[4*0 + k], 
          values_yz[4*1 + k], 
          values_yz[4*2 + k], 
          values_yz[4*3 + k], 
          dp[1]
    );
  }

  res = tricubic_spline(values_z[0], values_z[1], values_z[2], values_z[3], dp[2]);

  return res;
}

float m_pAccelStruct_eval_dist_trilinear(const float values[8], vec3 dp) {
  return (1-dp.x)*(1-dp.y)*(1-dp.z)*values[0] + 
         (1-dp.x)*(1-dp.y)*(  dp.z)*values[1] + 
         (1-dp.x)*(  dp.y)*(1-dp.z)*values[2] + 
         (1-dp.x)*(  dp.y)*(  dp.z)*values[3] + 
         (  dp.x)*(1-dp.y)*(1-dp.z)*values[4] + 
         (  dp.x)*(1-dp.y)*(  dp.z)*values[5] + 
         (  dp.x)*(  dp.y)*(1-dp.z)*values[6] + 
         (  dp.x)*(  dp.y)*(  dp.z)*values[7];
}

float m_pAccelStruct_eval_distance_sdf(uint type, uint sdf_id, vec3 pos) {
  float val = 1000;
  switch (type)
  {
#ifndef DISABLE_SDF_GRID
  case TYPE_SDF_GRID:
    val = eval_distance_sdf_grid(sdf_id, pos);
    break;
#endif
#ifndef DISABLE_SDF_SBS
  case TYPE_SDF_SBS:
    val = m_pAccelStruct_eval_distance_sdf_sbs(sdf_id, pos);
    break;
#endif
  default:
    break;
  }
  return val;
}

void RecordBlendRndNeeded(uint bounceId, uint layer, float rand) {}

void m_pAccelStruct_LocalSurfaceIntersection(uint type, const vec3 ray_dir, uint instId, uint geomId, inout float values[8], uint nodeId, uint primId, float d, float qNear, float qFar, vec2 fNearFar, vec3 start_q, inout CRT_Hit pHit) {
  const float EPS = 1e-6f;
  float d_inv = 1.0f / d;
  float t = qNear;
  bool hit = false;
  uint iter = 0;

  float start_dist = 10000;
  float start_sign = 1;

  start_dist = m_pAccelStruct_eval_dist_trilinear(values, start_q + t * ray_dir);
  /*If we want to represent thin surfaces, we should find rays that reach 
  //zero distance regardless of what thww sign of initial distance is.
  //However, it can lead to visual artifacts and disabled by default
  */
  if (ubo.m_pAccelStruct_m_preset.representation_mode == REPRESENTATION_MODE_SURFACE)
    start_sign = sign(start_dist);
  start_dist *= start_sign;

  if (start_dist <= EPS || ubo.m_pAccelStruct_m_preset.sdf_node_intersect == SDF_OCTREE_NODE_INTERSECT_BBOX)
  {
    hit = true;
  }
  else if (ubo.m_pAccelStruct_m_preset.sdf_node_intersect == SDF_OCTREE_NODE_INTERSECT_ST)
  {
    const uint ST_max_iters = 256;
    float dist = start_dist;
    vec3 pp0 = start_q + t * ray_dir;

    while (t < qFar && dist > EPS && iter < ST_max_iters)
    {
      t += dist * d_inv;

      dist = start_sign*m_pAccelStruct_eval_dist_trilinear(values, start_q + t * ray_dir);
      
      vec3 pp = start_q + t * ray_dir;
      iter++;
    }
    hit = (dist <= EPS);
  }
  else //if (m_preset.sdf_node_intersect == SDF_OCTREE_NODE_INTERSECT_ANALYTIC ||
       //    m_preset.sdf_node_intersect == SDF_OCTREE_NODE_INTERSECT_NEWTON ||
       //    m_preset.sdf_node_intersect == SDF_OCTREE_NODE_INTERSECT_IT)
  {
    //finding exact intersection between surface sdf(x,y,z) = 0 and ray
    // based on paper "Ray Tracing of Signed Distance Function Grids, 
    // Journal of Computer Graphics Techniques (JCGT), vol. 11, no. 3, 94-113, 2022"
    // http://jcgt.org/published/0011/03/06/

    // define values and constants as proposed in paper
    float s000 = values[0]*d_inv;
    float s001 = values[1]*d_inv;
    float s010 = values[2]*d_inv;
    float s011 = values[3]*d_inv;
    float s100 = values[4]*d_inv;
    float s101 = values[5]*d_inv;
    float s110 = values[6]*d_inv;
    float s111 = values[7]*d_inv;

    float a = s101-s001;

    float k0 = s000;
    float k1 = s100-s000;
    float k2 = s010-s000;
    float k3 = s110-s010-k1;
    float k4 = k0-s001;
    float k5 = k1-a;
    float k6 = k2-(s011-s001);
    float k7 = k3-(s111-s011-a);

    vec3 o = start_q;
    vec3 d3 = ray_dir;

    float m0 = o.x*o.y;
    float m1 = d3.x*d3.y;
    float m2 = o.x*d3.y + o.y*d3.x;
    float m3 = k5*o.z - k1;
    float m4 = k6*o.z - k2;
    float m5 = k7*o.z - k3;

    float c0 = (k4*o.z - k0) + o.x*m3 + o.y*m4 + m0*m5;
    float c1 = d3.x*m3 + d3.y*m4 + m2*m5 + d3.z*(k4 + k5*o.x + k6*o.y + k7*m0);
    float c2 = m1*m5 + d3.z*(k5*d3.x + k6*d3.y + k7*m2);
    float c3 = k7*m1*d3.z;

    // the surface is defined by equation c3*t^3 + c2*t^2 + c1*t + c0 = 0;
    // solve this equation analytically or numerically using the Newton's method
    // see "Numerical Recipes - The Art of Scientific Computing - 3rd Edition" for details

    if (ubo.m_pAccelStruct_m_preset.sdf_node_intersect == SDF_OCTREE_NODE_INTERSECT_ANALYTIC)
    {
      float x1 = 1000;
      float x2 = 1000;
      float x3 = 1000;
      uint type = 0;
      if (abs(c3) > 1e-2)
      {
        type = 3;
        //it is a cubic equation, transform it to x^3 + a*x^2 + b*x + c = 0
        //use Vieta method to obtain 3 or 1 real roots
        float a = c2/c3;
        float b = c1/c3;
        float c = c0/c3;   

        float Q = (a*a - 3*b)/9;
        float R = (2*a*a - 9*a*b + 27*c)/54;
        float Q3 = Q*Q*Q;

        if (R*R < Q3) //equation has three real roots
        {
          float theta = acos(R/sqrt(Q3));
          x1 = -2*sqrt(Q)*cos(theta/3) - a/3;
          x2 = -2*sqrt(Q)*cos((theta+2*M_PI)/3) - a/3;
          x3 = -2*sqrt(Q)*cos((theta-2*M_PI)/3) - a/3;
        }
        else //equation has only one real roots
        {
          float A = -sign(R)*pow(abs(R) + sqrt(R*R - Q3), 1.0f/3.0f);
          float B = abs(A) > EPS ? Q/A : 0;
          x1 = A+B - a/3;
        }
      }
      else if (abs(c2) > 1e-4)
      {
        type = 2;
        //it is a quadratic equation a*x^2 + b*x + c = 0
        float a = c2;
        float b = c1;
        float c = c0;

        float D = b*b - 4*a*c;
        if (D > 0)
        {
          float q = -0.5f*(b + sign(b)*sqrt(D));
          x1 = q/a;
          if (abs(q) > EPS)
            x2 = c/q; 
        }
      }
      else if (abs(c1) > EPS)
      {
        type = 1;
        //it is a linear equation c1*x + c0 = 0
        x1 = -c0/c1;
      }
      //else
      //no roots or inf roots, something's fucked up so just drop it

      x1 = x1 < 0 ? 1000 : x1;
      x2 = x2 < 0 ? 1000 : x2;
      x3 = x3 < 0 ? 1000 : x3;

      //bool prev_hit = hit;
      //float nt = std::min(x1, std::min(x2,x3));
      //if (prev_hit && std::abs(t - nt) > 0.1)
      //  printf("%f-%f -- %f %f %f %f -- %f %f %f, type %u\n",t, nt, c3,c2,c1,c0, x1,x2,x3, type);
      t = min(x1, min(x2, x3));
      hit = (t >= 0 && t <= qFar);
    }
    else if (ubo.m_pAccelStruct_m_preset.sdf_node_intersect == SDF_OCTREE_NODE_INTERSECT_NEWTON)
    {
      // our polynom is c3*t^3 + c2*t^2 + c1*t + c0 = 0;
      // it's derivative is  3*c3*t^2 + 2*c2*t + c1 = 0; 
      // find where it equals 0 to determine interval where the root is located
      // by solving a quadratic equation a*x^2 + b*x + c = 0
      float a = 3*c3;
      float b = 2*c2;
      float c = c1;

      float t0 = 0;
      float t1 = qFar;
      float t2 = qFar;
      float t3 = qFar;

      float D = b*b - 4*a*c;
      if (D >= 0)
      {
        float q = -0.5f*(b + sign(b)*sqrt(D));
        t1 = abs(a) > EPS ? q/a : t0;
        t2 = abs(q) > EPS ? c/q : qFar;

        float tmp = min(t1, t2);
        t2 = max(t1, t2);
        t1 = tmp;

        t1 = clamp(t1, t0, t3);
        t2 = clamp(t2, t0, t3);
      }
      
      //calculate sign of initial polynom at each critical point
      bool s0 = c0 > 0;
      bool s1 = (c0 + t1*(c1 + t1*(c2 + t1*c3))) > 0;
      bool s2 = (c0 + t2*(c1 + t2*(c2 + t2*c3))) > 0;
      bool s3 = (c0 + t3*(c1 + t3*(c2 + t3*c3))) > 0;

      //determine the range to apply Newton's method
      float nwt_min = t0;
      float nwt_max = t0;
      if (int(s0) != int(s1))
      {
        nwt_min = t0;
        nwt_max = t1;
      }
      else if (int(s1) != int(s2))
      {
        nwt_min = t1;
        nwt_max = t2;
      }
      else if (int(s2) != int(s3))
      {
        nwt_min = t2;
        nwt_max = t3;
      }

      float rtn = -100;

      if (nwt_min < nwt_max)
      {
        //perform Newton's method
        const uint max_iters = 10;
        uint iter = 0;
        rtn = 0.5f*(nwt_min + nwt_max);
        float f = 1000;
        while (iter < max_iters && abs(f) >= EPS)
        {
          f = c0 + rtn*(c1 + rtn*(c2 + rtn*c3));
          float df = c1 + rtn*(2*c2 + rtn*3*c3);
          float dx = f/(df + sign(df)*1e-9f);
          rtn -= dx;
          iter++;
        }
        t = rtn;
        hit = (t >= 0 && t <= qFar && abs(f) < EPS);
      }
      else
      {
        //no hit
        hit = false;
      }

      //bool prev_hit = hit;
      //float nt = rtn;
      //if (prev_hit && std::abs(t - nt) > 0.1)
      //  printf("%f-%f -- %f %f %f %f -- %f -- %f %f %f %f %d %d %d %d\n",t, nt, c3,c2,c1,c0, rtn, t0, t1, t2, t3, s0, s1, s2, s3);
    }
    else //if (m_preset.sdf_node_intersect == SDF_OCTREE_NODE_INTERSECT_IT)
    {
      const uint IT_max_iters = 256;
      const float k = 2;

      float e = 0.1f*qFar;
      float t_max = abs(c3) < EPS ? 1e6 : -c2/(3*c3);
      float df_max = 3*c3*t_max*t_max + 2*c2*t_max + c1;

      float dist = start_dist;
      vec3 pp = start_q + t * ray_dir;

      while (t < qFar && dist > EPS && iter < IT_max_iters)
      {
        float df_1 = 3*c3*t*t + 2*c2*t + c1;
        float df_2 = 3*c3*(t+e)*(t+e) + 2*c2*(t+e) + c1;
        float L = (t_max > t && t_max < t + e) ? max(df_max, max(df_1, df_2)) : max(df_1, df_2);
        L = max(L, EPS);
        float s = min((dist*d_inv)/L, e);
        t += s;
        e = k*s;
        dist = start_sign*m_pAccelStruct_eval_dist_trilinear(values, start_q + t * ray_dir);
        pp = start_q + t * ray_dir;
        iter++;
      }
      hit = (dist <= EPS);
     
    }
  }

  float tReal = fNearFar.x + d * t;


#if ON_CPU==1
  if (debug_cur_pixel)
  {
    printf("\n");
    printf("sdf type = %u\n", type);
    //printf("node bbox [(%f %f %f)-(%f %f %f)]\n", min_pos.x, min_pos.y, min_pos.z, max_pos.x, max_pos.y, max_pos.z);
    printf("sdf values %f %f %f %f %f %f %f %f\n", 
           values[0], values[1], values[2], values[3],
           values[4], values[5], values[6], values[7]);
    printf("t = %f in [0, %f], tReal = %f in [%f %f]\n",t,qFar,tReal,fNearFar.x,fNearFar.y);
    printf("ray_dir = (%f %f %f)\n", ray_dir.x, ray_dir.y, ray_dir.z);
    //printf("ray_pos = (%f %f %f)\n", ray_pos.x, ray_pos.y, ray_pos.z);
    printf("\n");
  }
#endif

  if (t <= qFar && hit && tReal < pHit.t)
  {
    vec3 norm = vec3(0,0,1);
    if (m_pAccelStruct_need_normal())
    {
      vec3 p0 = start_q + t * ray_dir;
      const float h = 0.001;
      float ddx = (m_pAccelStruct_eval_dist_trilinear(values, p0 + vec3(h,0,0)) -
                   m_pAccelStruct_eval_dist_trilinear(values, p0 + vec3(-h,0,0))) /
                  (2 * h);
      float ddy = (m_pAccelStruct_eval_dist_trilinear(values, p0 + vec3(0,h,0)) -
                   m_pAccelStruct_eval_dist_trilinear(values, p0 + vec3(0,-h,0))) /
                  (2 * h);
      float ddz = (m_pAccelStruct_eval_dist_trilinear(values, p0 + vec3(0,0,h)) -
                   m_pAccelStruct_eval_dist_trilinear(values, p0 + vec3(0,0,-h))) /
                  (2 * h);

      norm = start_sign*normalize(matmul4x3(m_pAccelStruct_m_instanceData[instId].transformInvTransposed, vec3(ddx,ddy,ddz)));
    }
    
    vec2 encoded_norm = m_pAccelStruct_encode_normal(norm);

    pHit.t = tReal;
    pHit.primId = primId;
    pHit.instId = instId;
    pHit.geomId = geomId | (type << SH_TYPE);
    pHit.coords[0] = 0;
    pHit.coords[1] = 0;
    pHit.coords[2] = encoded_norm.x;
    pHit.coords[3] = encoded_norm.y;

    if (ubo.m_pAccelStruct_m_preset.render_mode == MULTI_RENDER_MODE_ST_ITERATIONS)
      pHit.primId = iter;
    
  #ifndef DISABLE_SDF_FRAME_OCTREE_TEX
    if (type == TYPE_SDF_FRAME_OCTREE_TEX)
    {
      float3 dp = start_q + t * ray_dir;
      
      pHit->coords[0] = (1-dp.x)*(1-dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[0] + 
                        (1-dp.x)*(1-dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[2] + 
                        (1-dp.x)*(  dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[4] + 
                        (1-dp.x)*(  dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[6] + 
                        (  dp.x)*(1-dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[8] + 
                        (  dp.x)*(1-dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[10] + 
                        (  dp.x)*(  dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[12] + 
                        (  dp.x)*(  dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[14];

      pHit->coords[1] = (1-dp.x)*(1-dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[1] + 
                        (1-dp.x)*(1-dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[3] + 
                        (1-dp.x)*(  dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[5] + 
                        (1-dp.x)*(  dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[7] + 
                        (  dp.x)*(1-dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[9] + 
                        (  dp.x)*(1-dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[11] + 
                        (  dp.x)*(  dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[13] + 
                        (  dp.x)*(  dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[15];
    }
  #endif
  }
}

void m_pAccelStruct_OctreeIntersect(uint type, const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint a_start, uint a_count, inout CRT_Hit pHit) {
#ifndef DISABLE_SDF_COCTREE_V2
  vec3 pos_ray_pos = ray_pos;
  vec3 pos_ray_dir = ray_dir;
  //assume octree is box [-1,1]^3
  uint a = 0;
  if (ray_dir.x < 0)
  {
    pos_ray_pos.x *= -1;
    pos_ray_dir.x *= -1;
    a |= 4;
  }

  if (ray_dir.y < 0)
  {
    pos_ray_pos.y *= -1;
    pos_ray_dir.y *= -1;
    a |= 2;
  }

  if (ray_dir.z < 0)
  {
    pos_ray_pos.z *= -1;
    pos_ray_dir.z *= -1;
    a |= 1;
  }

  pos_ray_pos *= -1;
  const vec3 pos_ray_dir_inv = SafeInverse(pos_ray_dir);
  const vec3 _t0 = pos_ray_pos * pos_ray_dir_inv - pos_ray_dir_inv;
  const vec3 _t1 = pos_ray_pos * pos_ray_dir_inv + pos_ray_dir_inv;
  const vec3 _l = _t1 - _t0;
  //printf("_t0 %f %f %f\n", _t0.x, _t0.y, _t0.z);
  //printf("_t1 %f %f %f\n", _t1.x, _t1.y, _t1.z);

  const uvec3 nn_indices[8] = {uvec3(4,2,1), uvec3(5,3,8), uvec3(6,8,3), uvec3(7,8,8),
                               uvec3(8,6,5), uvec3(8,7,8), uvec3(8,8,7), uvec3(8,8,8)};

  OTStackElement stack[32];
  OTStackElement tmp_buf[4];

  int top = 0;
  int buf_top = 0;
  uvec3 p;
  vec3 p_f,  t0,  t1,  tm;
  int currNode;
  uint32_t nodeId;
  uint32_t level_sz;
  float d, qFar;
  vec2 fNearFar;
  vec3 start_q;
  float values[8];
  float old_t = pHit.t;

  stack[top].nodeId = 0;
  stack[top].info = 0;
  stack[top].p_size = uvec2(0,1);

    while (top >= 0)
    {
      level_sz = stack[top].p_size.y & 0xFFFF;
      p = uvec3(stack[top].p_size.x >> 16,stack[top].p_size.x & 0xFFFF,stack[top].p_size.y >> 16);
      d = 1.0f/float(level_sz);
      p_f = vec3(p);
      t0 = _t0 + d*p_f * _l;
      t1 = _t0 + d*(p_f + 1) * _l;

      //static int counter = 0;
      //if (counter < 100)
      //{
      //  printf("node %u, p = (%u %u %u) d = %f\n", stack[top].nodeId, p.x, p.y, p.z, d);
      //  counter++;
      //}

      if(stack[top].info > 0) //leaf node
      {
        float tmin = max(t0.x, max(t0.y, t0.z));
        float tmax = min(t1.x, min(t1.y, t1.z));

        {
          uint p_mask = level_sz - 1;
          uvec3 real_p = uvec3(((a & 4) > 0) ? (~p.x & p_mask) : p.x,((a & 2) > 0) ? (~p.y & p_mask) : p.y,((a & 1) > 0) ? (~p.z & p_mask) : p.z);

          nodeId = stack[top].nodeId;
          float sz = 0.5f*float(level_sz);
          d = 1.0f/sz;
          vec3 min_pos = vec3(-1,-1,-1) + d*vec3(real_p.x,real_p.y,real_p.z);

          fNearFar = vec2(tmin,tmax);
          vec3 start_pos = ray_pos + fNearFar.x*ray_dir;
          start_q = sz*(start_pos - min_pos);
          qFar = sz*(fNearFar.y - fNearFar.x);
        }

        float d_max = 2*1.73205081f/float(level_sz);
        for (int i=0;i<8;i++)
        {
          values[i] = -d_max + 2*d_max*(1.0/255.0f)*((m_pAccelStruct_m_SdfCompactOctreeV2Data[stack[top].nodeId + i/4] >> (8*(i%4))) & 0xFF);
        }
        //if (counter < 100)
        //{
        //  printf("values = %f %f %f %f %f %f %f %f\n", values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7]);
        //  counter++;
        //}
        
        m_pAccelStruct_LocalSurfaceIntersection(TYPE_SDF_FRAME_OCTREE, ray_dir, 0, 0, values, nodeId, nodeId, d, 0.0f, qFar, fNearFar, start_q, pHit); /*out*/

        if (pHit.t < old_t)
          top = -1;
        else
          top--;
      }
      else
      { 
        buf_top = 0;
        tm = 0.5f*(t0 + t1);

        currNode = first_node(t0, tm);
        do
        {
          //0-7 bits are child_is_active flags, next 8-15 bits are child_is_leaf flags
          uint childrenInfo = m_pAccelStruct_m_SdfCompactOctreeV2Data[stack[top].nodeId + 1];
          uint childNode = uint(currNode) ^ a; //child node number, from 0 to 8

          // if child is active
          if ((childrenInfo & (1u << childNode)) > 0)
          {
            uint currChildOffset = m_bitcount[childrenInfo & ((1u << childNode) - 1)]; //number of child in the list of active children
            uint baseChildrenOffset = m_pAccelStruct_m_SdfCompactOctreeV2Data[stack[top].nodeId];
            tmp_buf[buf_top].nodeId = baseChildrenOffset + 2u*currChildOffset;
            tmp_buf[buf_top].info = childrenInfo & (1u << (childNode + 8)); // > 0 is child is leaf
            tmp_buf[buf_top].p_size = (stack[top].p_size << 1) | uvec2(((currNode & 4) << (16-2)) | ((currNode & 2) >> 1),(currNode & 1) << 16);
            buf_top++;
          }
          //return (txm < tym) ? (txm < tzm ? x : z) : (tym < tzm ? y : z);
          currNode = new_node(((currNode & 4) > 0) ? t1.x : tm.x, int(nn_indices[currNode].x),
                              ((currNode & 2) > 0) ? t1.y : tm.y, int(nn_indices[currNode].y),
                              ((currNode & 1) > 0) ? t1.z : tm.z, int(nn_indices[currNode].z));
        } while (currNode<8);

        for (int i = 0; i < buf_top; i++)
        {
          stack[top+i] = tmp_buf[buf_top-i-1];
        }
        top += buf_top - 1;
      }
    }
#endif
}

uint extractMatId(uint a_flags) { return (a_flags & 0x00FFFFFF); }

void m_pAccelStruct_OctreeNodeIntersect(uint type, const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint a_start, uint a_count, inout CRT_Hit pHit) {
  float values[8];
  uint nodeId,  primId;
  float d, qNear, qFar;
  vec2 fNearFar;
  vec3 start_q;

  qNear = 1.0f;

  m_pAccelStruct_RayNodeIntersection(type, ray_pos, ray_dir, tNear, geomId, a_start, values, primId, nodeId, d, qNear, qFar, fNearFar, start_q); /*out*/

  //fast return if starting point in this exact node or type is not supported
  if (qNear > 0.0f) 
    return;
  
  m_pAccelStruct_LocalSurfaceIntersection(type, ray_dir, instId, geomId, values, nodeId, primId, d, qNear, qFar, fNearFar, start_q, pHit); /*out*/
}

void m_pAccelStruct_OctreeBrickIntersect(uint type, const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint bvhNodeId, uint a_count, inout CRT_Hit pHit) {
  #ifndef DISABLE_SDF_SBS
  float tricub_values[64], trilinear_values[8]; // values

  uint nodeId,  primId;
  float d, qNear, qFar;
  vec2 fNearFar;
  vec3 start_q;

  qNear = 1.0f;

  uint sdfId = m_pAccelStruct_m_geomData[geomId].offset.x;
  primId = bvhNodeId; //id of bbox in BLAS
  nodeId = primId + m_pAccelStruct_m_SdfSBSRoots[sdfId];
  SdfSBSHeader header = m_pAccelStruct_m_SdfSBSHeaders[sdfId];
  uint v_size = header.brick_size + 2*header.brick_pad + 1;

  float px = m_pAccelStruct_m_SdfSBSNodes[nodeId].pos_xy >> 16;
  float py = m_pAccelStruct_m_SdfSBSNodes[nodeId].pos_xy & 0x0000FFFF;
  float pz = m_pAccelStruct_m_SdfSBSNodes[nodeId].pos_z_lod_size >> 16;
  float sz = m_pAccelStruct_m_SdfSBSNodes[nodeId].pos_z_lod_size & 0x0000FFFF;
  float sz_inv = 2.0f/sz;
  
  d = 2.0f/(sz*float(header.brick_size));

  vec3 brick_min_pos = vec3(-1,-1,-1) + sz_inv*vec3(px,py,pz);
  vec3 brick_max_pos = brick_min_pos + sz_inv*vec3(1,1,1);
  vec3 brick_size = brick_max_pos - brick_min_pos;

  vec2 brick_fNearFar = RayBoxIntersection2(ray_pos, SafeInverse(ray_dir), brick_min_pos, brick_max_pos);
  float old_t = pHit.t;
  while (brick_fNearFar.x < brick_fNearFar.y && pHit.t == old_t)
  {
    vec3 hit_pos = ray_pos + brick_fNearFar.x*ray_dir;
    vec3 local_pos = (hit_pos - brick_min_pos) * (0.5f*sz*float(header.brick_size));
    vec3 voxelPos = floor(clamp(local_pos, 1e-6f, float(header.brick_size)-1e-6f));

    vec3 min_pos = brick_min_pos + d*voxelPos;
    vec3 max_pos = min_pos + d*vec3(1,1,1);
    vec3 size = max_pos - min_pos;

    float vmin = 0;

    if (ubo.m_pAccelStruct_m_preset.interpolation_mode == INTERPOLATION_MODE_TRILINEAR)
    {
      vmin = m_pAccelStruct_load_distance_values(nodeId, voxelPos, v_size, sz_inv, header, trilinear_values);
    }
    else
    {
      vmin = m_pAccelStruct_load_tricubic_distance_values(nodeId, voxelPos, v_size, sz_inv, header, tricub_values);
    }

    fNearFar = RayBoxIntersection2(ray_pos, SafeInverse(ray_dir), min_pos, max_pos);
    if (tNear < fNearFar.x && vmin <= 0.0f)    
    {
      vec3 start_pos = ray_pos + fNearFar.x*ray_dir;
      start_q = (start_pos - min_pos) * (0.5f*sz*float(header.brick_size));
      qFar = (fNearFar.y - fNearFar.x) * (0.5f*sz*float(header.brick_size));
    
      if (ubo.m_pAccelStruct_m_preset.interpolation_mode == INTERPOLATION_MODE_TRILINEAR)
      {
        m_pAccelStruct_LocalSurfaceIntersection(type, ray_dir, instId, geomId, trilinear_values, nodeId, primId, d, 0.0f, qFar, fNearFar, start_q, pHit); /*out*/
      }
      else
      {
        m_pAccelStruct_TricubicLocalSurfaceIntersection(type, ray_dir, instId, geomId, tricub_values, nodeId, primId, d, 0.0f, qFar, fNearFar, start_q, pHit);
      }
    
      if (ubo.m_pAccelStruct_m_preset.interpolation_mode == INTERPOLATION_MODE_TRILINEAR && header.aux_data == SDF_SBS_NODE_LAYOUT_ID32F_IRGB32F_IN &&
          ubo.m_pAccelStruct_m_preset.normal_mode == NORMAL_MODE_SDF_SMOOTHED && 
          m_pAccelStruct_need_normal() && pHit.t != old_t)
      {
        const float beta = 0.5f;
        vec3 dp = start_q + ((pHit.t - fNearFar.x)/d)*ray_dir; //linear interpolation coefficients in voxels

        vec3 normals[8];
        float values_n[8];
        for (int i=0;i<8;i++)
          normals[i] = vec3(0,0,0);
        
        vec3 nmq = vec3(0.5f,0.5f,0.5f);
        nmq.x = dp.x < 0.5f ? step(-beta, beta, dp.x) : step(-beta, beta, dp.x - 1.0f);
        nmq.y = dp.y < 0.5f ? step(-beta, beta, dp.y) : step(-beta, beta, dp.y - 1.0f);
        nmq.z = dp.z < 0.5f ? step(-beta, beta, dp.z) : step(-beta, beta, dp.z - 1.0f);

        ivec3 voxelPos0 = ivec3(dp.x < 0.5f ? voxelPos.x - 1 : voxelPos.x,dp.y < 0.5f ? voxelPos.y - 1 : voxelPos.y,dp.z < 0.5f ? voxelPos.z - 1 : voxelPos.z);
        for (int i=0;i<8;i++)
        {
          ivec3 VoxelPosI = voxelPos0 + ivec3((i & 4) >> 2,(i & 2) >> 1,i & 1);
          ivec3 BrickPosI = ivec3((VoxelPosI.x >= 0 ? (uint(VoxelPosI.x) < header.brick_size ? 0 : 1) : -1),(VoxelPosI.y >= 0 ? (uint(VoxelPosI.y) < header.brick_size ? 0 : 1) : -1),(VoxelPosI.z >= 0 ? (uint(VoxelPosI.z) < header.brick_size ? 0 : 1) : -1));

          uint neighborId = 0;
          neighborId += 3*3 * (BrickPosI.x + 1);
          neighborId +=   3 * (BrickPosI.y + 1);
          neighborId +=       (BrickPosI.z + 1);
          
          vec3 dVoxelPos = vec3(VoxelPosI) - voxelPos;
          uint32_t neighbor_nodeId;
          vec3 neighbor_voxelPos;

          if (neighborId == 9+3+1)//we have our neighbor voxel in the same brick
          {
            neighbor_nodeId = nodeId;
            neighbor_voxelPos = vec3(VoxelPosI);
          }
          else //we have our neighbor voxel in a different brick, read it from neigbors data
          {
            uint v_off = m_pAccelStruct_m_SdfSBSNodes[nodeId].data_offset;
            uint neighbors_data_offset = v_size*v_size*v_size + 8;

            neighbor_nodeId = m_pAccelStruct_m_SdfSBSData[v_off + neighbors_data_offset + neighborId];
            neighbor_voxelPos = vec3(VoxelPosI) - float(header.brick_size)*vec3(BrickPosI);
          }

          if (neighbor_nodeId != INVALID_IDX)
          {
            m_pAccelStruct_load_distance_values(neighbor_nodeId, neighbor_voxelPos, v_size, sz_inv, header, values_n);
            normals[i] = normalize(eval_dist_trilinear_diff(values_n, dp - dVoxelPos));
          }
        }

        vec3 smoothed_norm = (1-nmq.x)*(1-nmq.y)*(1-nmq.z)*normals[0] + 
                               (1-nmq.x)*(1-nmq.y)*(  nmq.z)*normals[1] + 
                               (1-nmq.x)*(  nmq.y)*(1-nmq.z)*normals[2] + 
                               (1-nmq.x)*(  nmq.y)*(  nmq.z)*normals[3] + 
                               (  nmq.x)*(1-nmq.y)*(1-nmq.z)*normals[4] + 
                               (  nmq.x)*(1-nmq.y)*(  nmq.z)*normals[5] + 
                               (  nmq.x)*(  nmq.y)*(1-nmq.z)*normals[6] + 
                               (  nmq.x)*(  nmq.y)*(  nmq.z)*normals[7];
        smoothed_norm = normalize(smoothed_norm);
        vec2 encoded_norm = m_pAccelStruct_encode_normal(smoothed_norm);

        pHit.coords[2] = encoded_norm.x;
        pHit.coords[3] = encoded_norm.y;
      }
    }
    
    brick_fNearFar.x += max(0.0f, fNearFar.y-brick_fNearFar.x) + 1e-6f;
  }
  
  //ray hit a brick
  if (pHit.t < old_t)
  {
    vec3 pos = ray_pos + pHit.t*ray_dir;
    vec3 dp = (pos - brick_min_pos)*(0.5f*sz);

    if (header.aux_data == SDF_SBS_NODE_LAYOUT_DX_UV16)
    {   
      uint vals_per_int = 4/header.bytes_per_value;
      uint t_off = m_pAccelStruct_m_SdfSBSNodes[nodeId].data_offset + (v_size*v_size*v_size+vals_per_int-1)/vals_per_int;

      pHit.coords[0] = (1-dp.x)*(1-dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+0] >> 16)) + 
                        (1-dp.x)*(1-dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+1] >> 16)) + 
                        (1-dp.x)*(  dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+2] >> 16)) + 
                        (1-dp.x)*(  dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+3] >> 16)) + 
                        (  dp.x)*(1-dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+4] >> 16)) + 
                        (  dp.x)*(1-dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+5] >> 16)) + 
                        (  dp.x)*(  dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+6] >> 16)) + 
                        (  dp.x)*(  dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+7] >> 16));

      pHit.coords[1] = (1-dp.x)*(1-dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+0] & 0xFFFF)) + 
                        (1-dp.x)*(1-dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+1] & 0xFFFF)) + 
                        (1-dp.x)*(  dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+2] & 0xFFFF)) + 
                        (1-dp.x)*(  dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+3] & 0xFFFF)) + 
                        (  dp.x)*(1-dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+4] & 0xFFFF)) + 
                        (  dp.x)*(1-dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+5] & 0xFFFF)) + 
                        (  dp.x)*(  dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+6] & 0xFFFF)) + 
                        (  dp.x)*(  dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfSBSData[t_off+7] & 0xFFFF));
    }
    else if (header.aux_data == SDF_SBS_NODE_LAYOUT_DX_RGB8)
    {
      uint vals_per_int = 4/header.bytes_per_value;
      uint t_off = m_pAccelStruct_m_SdfSBSNodes[nodeId].data_offset + (v_size*v_size*v_size+vals_per_int-1)/vals_per_int;

      vec3 color = (1-dp.x)*(1-dp.y)*(1-dp.z)*vec3((m_pAccelStruct_m_SdfSBSData[t_off+0] >> 0) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+0] >> 8) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+0] >> 16) & 0xFF) + 
                     (1-dp.x)*(1-dp.y)*(  dp.z)*vec3((m_pAccelStruct_m_SdfSBSData[t_off+1] >> 0) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+1] >> 8) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+1] >> 16) & 0xFF) + 
                     (1-dp.x)*(  dp.y)*(1-dp.z)*vec3((m_pAccelStruct_m_SdfSBSData[t_off+2] >> 0) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+2] >> 8) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+2] >> 16) & 0xFF) + 
                     (1-dp.x)*(  dp.y)*(  dp.z)*vec3((m_pAccelStruct_m_SdfSBSData[t_off+3] >> 0) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+3] >> 8) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+3] >> 16) & 0xFF) + 
                     (  dp.x)*(1-dp.y)*(1-dp.z)*vec3((m_pAccelStruct_m_SdfSBSData[t_off+4] >> 0) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+4] >> 8) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+4] >> 16) & 0xFF) + 
                     (  dp.x)*(1-dp.y)*(  dp.z)*vec3((m_pAccelStruct_m_SdfSBSData[t_off+5] >> 0) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+5] >> 8) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+5] >> 16) & 0xFF) + 
                     (  dp.x)*(  dp.y)*(1-dp.z)*vec3((m_pAccelStruct_m_SdfSBSData[t_off+6] >> 0) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+6] >> 8) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+6] >> 16) & 0xFF) + 
                     (  dp.x)*(  dp.y)*(  dp.z)*vec3((m_pAccelStruct_m_SdfSBSData[t_off+7] >> 0) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+7] >> 8) & 0xFF,(m_pAccelStruct_m_SdfSBSData[t_off+7] >> 16) & 0xFF);

      color = clamp(floor(color + 0.5f), 0.0f, 255.0f);

      pHit.coords[0] = color.x + color.y/256.0f;
      pHit.coords[1] = color.z;

      //printf("color = %f %f %f coords = %f %f\n", color.x, color.y, color.z, pHit->coords[0], pHit->coords[1]);
    }
    else if (header.aux_data == SDF_SBS_NODE_LAYOUT_ID32F_IRGB32F ||
             header.aux_data == SDF_SBS_NODE_LAYOUT_ID32F_IRGB32F_IN)
    {
      uint t_off = m_pAccelStruct_m_SdfSBSNodes[nodeId].data_offset + v_size*v_size*v_size;

      vec3 color = (1-dp.x)*(1-dp.y)*(1-dp.z)*vec3(m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+0]+0],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+0]+1],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+0]+2]) + 
                     (1-dp.x)*(1-dp.y)*(  dp.z)*vec3(m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+1]+0],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+1]+1],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+1]+2]) + 
                     (1-dp.x)*(  dp.y)*(1-dp.z)*vec3(m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+2]+0],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+2]+1],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+2]+2]) + 
                     (1-dp.x)*(  dp.y)*(  dp.z)*vec3(m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+3]+0],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+3]+1],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+3]+2]) + 
                     (  dp.x)*(1-dp.y)*(1-dp.z)*vec3(m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+4]+0],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+4]+1],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+4]+2]) + 
                     (  dp.x)*(1-dp.y)*(  dp.z)*vec3(m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+5]+0],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+5]+1],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+5]+2]) + 
                     (  dp.x)*(  dp.y)*(1-dp.z)*vec3(m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+6]+0],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+6]+1],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+6]+2]) + 
                     (  dp.x)*(  dp.y)*(  dp.z)*vec3(m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+7]+0],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+7]+1],m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[t_off+7]+2]);

      color = clamp(floor(255.0f*color + 0.5f), 0.0f, 255.0f);

      pHit.coords[0] = color.x + color.y/256.0f;
      pHit.coords[1] = color.z;
      //printf("color = %f %f %f coords = %f %f\n", color.x, color.y, color.z, pHit->coords[0], pHit->coords[1]);
    }
  }
#endif
}

vec2 m_pAccelStruct_encode_normal(vec3 v) {
  vec2 p = vec2(v.x,v.y) * (1.0f / (abs(v.x) + abs(v.y) + abs(v.z)));
  vec2 signNotZero = vec2((p.x >= 0.0f) ? +1.0f : -1.0f,(p.y >= 0.0f) ? +1.0f : -1.0f);
  return (v.z <= 0.0f) ? ((1.0f - abs(vec2(p.y,p.x))) * signNotZero) : p;
}

void RecordShadowHitIfNeeded(uint bounceId, bool inShadow) {}

vec2 m_pAccelStruct_box_intersects(in vec3 min_pos, in vec3 max_pos, in vec3 origin, in vec3 dir) {
  vec3 safe_dir = sign(dir) * max(vec3(1e-9f), abs(dir));
  vec3 tMin = (min_pos - origin) / safe_dir;
  vec3 tMax = (max_pos - origin) / safe_dir;
  vec3 t1 = min(tMin, tMax);
  vec3 t2 = max(tMin, tMax);
  float tNear = max(t1.x, max(t1.y, t1.z));
  float tFar = min(t2.x, min(t2.y, t2.z));

  return vec2(tNear,tFar);
}

bool isDeadRay(uint a_flags) { return (a_flags & RAY_FLAG_IS_DEAD)        != 0; }

float m_pAccelStruct_knot(uint i, int knots_offset) {
  return m_pAccelStruct_m_NURBSData[uint(knots_offset)+i];
}

void m_pAccelStruct_TricubicLocalSurfaceIntersection(uint type, const vec3 ray_dir, uint instId, uint geomId, inout float values[64], uint nodeId, uint primId, float d, float qNear, float qFar, vec2 fNearFar, vec3 start_q, inout CRT_Hit pHit) {
  const float EPS = 1e-6f;
  float d_inv = 1.0f / d;
  float t = qNear;
  bool hit = false;
  uint iter = 0;

  float start_dist = 10000;
  float start_sign = 1;

  float point[3] = {(start_q + t * ray_dir).x, (start_q + t * ray_dir).y, (start_q + t * ray_dir).z};
  start_dist = m_pAccelStruct_tricubicInterpolation(values, point);

  if (ubo.m_pAccelStruct_m_preset.representation_mode == REPRESENTATION_MODE_SURFACE)
    start_sign = sign(start_dist);
  start_dist *= start_sign;

  if (start_dist <= EPS || ubo.m_pAccelStruct_m_preset.sdf_node_intersect == SDF_OCTREE_NODE_INTERSECT_BBOX)
  {
    hit = true;
  }
  else if (ubo.m_pAccelStruct_m_preset.sdf_node_intersect == SDF_OCTREE_NODE_INTERSECT_ST)
  {
    const uint ST_max_iters = 256;
    float dist = start_dist;
    vec3 pp0 = start_q + t * ray_dir;

    while (t < qFar && dist > EPS && iter < ST_max_iters)
    {
      t += dist * d_inv;

      float point[3] = {(start_q + t * ray_dir).x, (start_q + t * ray_dir).y, (start_q + t * ray_dir).z};
      dist = m_pAccelStruct_tricubicInterpolation(values, point);
      
      vec3 pp = start_q + t * ray_dir;
      iter++;
    }
    hit = (dist <= EPS);
  }

  float tReal = fNearFar.x + d * t;

  if (t <= qFar && hit && tReal < pHit.t)
  {
    vec3 norm = vec3(0,0,1);
    if (m_pAccelStruct_need_normal())
    {
      vec3 p0 = start_q + t * ray_dir;
      const float h = 0.001;

      float p1[3] = {(p0 + vec3(h,0,0)).x, (p0).y, (p0).z};
      float p2[3] = {(p0 + vec3(-h,0,0)).x, p0.y, p0.z};
      
      float ddx = (m_pAccelStruct_tricubicInterpolation(values, p1) -
                   m_pAccelStruct_tricubicInterpolation(values, p2)) /
                  (2 * h);

      float p3[3] = {p0.x, (p0 + vec3(0,h,0)).y, p0.z};
      float p4[3] = {p0.x, (p0 + vec3(0,-h,0)).y, p0.z};
      float ddy = (m_pAccelStruct_tricubicInterpolation(values, p3) -
                   m_pAccelStruct_tricubicInterpolation(values, p4)) /
                  (2 * h);

      float p5[3] = {p0.x, p0.y, (p0 + vec3(0,0,h)).z};
      float p6[3] = {p0.x, p0.y, (p0 + vec3(0,0,-h)).z};

      float ddz = (m_pAccelStruct_tricubicInterpolation(values, p5) -
                   m_pAccelStruct_tricubicInterpolation(values, p6)) /
                  (2 * h);

      norm = start_sign * normalize(matmul4x3(m_pAccelStruct_m_instanceData[instId].transformInvTransposed, vec3(ddx,ddy,ddz)));
    }
    
    vec2 encoded_norm = m_pAccelStruct_encode_normal(norm);

    pHit.t = tReal;
    pHit.primId = primId;
    pHit.instId = instId;
    pHit.geomId = geomId | (type << SH_TYPE);
    pHit.coords[0] = 0;
    pHit.coords[1] = 0;
    pHit.coords[2] = encoded_norm.x;
    pHit.coords[3] = encoded_norm.y;

    if (ubo.m_pAccelStruct_m_preset.render_mode == MULTI_RENDER_MODE_ST_ITERATIONS)
      pHit.primId = iter;
    
  #ifndef DISABLE_SDF_FRAME_OCTREE_TEX
    if (type == TYPE_SDF_FRAME_OCTREE_TEX)
    {
      float3 dp = start_q + t * ray_dir;
      
      pHit->coords[0] = (1-dp.x)*(1-dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[0] + 
                        (1-dp.x)*(1-dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[2] + 
                        (1-dp.x)*(  dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[4] + 
                        (1-dp.x)*(  dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[6] + 
                        (  dp.x)*(1-dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[8] + 
                        (  dp.x)*(1-dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[10] + 
                        (  dp.x)*(  dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[12] + 
                        (  dp.x)*(  dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[14];

      pHit->coords[1] = (1-dp.x)*(1-dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[1] + 
                        (1-dp.x)*(1-dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[3] + 
                        (1-dp.x)*(  dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[5] + 
                        (1-dp.x)*(  dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[7] + 
                        (  dp.x)*(1-dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[9] + 
                        (  dp.x)*(1-dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[11] + 
                        (  dp.x)*(  dp.y)*(1-dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[13] + 
                        (  dp.x)*(  dp.y)*(  dp.z)*m_SdfFrameOctreeTexNodes[nodeId].tex_coords[15];
    }
  #endif
  }
}

vec4 GetRandomNumbersLgts(uint tid, inout RandomGen a_gen, int a_bounce) {
  const float  rndId = rndFloat1_Pseudo(a_gen); // don't use single rndFloat4 (!!!)
  const vec4 rands = rndFloat4_Pseudo(a_gen); // don't use single rndFloat4 (!!!)
  return vec4(rands.x,rands.y,rands.z,rndId);
}

vec4 m_pAccelStruct_control_point(uint i, int offset) {
  return vec4(m_pAccelStruct_m_NURBSData[uint(offset)+i*4+0],m_pAccelStruct_m_NURBSData[uint(offset)+i*4+1],m_pAccelStruct_m_NURBSData[uint(offset)+i*4+2],m_pAccelStruct_m_NURBSData[uint(offset)+i*4+3]);
}

MatIdWeightPair BlendEval(MatIdWeight a_mat, vec4 wavelengths, vec3 l, vec3 v, vec3 n, vec2 tc) {
  const vec2 texCoordT = mulRows2x4(m_materials[a_mat.id].row0[0], m_materials[a_mat.id].row1[0], tc);
  const uint   texId     = m_materials[a_mat.id].texid[0];
  const vec4 weightDat = texture(m_textures[texId], texCoordT);
  
  const float  weightTex = weightDat.x;
  const float  weight    = m_materials[a_mat.id].data[BLEND_WEIGHT] * weightTex;

  const uint matId1      = m_materials[a_mat.id].datai[0];
  const uint matId2      = m_materials[a_mat.id].datai[1];

  MatIdWeight p1, p2;
  p1.id     = matId1;
  p1.weight = a_mat.weight * (1.0f - weight);
  p2.id     = matId2;
  p2.weight = a_mat.weight * weight;

  return make_weight_pair(p1, p2);
}

CRT_Hit m_pAccelStruct_RayQuery_NearestHitMotion(vec4 posAndNear, vec4 dirAndFar, float time) { return m_pAccelStruct_RayQuery_NearestHit(posAndNear, dirAndFar); }

void m_pAccelStruct_IntersectRibbon(in vec3 ray_pos, in vec3 ray_dir, float tNear, uint instId, uint geomId, inout CRT_Hit pHit) {
#ifndef DISABLE_RIBBON
  // offset of ribbon object in headers array
  uint offset = m_pAccelStruct_m_geomData[geomId].offset.x;
  // object header
  RibbonHeader header = m_pAccelStruct_m_RibbonHeaders[offset];
  // object type <=> catmul_clark
  uint type = m_pAccelStruct_m_geomData[geomId].type;

  // you can access your box of entire object (this is not box of bvh leave)
  vec3 min_pos = m_pAccelStruct_m_geomData[geomId].boxMin.xyz;
  vec3 max_pos = m_pAccelStruct_m_geomData[geomId].boxMax.xyz;
  vec2 tNear_tFar = m_pAccelStruct_box_intersects(min_pos, max_pos, ray_pos, ray_dir);

  // you can pass bvh leave information to this function in GeomDataRibbon::Intersect 
  // ...

  vec3 norm = normalize(ray_pos + tNear_tFar.x * ray_dir);
  vec2 encoded_norm = m_pAccelStruct_encode_normal(norm); // compress 3dim normal vector to 2dim vector
  
  pHit.t = tNear_tFar.x;
  pHit.primId = 0;
  pHit.geomId = geomId | (type << SH_TYPE);
  pHit.instId = instId;
  pHit.coords[0] = 0; // u texture coordinate
  pHit.coords[1] = 0; // v texture coordinate
  pHit.coords[2] = encoded_norm.x;
  pHit.coords[3] = encoded_norm.y;
#endif
}

float m_pAccelStruct_load_distance_values(uint nodeId, vec3 voxelPos, uint v_size, float sz_inv, in SdfSBSHeader header, inout float values[8]) {
  float vmin = 1e6f;
#ifndef DISABLE_SDF_SBS
  if (header.aux_data == SDF_SBS_NODE_LAYOUT_ID32F_IRGB32F ||
      header.aux_data == SDF_SBS_NODE_LAYOUT_ID32F_IRGB32F_IN)
  {
    uint v_off = m_pAccelStruct_m_SdfSBSNodes[nodeId].data_offset;
    //  (000) (001) (010) (011) (100) (101) (110) (111)

    for (int i = 0; i < 8; i++)
    {
      uvec3 vPos = uvec3(voxelPos) + uvec3((i & 4) >> 2,(i & 2) >> 1,i & 1);
      uint vId = SBS_v_to_i(float(vPos.x), float(vPos.y), float(vPos.z), v_size, header.brick_pad);
      values[i] = m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[v_off + vId]];
      // printf("%f\n", values[i]);
      vmin = min(vmin, values[i]);
    }
  }
  else
  {
    uint v_off = m_pAccelStruct_m_SdfSBSNodes[nodeId].data_offset;
    uint vals_per_int = 4 / header.bytes_per_value;
    uint bits = 8 * header.bytes_per_value;
    uint max_val = header.bytes_per_value == 4 ? 0xFFFFFFFF : ((1 << bits) - 1);
    float d_max = 1.73205081f * sz_inv;
    float mult = 2 * d_max / float(max_val);
    for (int i = 0; i < 8; i++)
    {
      uvec3 vPos = uvec3(voxelPos) + uvec3((i & 4) >> 2,(i & 2) >> 1,i & 1);
      uint vId = SBS_v_to_i(float(vPos.x), float(vPos.y), float(vPos.z), v_size, header.brick_pad);;
      values[i] = -d_max + mult * ((m_pAccelStruct_m_SdfSBSData[v_off + vId / vals_per_int] >> (bits * (vId % vals_per_int))) & max_val);
      vmin = min(vmin, values[i]);
    }
  }
#endif
  return vmin;
}

void m_pAccelStruct_COctreeV3_BrickIntersect(uint type, const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, in COctreeV3Header header, uint brickOffset, vec3 p, float sz, uint transform_code_leaf_type, inout CRT_Hit pHit) {

#if ON_CPU==1
  assert(COctreeV3::VERSION == 5); //if version is changed, this function should be revisited, as some changes may be needed
#endif

#ifndef DISABLE_SDF_COCTREE_V3
  float values[8];

  float d, qNear, qFar;
  vec2 fNearFar;
  vec3 start_q;

  qNear = 1.0f;

  //uint32_t sdfId =  m_geomData[geomId].offset.x;

  uint v_size = header.brick_size + 2*header.brick_pad + 1;
  uint leaf_type = transform_code_leaf_type & COCTREE_LEAF_TYPE_MASK;
  uint transform_code = transform_code_leaf_type >> COCTREE_LEAF_TYPE_BITS;

  float sz_inv = 2.0f/sz;
  
  d = 2.0f/(sz*float(header.brick_size));

  vec3 brick_min_pos = vec3(-1,-1,-1) + sz_inv*p;
  vec3 brick_max_pos = brick_min_pos + sz_inv*vec3(1,1,1);
  vec3 brick_size = brick_max_pos - brick_min_pos;

  vec2 brick_fNearFar = RayBoxIntersection2(ray_pos, SafeInverse(ray_dir), brick_min_pos, brick_max_pos);
  brick_fNearFar.x = max(tNear, brick_fNearFar.x);
  float old_t = pHit.t;
  // if (ray_pos.x != 0.f || ray_pos.y != 0.f)
  //   printf("Pos: [%f, %f, %f]: brick_t: [%f, %f], t: %f\n", ray_pos.x, ray_pos.y, ray_pos.z, brick_fNearFar.x, brick_fNearFar.y, old_t);
  while (brick_fNearFar.x < brick_fNearFar.y && pHit.t == old_t)
  {
    vec3 hit_pos = ray_pos + brick_fNearFar.x*ray_dir;
    vec3 local_pos = (hit_pos - brick_min_pos) * (0.5f*sz*float(header.brick_size));
    vec3 voxelPos = floor(clamp(local_pos, 1e-6f, float(header.brick_size)-1e-6f));

    vec3 min_pos = brick_min_pos + d*voxelPos;
    vec3 max_pos = min_pos + d*vec3(1,1,1);
    vec3 size = max_pos - min_pos;

    float vmin = m_pAccelStruct_COctreeV3_LoadDistanceValues(leaf_type, brickOffset, voxelPos, v_size, sz_inv, header, transform_code, values);

    fNearFar = RayBoxIntersection2(ray_pos, SafeInverse(ray_dir), min_pos, max_pos);
    if (tNear < fNearFar.x && vmin <= 0.0f)    
    {
      vec3 start_pos = ray_pos + fNearFar.x*ray_dir;
      start_q = (start_pos - min_pos) * (0.5f*sz*float(header.brick_size));
      qFar = (fNearFar.y - fNearFar.x) * (0.5f*sz*float(header.brick_size));
    
      m_pAccelStruct_LocalSurfaceIntersection(type, ray_dir, instId, geomId, values, brickOffset, brickOffset, d, 0.0f, qFar, fNearFar, start_q, pHit); /*out*/
    
      if (ubo.m_pAccelStruct_m_preset.normal_mode == NORMAL_MODE_SDF_SMOOTHED && m_pAccelStruct_need_normal() && pHit.t < old_t)
      {
        const float beta = 0.5f;
        vec3 dp = start_q + ((pHit.t - fNearFar.x)/d)*ray_dir; //linear interpolation coefficients in voxels

        vec3 normals[8];
        float values_n[8];
        for (int i=0;i<8;i++)
          normals[i] = vec3(0,0,0);
        
        vec3 nmq = vec3(0.5f,0.5f,0.5f);
        nmq.x = dp.x < 0.5f ? step(-beta, beta, dp.x) : step(-beta, beta, dp.x - 1.0f);
        nmq.y = dp.y < 0.5f ? step(-beta, beta, dp.y) : step(-beta, beta, dp.y - 1.0f);
        nmq.z = dp.z < 0.5f ? step(-beta, beta, dp.z) : step(-beta, beta, dp.z - 1.0f);

        ivec3 voxelPos0 = ivec3(dp.x < 0.5f ? voxelPos.x - 1 : voxelPos.x,dp.y < 0.5f ? voxelPos.y - 1 : voxelPos.y,dp.z < 0.5f ? voxelPos.z - 1 : voxelPos.z);
        for (int i=0;i<8;i++)
        {
          ivec3 VoxelPosI = voxelPos0 + ivec3((i & 4) >> 2,(i & 2) >> 1,i & 1);
          vec3 dVoxelPos = vec3(VoxelPosI) - voxelPos;

          float vmin_n = m_pAccelStruct_COctreeV3_LoadDistanceValues(leaf_type, brickOffset, vec3(VoxelPosI), v_size, sz_inv, header, transform_code, values_n);
          if (vmin_n <= 0.0f)
            normals[i] = normalize(eval_dist_trilinear_diff(values_n, dp - dVoxelPos));
        }

        vec3 smoothed_norm = (1-nmq.x)*(1-nmq.y)*(1-nmq.z)*normals[0] + 
                               (1-nmq.x)*(1-nmq.y)*(  nmq.z)*normals[1] + 
                               (1-nmq.x)*(  nmq.y)*(1-nmq.z)*normals[2] + 
                               (1-nmq.x)*(  nmq.y)*(  nmq.z)*normals[3] + 
                               (  nmq.x)*(1-nmq.y)*(1-nmq.z)*normals[4] + 
                               (  nmq.x)*(1-nmq.y)*(  nmq.z)*normals[5] + 
                               (  nmq.x)*(  nmq.y)*(1-nmq.z)*normals[6] + 
                               (  nmq.x)*(  nmq.y)*(  nmq.z)*normals[7];
        smoothed_norm = normalize(matmul4x3(m_pAccelStruct_m_instanceData[instId].transformInvTransposed, smoothed_norm));
        vec2 encoded_norm = m_pAccelStruct_encode_normal(smoothed_norm);

        pHit.coords[2] = encoded_norm.x;
        pHit.coords[3] = encoded_norm.y;
      }
    }
    
    brick_fNearFar.x += max(0.0f, fNearFar.y-brick_fNearFar.x) + 1e-6f;
  }
  
  //ray hit a brick
  if (pHit.t < old_t && header.uv_size > 0)
  {
    uint p_size = header.brick_size + 2 * header.brick_pad;
  
    //this voxel is guaranteed to have surface
    const uint line_distances_offset_bits = 16;
    const uint line_distances_offsets_per_uint = 32 / line_distances_offset_bits;

    uint slice_distance_flags_bits = v_size * v_size;
    uint slice_distance_flags_uints = (slice_distance_flags_bits + 32 - 1) / 32;
    uint distance_flags_size_uints = v_size * slice_distance_flags_uints;
    uint presence_flags_size_uints = (p_size * p_size * p_size + 32 - 1) / 32;
    uint distance_offsets_size_uints = (v_size + line_distances_offsets_per_uint - 1) / line_distances_offsets_per_uint; // 16 bits for offset, should be enough for all cases

    const uint min_range_size_uints = 2;

    //<presence_flags><distance_flags><distance_offsets><min value and range><distances>
    uint off_0 = 0;                                   // presence flags
    uint off_1 = off_0 + presence_flags_size_uints;   // distance flags
    uint off_2 = off_1 + distance_flags_size_uints;   // distance offsets
    uint off_3 = off_2 + distance_offsets_size_uints; // min value and range
    uint off_4 = off_3 + min_range_size_uints;        // texture coordinates
    uint off_5 = off_4 + 8 * header.uv_size;          // distances

    vec3 pos = ray_pos + pHit.t*ray_dir;
    vec3 dp = (pos - brick_min_pos)*(0.5f*sz);

      pHit.coords[0] = (1-dp.x)*(1-dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 0] >> 16)) + 
                        (1-dp.x)*(1-dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 1] >> 16)) + 
                        (1-dp.x)*(  dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 2] >> 16)) + 
                        (1-dp.x)*(  dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 3] >> 16)) + 
                        (  dp.x)*(1-dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 4] >> 16)) + 
                        (  dp.x)*(1-dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 5] >> 16)) + 
                        (  dp.x)*(  dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 6] >> 16)) + 
                        (  dp.x)*(  dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 7] >> 16));

      pHit.coords[1] = (1-dp.x)*(1-dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 0] & 0xFFFF)) + 
                        (1-dp.x)*(1-dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 1] & 0xFFFF)) + 
                        (1-dp.x)*(  dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 2] & 0xFFFF)) + 
                        (1-dp.x)*(  dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 3] & 0xFFFF)) + 
                        (  dp.x)*(1-dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 4] & 0xFFFF)) + 
                        (  dp.x)*(1-dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 5] & 0xFFFF)) + 
                        (  dp.x)*(  dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 6] & 0xFFFF)) + 
                        (  dp.x)*(  dp.y)*(  dp.z)*(1.5259022e-5f*float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_4 + 7] & 0xFFFF));

  }
#endif
}

uint m_pAccelStruct_eval_distance_traverse_bvh(uint geomId, vec3 pos) {
  const uint bvhOffset = m_pAccelStruct_m_geomData[geomId].bvhOffset;

  uint32_t stack[STACK_SIZE];
  int top = 0;
  uint leftNodeOffset = 0;

  while (top >= 0)
  {
#ifndef DISABLE_RF_GRID
    // if (m_RFGridFlags.size() > 0 && pHit->coords[0] <= 0.01f)
    //   break;
#endif

    while (top >= 0 && ((leftNodeOffset & LEAF_BIT) == 0))
    {
      const BVHNodePair fatNode = m_pAccelStruct_m_allNodePairs[bvhOffset + leftNodeOffset];
      const uint node0_leftOffset = fatNode.left.leftOffset;
      const uint node1_leftOffset = fatNode.right.leftOffset;

      const bool hitChild0 = (pos.x >= fatNode.left.boxMin.x) && (pos.x <= fatNode.left.boxMax.x) &&
                             (pos.y >= fatNode.left.boxMin.y) && (pos.y <= fatNode.left.boxMax.y) &&
                             (pos.z >= fatNode.left.boxMin.z) && (pos.z <= fatNode.left.boxMax.z);
      const bool hitChild1 = (pos.x >= fatNode.right.boxMin.x) && (pos.x <= fatNode.right.boxMax.x) &&
                             (pos.y >= fatNode.right.boxMin.y) && (pos.y <= fatNode.right.boxMax.y) &&
                             (pos.z >= fatNode.right.boxMin.z) && (pos.z <= fatNode.right.boxMax.z);

      // traversal decision
      if (hitChild0 && hitChild1)
      {
        leftNodeOffset = node0_leftOffset;
        stack[top]     = node1_leftOffset;
        top++;
      }
      else if (!hitChild0 && !hitChild1) // both miss, stack.pop()
      {
        leftNodeOffset = -1;
        if (--top >= 0)
          leftNodeOffset = stack[top];
      }
      else
      {
        leftNodeOffset = hitChild0 ? node0_leftOffset : node1_leftOffset;
      }

    } // end while (searchingForLeaf)

    // leaf node, intersect triangles
    if (top >= 0 && leftNodeOffset != 0xFFFFFFFF)
    {
      return leftNodeOffset;
    }

    // continue BVH traversal
    leftNodeOffset = -1;
    if (--top >= 0)
      leftNodeOffset = stack[top];
  } // end while (top >= 0)
  return leftNodeOffset;
}

vec4 m_pAccelStruct_rbezier_curve_der(float u, int p, int offset) {
  if (p == 1) {
    vec4 cur_pnt = m_pAccelStruct_control_point(0, offset);
    vec4 next_pnt = m_pAccelStruct_control_point(1, offset);
    vec4 res = (next_pnt-cur_pnt) * float(p);
    return res;
  }

  float u_n = 1.0f;
  float _1_u = 1.0f - u;
  int bc = 1;

  vec4 cur_pnt = m_pAccelStruct_control_point(0, offset);
  vec4 next_pnt = m_pAccelStruct_control_point(1, offset);
  vec4 res = (next_pnt-cur_pnt) * _1_u;
  cur_pnt = next_pnt;

  for (int i = 1; i <= p-2; ++i) {
    u_n *= u;
    bc = bc * (p-i)/i;
    next_pnt = m_pAccelStruct_control_point(i+1, offset);
    res = (res + u_n * float(bc) * (next_pnt-cur_pnt)) * _1_u;
    cur_pnt = next_pnt;
  }

  next_pnt = m_pAccelStruct_control_point(p, offset);
  res += (u_n * u) * (next_pnt-cur_pnt);

  res *= float(p);

  return res;
}

BsdfSample MaterialSampleAndEval(uint a_materialId, uint tid, uint bounce, vec4 wavelengths, inout RandomGen a_gen, vec3 v, vec3 n, vec3 tan, vec2 tc, inout MisData a_misPrev, const uint a_currRayFlags) {
  BsdfSample res;
  {
    res.val   = vec4(0,0,0,0);
    res.pdf   = 1.0f;
    res.dir   = vec3(0,1,0);
    res.ior   = 1.0f;
    res.flags = a_currRayFlags;
    res.ior   = 1.0f;
  }

  uint currMatId = a_materialId;
  uint     mtype     = m_materials[currMatId].mtype;
  uint     layer     = 0;
  while(KSPEC_MAT_TYPE_BLEND != 0 && mtype == MAT_TYPE_BLEND)
  {
    currMatId = BlendSampleAndEval(currMatId, tid, bounce, layer, wavelengths, a_gen, v, n, tc, a_misPrev, res);
    mtype     = m_materials[currMatId].mtype;
    layer++;
  }
  
  // BSDF is multiplied (outside) by cosThetaOut1.
  // When normal map is enables this becames wrong because normal is changed;
  // First : return cosThetaOut in sam;
  // Second: apply cos(theta2)/cos(theta1) to cos(theta1) to get cos(theta2)
  //
  const uint normalMapId   = m_materials[currMatId].texid[1];
  const vec3 geomNormal = n;
        vec3 shadeNormal = n;

  if(KSPEC_BUMP_MAPPING != 0 && normalMapId != 0xFFFFFFFF)
    shadeNormal = BumpMapping(normalMapId, currMatId, geomNormal, tan, tc);

  const vec2 texCoordT = mulRows2x4(m_materials[currMatId].row0[0], m_materials[currMatId].row1[0], tc);
  const uint   texId     = m_materials[currMatId].texid[0];
  const vec4 texColor = texture(m_textures[texId], texCoordT);
  const vec4 rands = GetRandomNumbersMats(tid, a_gen, int(bounce));
  const uint cflags      = m_materials[currMatId].cflags;
  RecordMatRndNeeded(bounce, rands);

  vec4 fourScalarMatParams = vec4(1,1,1,1);
  if(KSPEC_MAT_FOUR_TEXTURES != 0 && (cflags & FLAG_FOUR_TEXTURES) != 0)
  {
    const uint texId2  = m_materials[currMatId].texid[2];
    const uint texId3  = m_materials[currMatId].texid[3];
    
    const vec2 texCoord2T = mulRows2x4(m_materials[currMatId].row0[2], m_materials[currMatId].row1[2], tc);
    const vec2 texCoord3T = mulRows2x4(m_materials[currMatId].row0[3], m_materials[currMatId].row1[3], tc);

    const vec4 color2 = texture(m_textures[texId2], texCoord2T);
    const vec4 color3 = texture(m_textures[texId3], texCoord3T);
    
    if((cflags & FLAG_PACK_FOUR_PARAMS_IN_TEXTURE) != 0)
      fourScalarMatParams = color2;
    else
      fourScalarMatParams = vec4(color2.x,color3.x,1,1);
  }

  switch(mtype)
  {
    case MAT_TYPE_GLTF:
    if(KSPEC_MAT_TYPE_GLTF != 0)
    {
      const vec4 color = m_materials[currMatId].colors[GLTF_COLOR_BASE]*texColor;
      gltfSampleAndEval_m_materials(currMatId, rands, v, shadeNormal, tc, color, fourScalarMatParams, res);
    }
    break;
    case MAT_TYPE_GLASS: 
    if(KSPEC_MAT_TYPE_GLASS != 0)
    {
      glassSampleAndEval_m_materials(currMatId, rands, v, geomNormal, tc, res, a_misPrev);
    }
    break;
    case MAT_TYPE_CONDUCTOR:
    if(KSPEC_MAT_TYPE_CONDUCTOR != 0)
    {
      const vec3 alphaTex = texColor.xyz;    
      const vec2 alpha = vec2(m_materials[currMatId].data[CONDUCTOR_ROUGH_V],m_materials[currMatId].data[CONDUCTOR_ROUGH_U]);
      const vec4 etaSpec = SampleMatParamSpectrum(currMatId, wavelengths, CONDUCTOR_ETA, 0);
      const vec4 kSpec = SampleMatParamSpectrum(currMatId, wavelengths, CONDUCTOR_K,   1);
      if(trEffectivelySmooth(alpha))
        conductorSmoothSampleAndEval_m_materials(currMatId, etaSpec, kSpec, rands, v, shadeNormal, tc, res);
      else
        conductorRoughSampleAndEval_m_materials(currMatId, etaSpec, kSpec, rands, v, shadeNormal, tc, alphaTex, res);
    }
    break;
    case MAT_TYPE_THIN_FILM:
    if(KSPEC_MAT_TYPE_THIN_FILM != 0)
    {
      const vec3 alphaTex = texColor.xyz;  
      const vec2 alpha = vec2(m_materials[currMatId].data[FILM_ROUGH_V],m_materials[currMatId].data[FILM_ROUGH_U]);

      uint t_offset = floatBitsToUint(m_materials[currMatId].data[FILM_THICKNESS_OFFSET]);
      uint layers = floatBitsToUint(m_materials[currMatId].data[FILM_LAYERS_COUNT]);
      const bool spectral_mode = wavelengths[0] > 0.0f;
      // sampling 3 wavelengths for naive RGB method
      vec4 wavelengths_spec = spectral_mode? vec4(wavelengths[0],0.0f,0.0f,0.0f) : vec4(645.f,525.f,445.f,0.0f);
      vec4 wavelengths_sample = spectral_mode? vec4(wavelengths[0],0.0f,0.0f,0.0f) : vec4(525.f,0.f,0.f,0.0f);
      float extIOR = m_materials[currMatId].data[FILM_ETA_EXT];
      complex intIOR = make_complex(SampleFilmsSpectrum(currMatId, wavelengths_sample, FILM_ETA_OFFSET, FILM_ETA_SPECID_OFFSET, layers - 1)[0],SampleFilmsSpectrum(currMatId, wavelengths_sample, FILM_K_OFFSET, FILM_K_SPECID_OFFSET, layers - 1)[0]);
      complex filmIOR = make_complex(SampleFilmsSpectrum(currMatId, wavelengths, FILM_ETA_OFFSET, FILM_ETA_SPECID_OFFSET, 0)[0],SampleFilmsSpectrum(currMatId, wavelengths, FILM_K_OFFSET, FILM_K_SPECID_OFFSET, 0)[0]);

      float thickness;
      if (floatBitsToUint(m_materials[currMatId].data[FILM_THICKNESS_MAP]) > 0u)
      {
        const uint texId  = m_materials[currMatId].texid[2];
        const vec2 texCoord = mulRows2x4(m_materials[currMatId].row0[2], m_materials[currMatId].row1[2], tc);
        const vec4 thickness_val = texture(m_textures[texId], texCoord);
        float thickness_max = m_materials[currMatId].data[FILM_THICKNESS_MAX];
        float thickness_min = m_materials[currMatId].data[FILM_THICKNESS_MIN];
        thickness = (thickness_max - thickness_min) * thickness_val.x + thickness_min;
        //std::cout << fourScalarMatParams.x << " " << fourScalarMatParams.y << " " << fourScalarMatParams.z << " " << fourScalarMatParams.w << std::endl;
      }
      else
      {
        thickness = m_materials[currMatId].data[FILM_THICKNESS];
      }

      bool precomp_flag = floatBitsToUint(m_materials[currMatId].data[FILM_PRECOMP_FLAG]) > 0u;

      uint precomp_offset = precomp_flag ? floatBitsToUint(m_materials[currMatId].data[FILM_PRECOMP_OFFSET]) : 0;
      if(trEffectivelySmooth(alpha))
        filmSmoothSampleAndEval_m_materials_m_precomp_thin_films(currMatId, extIOR, filmIOR, intIOR, thickness, wavelengths_spec, a_misPrev.ior, rands, v, n, tc, res, precomp_offset, spectral_mode, precomp_flag);
      else
        filmRoughSampleAndEval_m_materials_m_precomp_thin_films(currMatId, extIOR, filmIOR, intIOR, thickness, wavelengths_spec, a_misPrev.ior, rands, v, n, tc, alphaTex, res, precomp_offset, spectral_mode, precomp_flag);

      //res.flags |= (specId < 0xFFFFFFFF) ? RAY_FLAG_WAVES_DIVERGED : 0;
      res.flags |= RAY_FLAG_WAVES_DIVERGED;

      a_misPrev.ior = res.ior;
    }
    break;
    case MAT_TYPE_DIFFUSE:
    if(KSPEC_MAT_TYPE_DIFFUSE != 0)
    {
      const vec4 color = texColor;
      vec4 reflSpec = SampleMatColorSpectrumTexture(currMatId, wavelengths, DIFFUSE_COLOR, 0, tc);
      if(ubo.m_spectral_mode == 0)
        reflSpec *= color;
      
      diffuseSampleAndEval_m_materials(currMatId, reflSpec, rands, v, shadeNormal, tc, res);
    }
    break;
    case MAT_TYPE_PLASTIC:
    if(KSPEC_MAT_TYPE_PLASTIC != 0)
    {
      const vec4 color = texColor;
      vec4 reflSpec = SampleMatColorSpectrumTexture(currMatId, wavelengths, PLASTIC_COLOR, 0, tc);
      // float4 reflSpec    = SampleMatColorParamSpectrum(currMatId, wavelengths, PLASTIC_COLOR, 0);
      if(ubo.m_spectral_mode == 0)
        reflSpec *= color;

      const uint precomp_id = m_materials[currMatId].datai[0];

      plasticSampleAndEval_m_materials_m_precomp_coat_transmittance(currMatId, reflSpec, rands, v, shadeNormal, tc, res, precomp_id * MI_ROUGH_TRANSMITTANCE_RES);
    }
    break;
    case MAT_TYPE_DIELECTRIC:
    if(KSPEC_MAT_TYPE_DIELECTRIC != 0)
    {
      const vec4 intIORSpec = SampleMatParamSpectrum(currMatId, wavelengths, DIELECTRIC_ETA_INT, 0);
      const uint specId = m_materials[currMatId].spdid[0];
      dielectricSmoothSampleAndEval_m_materials(currMatId, intIORSpec, a_misPrev.ior, rands, v, shadeNormal, tc, res);

      res.flags |= (specId < 0xFFFFFFFF) ? RAY_FLAG_WAVES_DIVERGED : 0;

      a_misPrev.ior = res.ior;
    }
    break;
    default:
    break;
  }
  
  // BSDF is multiplied (outside) by cosThetaOut1.
  // When normal map is enables this becames wrong because normal is changed;
  // First : return cosThetaOut in sam;
  // Second: apply cos(theta2)/cos(theta1) to cos(theta1) to get cos(theta2)
  //
  if(KSPEC_BUMP_MAPPING != 0 && normalMapId != 0xFFFFFFFF)
  {
    const float cosThetaOut1 = abs(dot(res.dir, geomNormal));
    const float cosThetaOut2 = abs(dot(res.dir, shadeNormal));
    res.val *= cosThetaOut2 / max(cosThetaOut1, 1e-10f);
  }

  return res;
}

vec4 m_pAccelStruct_rbezier_curve_point(float u, int p, int offset) {
  float u_n = 1.0f;
  float _1_u = 1.0f - u;
  int bc = 1;
  vec4 res = m_pAccelStruct_control_point(0, offset) * _1_u;
  for (int i = 1; i <= p-1; ++i) {
    u_n *= u;
    bc = bc * (p-i+1)/i;
    res = (res + u_n * float(bc) * m_pAccelStruct_control_point(i, offset)) * _1_u;
  }
  res += (u_n * u) * m_pAccelStruct_control_point(p, offset);
  return res;
}

void m_pAccelStruct_IntersectGraphicPrims(in vec3 ray_pos, in vec3 ray_dir, float tNear, uint instId, uint geomId, uint a_start, uint a_count, inout CRT_Hit pHit) {
#ifndef DISABLE_GRAPHICS_PRIM

  const float EPS = 1e-5f, T_MAX = 1e15f;
  uint32_t primId     = m_geomData[geomId].offset.x;
  uint32_t nextPrimId = m_geomData[geomId].offset.y;
  GraphicsPrimHeader header = m_GraphicsPrimHeaders[primId];
  float3 color = header.color;

  uint32_t prim_len = 2u;
  if (header.prim_type == GRAPH_PRIM_POINT)
    prim_len = 1u;
  if (header.prim_type >= GRAPH_PRIM_LINE_COLOR)
    prim_len = 3u;
  
  uint32_t start_index = primId + prim_len * a_start;
  uint32_t end_index = start_index + prim_len; // 1 per bbox
  // start_index = primId;
  // end_index = nextPrimId;

  bool has_custom_color = header.prim_type >= GRAPH_PRIM_POINT_COLOR;

  if (header.prim_type == GRAPH_PRIM_POINT ||
      header.prim_type == GRAPH_PRIM_POINT_COLOR)
  {
    for (uint32_t i = start_index; i < end_index; i += prim_len)
    {
      float4 point = m_GraphicsPrimPoints[i];
      if (has_custom_color)
        color = to_float3(m_GraphicsPrimPoints[i+1]);

      float3 point3 = float3(point.x, point.y, point.z);
      float pt_radius = point.w;
      float3 pos_minus_point3 = ray_pos - point3;

      float b = 2.f * dot(ray_dir, pos_minus_point3);
      float c = dot(pos_minus_point3, pos_minus_point3) - pt_radius * pt_radius;
      float D = b*b - 4*c;
      if (D >= EPS)
      {
        D = std::sqrt(D);
        float t = -(b + D) * 0.5f;
        if (t < EPS)
          t = (-b + D) * 0.5f;

        if (t > tNear && t < pHit->t)
        {
          float3 norm = normalize((ray_pos + t*ray_dir - point3) * 100.f);
          float2 encoded_norm = encode_normal(norm);

          pHit->t         = t;
          pHit->primId    = primId;
          pHit->instId    = instId;
          pHit->geomId    = geomId | (TYPE_GRAPHICS_PRIM << SH_TYPE);
          pHit->coords[0] = color.x + color.y/256.0f;
          pHit->coords[1] = color.z;
          pHit->coords[2] = encoded_norm.x;
          pHit->coords[3] = encoded_norm.y;
        }
      }
    }
  }
  else
  {
    for (uint32_t i = start_index; i < end_index; i += prim_len)
    {
      float4 point1 = m_GraphicsPrimPoints[i  ];
      float4 point2 = m_GraphicsPrimPoints[i+1];
      if (has_custom_color)
        color = to_float3(m_GraphicsPrimPoints[i+2]);

      float3 point1_3 = float3(point1.x, point1.y, point1.z);
      float3 point2_3 = float3(point2.x, point2.y, point2.z);
      if (header.prim_type == GRAPH_PRIM_LINE_SEGMENT_DIR ||
          header.prim_type == GRAPH_PRIM_LINE_SEGMENT_DIR_COLOR)
        point2_3 = point2_3 * 0.71f + point1_3 * 0.29f; // so that the line segment doesn't clip through the cone
      float ra = point1.w; // line (cylinder) radius

      //assert(ra > EPS);

      float t = T_MAX;
      float3 norm = float3(0.f, 0.f, 0.f);

      if (header.prim_type == GRAPH_PRIM_LINE ||
          header.prim_type == GRAPH_PRIM_LINE_SEGMENT ||
          header.prim_type == GRAPH_PRIM_LINE_SEGMENT_DIR ||
          header.prim_type == GRAPH_PRIM_LINE_COLOR ||
          header.prim_type == GRAPH_PRIM_LINE_SEGMENT_COLOR ||
          header.prim_type == GRAPH_PRIM_LINE_SEGMENT_DIR_COLOR)
      {
        float3 oc =  ray_pos - point1_3;
        float3 ba = point2_3 - point1_3;

        float baba = dot(ba, ba);
        float bard = dot(ba, ray_dir);
        float baoc = dot(ba, oc);

        float k2 = baba - (bard * bard);
        float k1 = baba*dot(oc, ray_dir) - baoc*bard;
        float k0 = baba*dot(oc, oc) - baoc*baoc - ra*ra*baba;

        float D = k1*k1 - k2*k0;

        if (D > 0.f)
        {
          float dist = -(k1 + std::sqrt(D)) / k2;
          float y = baoc + dist*bard;

          if (header.prim_type == GRAPH_PRIM_LINE || (y > 0.f && y < baba))
          {
            t = dist;
            norm = normalize(oc+t*ray_dir - ba*y/baba);
          }
          else
          {
            dist = ((y < 0.f ? 0.f : baba) - baoc)/bard;
            if (std::abs(k1+k2*dist)<std::sqrt(D))
            {
              t = dist;
              norm = normalize(ba*sign(y));
            }
          }
        }
      }
      if (header.prim_type == GRAPH_PRIM_LINE_SEGMENT_DIR ||
          header.prim_type == GRAPH_PRIM_LINE_SEGMENT_DIR_COLOR)
      {
        ra = length(point2_3 - point1_3) * 0.15f;
        point2_3 = float3(point2.x, point2.y, point2.z);
        float3 pa = point2_3 * 0.7f + point1_3 * 0.3f; // cone length along line segment is 0.3*length(b - a) for now
        float3 ba = point2_3 - pa;
        float3 oa = ray_pos - pa;
        float3 ob = ray_pos - point2_3;
        float  m0 = dot(ba,ba);
        float  m1 = dot(oa,ba);
        float  m2 = dot(ray_dir,ba);
        float  m3 = dot(ray_dir,oa);
        float  m5 = dot(oa,oa);
        float  m9 = dot(ob,ba);

        // cap - only one
        if(m1 < 0.f)
        {
          float3 tmp1 = oa * m2 - ray_dir * m1;
          if(dot(tmp1, tmp1) < (ra*ra*m2*m2))
          {
            t = -m1/m2;
            norm = normalize(-1.0f*ba);
          }
        }
        
        // body
        float rr = ra;
        float hy = m0 + rr*rr;
        float k2 = m0*m0    - m2*m2*hy;
        float k1 = m0*m0*m3 - m1*m2*hy + m0*ra*(rr*m2);
        float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);

        float D = k1*k1 - k2*k0;
        if(D > 0.f)
        {
          float dist = -(k1 + std::sqrt(D)) / k2;
          float y = m1 + dist * m2;
          if(y >= 0.f && y <= m0)
          {
            t = dist;
            norm = normalize(m0*(m0*(oa+t*ray_dir)+rr*ba*ra)-ba*hy*y);
          }
        }
      }
      if (header.prim_type == GRAPH_PRIM_BOX ||
          header.prim_type == GRAPH_PRIM_BOX_COLOR)
      {
        float3 pa = min(point2_3, point1_3);
        float3 pb = max(point2_3, point1_3);
        float minmax[3][2] = {{pa.x, pb.x}, {pa.y, pb.y}, {pa.z, pb.z}};

        const int4 vert_indices{0,3,5,6};
        for (int vert_ind = 0; vert_ind < 4; ++vert_ind)
        {
          int axis_indices[3] = { int((vert_indices[vert_ind] & 4u) != 0),
                                  int((vert_indices[vert_ind] & 2u) != 0),
                                  int((vert_indices[vert_ind] & 1u) != 0) };
          pa = float3(minmax[0][axis_indices[0]],
                      minmax[1][axis_indices[1]],
                      minmax[2][axis_indices[2]]);
          for (int axis = 0; axis < 3; ++axis)
          {
            pb = pa;
            pb[axis] = minmax[axis][1-axis_indices[axis]];
            float4 norm_dist = rayCapsuleIntersect(ray_pos, ray_dir, pa, pb, ra);
            if (norm_dist.w < t)
            {
              t = norm_dist.w;
              norm = to_float3(norm_dist);
            }
          }
        }
      }

      if (t > tNear && t < pHit->t)
      {
        float2 encoded_norm = encode_normal(norm);

        pHit->t         = t;
        pHit->primId    = primId;
        pHit->instId    = instId;
        pHit->geomId    = geomId | (TYPE_GRAPHICS_PRIM << SH_TYPE);
        pHit->coords[0] = color.x + color.y/256.0f;
        pHit->coords[1] = color.z;
        pHit->coords[2] = encoded_norm.x;
        pHit->coords[3] = encoded_norm.y;
      }
    }
  }
#endif // DISABLE_GRAPHICS_PRIM
}

float m_pAccelStruct_COctreeV3_LoadDistanceValuesLeafBitPack(uint brickOffset, vec3 voxelPos, uint v_size, float sz_inv, in COctreeV3Header header, uint transform_code, inout float values[8]) {
#if ON_CPU==1
  assert(COctreeV3::VERSION == 5); //if version is changed, this function should be revisited, as some changes may be needed
#endif

  float vmin = 1e6f;
#ifndef DISABLE_SDF_COCTREE_V3
  uint rotIdx = transform_code & header.rot_mask;
  uint p_size = header.brick_size + 2 * header.brick_pad;
  uint PFlagPos = uint32_t(dot(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[ROT_COUNT + rotIdx], 
                               ivec4(voxelPos.x + float(header.brick_pad),voxelPos.y + float(header.brick_pad),voxelPos.z + float(header.brick_pad),1)));
  
  //early exit if voxel is not present
  if ((m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + PFlagPos/32] & (1u << (PFlagPos%32))) == 0)
    return 1e6f;
  
  //this voxel is guaranteed to have surface
  uint distance_flags_size_uints = (v_size * v_size * v_size + 32 - 1) / 32;
  uint presence_flags_size_uints = (p_size * p_size * p_size + 32 - 1) / 32;
  uint min_range_size_uints = 2;

  //<presence_flags><distance_flags><><min value and range><tex_coords><distances>
  uint off_0 = 0;                                   // presence flags
  uint off_1 = off_0 + presence_flags_size_uints;   // distance flags
  uint off_3 = off_1 + distance_flags_size_uints;   // min value and range
  uint off_4 = off_3 + min_range_size_uints;        // texture coordinates
  uint off_5 = off_4 + 8 * header.uv_size;          // distances

  uint vals_per_int = 32 / header.bits_per_value;
  uint bits = header.bits_per_value;
  uint max_val = header.bits_per_value == 32 ? 0xFFFFFFFF : ((1 << bits) - 1);

  float add_transform = header.sim_compression > 0 ? 2*1.73205081f*sz_inv*(2*(float(transform_code & header.add_mask) / float(header.add_mask)) - 1) : 0.0f;

  float min_val = -float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_3 + 0]) / float(0xFFFFFFFFu) + add_transform;
  float range   =  (float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_3 + 1]) / float(0xFFFFFFFFu)) / float(max_val);

  for (int i = 0; i < 8; i++)
  {
    vec3 vPosOrig = voxelPos + vec3(header.brick_pad) + vec3((i & 4) >> 2,(i & 2) >> 1,i & 1);
    uint localId = uint32_t(dot(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[rotIdx], ivec4(vPosOrig.x,vPosOrig.y,vPosOrig.z,1)));

    uint b0 = m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_1];
    b0 = localId > 31 ? b0 : b0 & ((1u << localId) - 1);
    b0 = bitCount(b0);

    uint b1 = localId > 32 ? m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_1 + 1] & ((1u << (localId - 32)) - 1) : 0;
    b1 = bitCount(b1);

    uint vId0 = b0 + b1;
    uint dist0 = ((m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_5 + vId0 / vals_per_int] >> (bits * (vId0 % vals_per_int))) & max_val);
    values[i] = min_val + range * float(dist0);
  }
  return -1.0f;
#endif
  return vmin;
}

void m_pAccelStruct_IntersectNURBS(in vec3 ray_pos, in vec3 ray_dir, float tNear, uint approx_offset, uint instId, uint geomId, inout CRT_Hit pHit) {
#ifndef DISABLE_NURBS
  uint nurbsId = m_pAccelStruct_m_geomData[geomId].offset.x;
  NURBSHeader header  = m_pAccelStruct_m_NURBSHeaders[nurbsId];
  uint type = m_pAccelStruct_m_geomData[geomId].type;

  vec3 min_pos = m_pAccelStruct_m_geomData[geomId].boxMin.xyz;
  vec3 max_pos = m_pAccelStruct_m_geomData[geomId].boxMax.xyz;
  vec2 tNear_tFar = m_pAccelStruct_box_intersects(min_pos, max_pos, ray_pos, ray_dir);

  float u0 = m_pAccelStruct_m_NURBS_approxes[approx_offset];
  float v0 = m_pAccelStruct_m_NURBS_approxes[approx_offset+1];

  NURBS_HitInfo hit = m_pAccelStruct_ray_nurbs_newton_intersection(ray_pos, ray_dir, vec2(u0,v0), header);
  if (hit.hitten) {
    vec2 uv = hit.uv;
    vec3 point = hit.point;
    vec3 normal = hit.normal;
    float t = dot(normalize(ray_dir), point-ray_pos);
    if (t < tNear_tFar.x || t > tNear_tFar.y)
      return;
    pHit.geomId = geomId | (type << SH_TYPE);
    pHit.t = t;
    pHit.primId = 0;
    pHit.instId = instId;

    pHit.coords[0] = uv.x;
    pHit.coords[1] = uv.y;
  } 
  // pHit->geomId = geomId | (type << SH_TYPE);
  // pHit->t = tNear;
  // pHit->primId = 0;
  // pHit->instId = instId;

  // pHit->coords[0] = u0;
  // pHit->coords[1] = v0;
#endif
}

vec4 m_pAccelStruct_rbezier_surface_point(float u, float v, int points_offset, NURBSHeader h) {
  int p = h.p;
  int q = h.q;
  float u_n = 1.0f;
  float _1_u = 1.0f - u;
  int bc = 1;
  vec4 res = m_pAccelStruct_rbezier_curve_point(v, q, points_offset+(q+1)*4*0) * _1_u;
  for (int i = 1; i <= p-1; ++i) {
    u_n *= u;
    bc = bc * (p-i+1)/i;
    res = (res + u_n * float(bc) * m_pAccelStruct_rbezier_curve_point(v, q, points_offset+(q+1)*4*i)) * _1_u;
  }
  res += (u_n * u) * m_pAccelStruct_rbezier_curve_point(v, q, points_offset+(q+1)*4*p);
  return res;
}

bool m_pAccelStruct_need_normal() {
  return ubo.m_pAccelStruct_m_preset.render_mode == MULTI_RENDER_MODE_LAMBERT_NO_TEX || 
         ubo.m_pAccelStruct_m_preset.render_mode == MULTI_RENDER_MODE_NORMAL  ||
         ubo.m_pAccelStruct_m_preset.render_mode == MULTI_RENDER_MODE_PHONG_NO_TEX ||
         ubo.m_pAccelStruct_m_preset.render_mode == MULTI_RENDER_MODE_LAMBERT ||
         ubo.m_pAccelStruct_m_preset.render_mode == MULTI_RENDER_MODE_PHONG;
}

void RecordRayHitIfNeeded(uint bounceId, CRT_Hit hit) {}

void m_pAccelStruct_IntersectAllTrianglesInLeaf(const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint a_start, uint a_count, inout CRT_Hit pHit) {
#ifndef DISABLE_MESH
  const uvec2 a_geomOffsets = m_pAccelStruct_m_geomData[geomId].offset;

  for (uint triId = a_start; triId < a_start + a_count; triId++)
  {
    const uint A = m_pAccelStruct_m_indices[a_geomOffsets.x + triId*3 + 0];
    const uint B = m_pAccelStruct_m_indices[a_geomOffsets.x + triId*3 + 1];
    const uint C = m_pAccelStruct_m_indices[a_geomOffsets.x + triId*3 + 2];

    const vec3 A_pos = m_pAccelStruct_m_vertPos[a_geomOffsets.y + A].xyz;
    const vec3 B_pos = m_pAccelStruct_m_vertPos[a_geomOffsets.y + B].xyz;
    const vec3 C_pos = m_pAccelStruct_m_vertPos[a_geomOffsets.y + C].xyz;

    const vec3 edge1 = B_pos - A_pos;
    const vec3 edge2 = C_pos - A_pos;
    const vec3 pvec = cross(ray_dir, edge2);
    const vec3 tvec = ray_pos - A_pos;
    const vec3 qvec = cross(tvec, edge1);

    const float invDet = 1.0f / dot(edge1, pvec);
    const float v = dot(tvec, pvec) * invDet;
    const float u = dot(qvec, ray_dir) * invDet;
    const float t = dot(edge2, qvec) * invDet;

    if (v >= -1e-6f && u >= -1e-6f && (u + v <= 1.0f + 1e-6f) && t > tNear && t < pHit.t) 
    {
      pHit.t = t;
      pHit.primId = triId;
      pHit.instId = instId;
      pHit.geomId = geomId | (TYPE_MESH_TRIANGLE << SH_TYPE);
      pHit.coords[0] = u;
      pHit.coords[1] = v;

      if (m_pAccelStruct_need_normal())
      {
        vec3 n = vec3(1,0,0);
        if (ubo.m_pAccelStruct_m_preset.normal_mode == NORMAL_MODE_GEOMETRY)
        {
          n = cross(edge1, edge2);
        }
        else if (ubo.m_pAccelStruct_m_preset.normal_mode == NORMAL_MODE_VERTEX)
        {
          n = (m_pAccelStruct_m_vertNorm[a_geomOffsets.y + A] * (1.0f - u - v) + m_pAccelStruct_m_vertNorm[a_geomOffsets.y + B] * v + u * m_pAccelStruct_m_vertNorm[a_geomOffsets.y + C]).xyz;
        }

        n = normalize(matmul4x3(m_pAccelStruct_m_instanceData[instId].transformInvTransposed, n));
        vec2 encoded_norm = m_pAccelStruct_encode_normal(n);

        pHit.coords[2] = encoded_norm.x;
        pHit.coords[3] = encoded_norm.y;
      }
      else
      {
        pHit.coords[2] = 0;
        pHit.coords[3] = 0;
      }
    }
  }
#endif
}

vec4 SampleFilmsSpectrum(uint matId, vec4 a_wavelengths, uint paramId, uint paramSpecId, uint layer) {  
  vec4 res = vec4(m_films_eta_k_vec[floatBitsToUint(m_materials[matId].data[paramId]) + layer]);
  if(a_wavelengths[0] == 0.0f && false)
    return res;

  const uint specId = m_films_spec_id_vec[floatBitsToUint(m_materials[matId].data[paramSpecId]) + layer];
  if(specId < 0xFFFFFFFF)
  {
    const uvec2 data = m_spec_offset_sz[specId];
    const uint offset = data.x;
    const uint size   = data.y;
    res = SampleUniformSpectrum_m_spec_values(offset, a_wavelengths, size);
  }

  return res;
}

float LightEvalPDF(int a_lightId, vec3 illuminationPoint, vec3 ray_dir, const vec3 lpos, const vec3 lnorm, float a_envPdf) {
  const uint gtype = m_lights[a_lightId].geomType;
  if(gtype == LIGHT_GEOM_ENV)
    return a_envPdf;

  const float hitDist   = length(illuminationPoint - lpos);
  const float cosValTmp = dot(ray_dir, -1.0f*lnorm);
  float cosVal = 1.0f;
  switch(gtype)
  {
    case LIGHT_GEOM_SPHERE:
    {
      // const float  lradius = m_lights[a_lightId].size.x;
      // const float3 lcenter = to_float3(m_lights[a_lightId].pos);
      //if (DistanceSquared(illuminationPoint, lcenter) - lradius*lradius <= 0.0f)
      //  return 1.0f;
      const vec3 dirToV = normalize(lpos - illuminationPoint);
      cosVal = abs(dot(dirToV, lnorm));
    }
    break;

    case LIGHT_GEOM_POINT:
    {
      if(m_lights[a_lightId].distType == LIGHT_DIST_LAMBERT)
        cosVal = max(cosValTmp, 0.0f);
    };
    break;

    default: // any type of area light
    //cosVal = std::max(cosValTmp, 0.0f);                                                               ///< Note(!): actual correct way for area lights
    cosVal = (m_lights[a_lightId].iesId == uint(-1)) ? max(cosValTmp, 0.0f) : abs(cosValTmp); ///< Note(!): this is not physically correct for area lights, see test_206;
    break;                                                                                              ///< Note(!): dark line on top of image for pink light appears because area light don't shine to the side. 
  };
  
  return PdfAtoW(m_lights[a_lightId].pdfA, hitDist, cosVal);
}

vec4 m_pAccelStruct_rbezier_surface_uder(float u, float v, in vec4 Sw, int points_offset, NURBSHeader h) {
  int p = h.p;
  int q = h.q;
  if (p == 1) {
    vec4 cur_point = m_pAccelStruct_rbezier_curve_point(v, q, points_offset+(q+1)*4*0);
    vec4 next_point = m_pAccelStruct_rbezier_curve_point(v, q, points_offset+(q+1)*4*1);
    vec4 Sw_der = (next_point - cur_point) * float(p);
    vec4 S_der = (Sw_der * Sw.w - Sw * Sw_der.w)/(Sw.w * Sw.w);
    return S_der;
  }

  float u_n = 1.0f;
  float _1_u = 1.0f - u;
  int bc = 1;
  vec4 Sw_der = vec4(0.0f,0.0f,0.0f,0.0f);

  vec4 cur_point = m_pAccelStruct_rbezier_curve_point(v, q, points_offset+(q+1)*4*0);
  vec4 next_point = m_pAccelStruct_rbezier_curve_point(v, q, points_offset+(q+1)*4*1);
  Sw_der = (next_point - cur_point) * _1_u;
  cur_point = next_point;

  for (int i = 1; i <= p-2; ++i) {
    u_n *= u;
    bc = bc * (p-i)/i;
    next_point = m_pAccelStruct_rbezier_curve_point(v, q, points_offset+(q+1)*4*(i+1));
    Sw_der = (Sw_der + u_n * float(bc) * (next_point-cur_point)) * _1_u;
    cur_point = next_point;
  }

  next_point = m_pAccelStruct_rbezier_curve_point(v, q, points_offset+(q+1)*4*p);
  Sw_der += (u_n * u) * (next_point-cur_point);

  Sw_der *= float(p);
  
  vec4 S_der = (Sw_der * Sw.w - Sw * Sw_der.w)/(Sw.w * Sw.w);
  return S_der;
}

int m_pAccelStruct_find_span(float t, int knots_offset, int knots_count, NURBSHeader h) {
  if (t == m_pAccelStruct_knot(knots_count-1, knots_offset))
    return knots_count-2;

  int l = 0;
  int r = knots_count-1;
  while(r-l > 1) {
    int m = (l+r)/2;
    if (t < m_pAccelStruct_knot(m, knots_offset))
      r = m;
    else 
      l = m;
  }

  //assert(knot(l, knots_offset) <= t && t < knot(l+1, knots_offset));
  return l;
}

vec4 LightIntensity(uint a_lightId, vec4 a_wavelengths, vec3 a_rayPos, vec3 a_rayDir) {
  vec4 lightColor = m_lights[a_lightId].intensity;  
  
  // get spectral data for light source
  //
  const uint specId = m_lights[a_lightId].specId;
  if(KSPEC_SPECTRAL_RENDERING !=0 && ubo.m_spectral_mode != 0 && specId < 0xFFFFFFFF)
  {
    const uvec2 data = m_spec_offset_sz[specId];
    const uint offset = data.x;
    const uint size   = data.y;
    lightColor = SampleUniformSpectrum_m_spec_values(offset, a_wavelengths, size);
  }
  lightColor *= m_lights[a_lightId].mult;
  
  // get ies data for light source
  //
  const uint iesId = m_lights[a_lightId].iesId;
  if(KSPEC_LIGHT_IES != 0 && iesId != uint(-1))
  {
    if((m_lights[a_lightId].flags & LIGHT_FLAG_POINT_AREA) != 0)
      a_rayDir = normalize(m_lights[a_lightId].pos.xyz - a_rayPos);
    const vec3 dirTrans = (m_lights[a_lightId].iesMatrix*vec4(a_rayDir, 0.0f)).xyz;
    float sintheta        = 0.0f;
    const vec2 texCoord = sphereMapTo2DTexCoord((-1.0f)*dirTrans, sintheta);
    const vec4 texColor = texture(m_textures[iesId], texCoord);
    lightColor *= texColor;
  }

  // get environment color
  //
  const uint texId = m_lights[a_lightId].texId;

  if(m_lights[a_lightId].distType == LIGHT_DIST_SPOT) // areaSpotLightAttenuation
  {
    float cos1      = m_lights[a_lightId].lightCos1;
    float cos2      = m_lights[a_lightId].lightCos2;
    vec3 norm = m_lights[a_lightId].norm.xyz;
    float cos_theta = max(-dot(a_rayDir, norm), 0.0f);
    lightColor *= mylocalsmoothstep(cos2, cos1, cos_theta);

    if(KSPEC_LIGHT_PROJECTIVE != 0 && (m_lights[a_lightId].flags & LIGHT_FLAG_PROJECTIVE) != 0 && texId != uint(-1))
    {
      const mat4 mat = m_lights[a_lightId].iesMatrix;
      const vec4 posLightClipSpace = mat*vec4(a_rayPos, 1.0f); // 
      const vec3 posLightSpaceNDC = posLightClipSpace.xyz/posLightClipSpace.w;                         // perspective division
      const vec2 shadowTexCoord = vec2(posLightSpaceNDC.x,posLightSpaceNDC.y)*0.5f + vec2(0.5f,0.5f); // just shift coords from [-1,1] to [0,1]  
      const vec4 texColor = texture(m_textures[texId], shadowTexCoord);
      lightColor *= texColor;
    }
  }
  else if(KSPEC_LIGHT_ENV != 0 && texId != uint(-1))
  {
    float sintheta = 0.0f;
    const vec2 texCoord = sphereMapTo2DTexCoord(a_rayDir, sintheta);
    const vec2 texCoordT = mulRows2x4(m_lights[a_lightId].samplerRow0, m_lights[a_lightId].samplerRow1, texCoord);
    const vec4 texColor = texture(m_textures[texId], texCoordT);
    lightColor *= texColor;
  }

  return lightColor;
}

float m_pAccelStruct_COctreeV3_LoadDistanceValuesLeafSlices(uint brickOffset, vec3 voxelPos, uint v_size, float sz_inv, in COctreeV3Header header, uint transform_code, inout float values[8]) {
#if ON_CPU==1
  assert(COctreeV3::VERSION == 5); //if version is changed, this function should be revisited, as some changes may be needed
#endif

  float vmin = 1e6f;
#ifndef DISABLE_SDF_COCTREE_V3
  uint rotIdx = transform_code & header.rot_mask;
  uint p_size = header.brick_size + 2 * header.brick_pad;
  uint PFlagPos = uint32_t(dot(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[ROT_COUNT + rotIdx], 
                               ivec4(voxelPos.x + float(header.brick_pad),voxelPos.y + float(header.brick_pad),voxelPos.z + float(header.brick_pad),1)));
  
  //early exit if voxel is not present
  if ((m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + PFlagPos/32] & (1u << (PFlagPos%32))) == 0)
    return 1e6f;
  
  //this voxel is guaranteed to have surface
  const uint line_distances_offset_bits = 16;
  const uint line_distances_offsets_per_uint = 32 / line_distances_offset_bits;

  uint slice_distance_flags_bits = v_size * v_size;
  uint slice_distance_flags_uints = (slice_distance_flags_bits + 32 - 1) / 32;
  uint distance_flags_size_uints = v_size * slice_distance_flags_uints;
  uint presence_flags_size_uints = (p_size * p_size * p_size + 32 - 1) / 32;
  uint distance_offsets_size_uints = (v_size + line_distances_offsets_per_uint - 1) / line_distances_offsets_per_uint; // 16 bits for offset, should be enough for all cases

  const uint min_range_size_uints = 2;

  //<presence_flags><distance_flags><distance_offsets><min value and range><tex_coords><distances>
  uint off_0 = 0;                                   // presence flags
  uint off_1 = off_0 + presence_flags_size_uints;   // distance flags
  uint off_2 = off_1 + distance_flags_size_uints;   // distance offsets
  uint off_3 = off_2 + distance_offsets_size_uints; // min value and range
  uint off_4 = off_3 + min_range_size_uints;        // texture coordinates
  uint off_5 = off_4 + 8 * header.uv_size;          // distances

  uint vals_per_int = 32 / header.bits_per_value;
  uint bits = header.bits_per_value;
  uint max_val = header.bits_per_value == 32 ? 0xFFFFFFFF : ((1 << bits) - 1);

  float add_transform = header.sim_compression > 0 ? 2*1.73205081f*sz_inv*(2*(float(transform_code & header.add_mask) / float(header.add_mask)) - 1) : 0.0f;

  float min_val = -float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_3 + 0]) / float(0xFFFFFFFFu) + add_transform;
  float range   =  (float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_3 + 1]) / float(0xFFFFFFFFu)) / float(max_val);

  for (int i = 0; i < 8; i++)
  {
    vec3 vPosOrig = voxelPos + vec3(header.brick_pad) + vec3((i & 4) >> 2,(i & 2) >> 1,i & 1);
    uint voxelId = uint32_t(dot(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[rotIdx], ivec4(vPosOrig.x,vPosOrig.y,vPosOrig.z,1)));
    uint sliceId = voxelId / (v_size * v_size);
    uint localId = voxelId % (v_size * v_size);

    uint b0 = m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_1 + slice_distance_flags_uints * sliceId];
    b0 = localId > 31 ? b0 : b0 & ((1u << localId) - 1);
    b0 = bitCount(b0);

    uint b1 = localId > 32 ? m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_1 + slice_distance_flags_uints * sliceId + 1] & ((1u << (localId - 32)) - 1)
                               : 0;
    b1 = bitCount(b1);

    uint sliceOffset = (m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_2 + sliceId / line_distances_offsets_per_uint] >>
                            (line_distances_offset_bits * (sliceId % line_distances_offsets_per_uint))) &
                           (((1u << line_distances_offset_bits) - 1));
    uint localOffset = b0 + b1;

    uint vId0 = sliceOffset + localOffset;
    uint dist0 = ((m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_5 + vId0 / vals_per_int] >> (bits * (vId0 % vals_per_int))) & max_val);
    values[i] = min_val + range * float(dist0);
  }
  return -1.0f;
#endif
  return vmin;
}

vec4 m_pAccelStruct_rbezier_surface_vder(float u, float v, in vec4 Sw, int points_offset, NURBSHeader h) {
  int p = h.p;
  int q = h.q;
  float u_n = 1.0f;
  float _1_u = 1.0f - u;
  int bc = 1;
  vec4 Sw_der = m_pAccelStruct_rbezier_curve_der(v, q, points_offset+(q+1)*4*0) * _1_u;
  for (int i = 1; i <= p-1; ++i) {
    u_n *= u;
    bc = bc * (p-i+1)/i;
    Sw_der = (Sw_der + u_n * float(bc) * m_pAccelStruct_rbezier_curve_der(v, q, points_offset+(q+1)*4*i)) * _1_u;
  }
  Sw_der += (u_n * u) * m_pAccelStruct_rbezier_curve_der(v, q, points_offset+(q+1)*4*p);

  vec4 S_der = (Sw_der * Sw.w - Sw * Sw_der.w) / (Sw.w * Sw.w);
  return S_der;
}

void m_pAccelStruct_RayNodeIntersection(uint type, const vec3 ray_pos, const vec3 ray_dir, float tNear, uint geomId, uint bvhNodeId, inout float values[8], inout uint primId, inout uint nodeId, inout float d, inout float qNear, inout float qFar, inout vec2 fNearFar, inout vec3 start_q) {
  vec3 min_pos,  max_pos;

  if (type == TYPE_SDF_FRAME_OCTREE)
  {
#ifndef DISABLE_SDF_FRAME_OCTREE
    uint sdfId = m_pAccelStruct_m_geomData[geomId].offset.x;
    primId = m_pAccelStruct_m_origNodes[bvhNodeId].leftOffset;
    nodeId = primId + m_pAccelStruct_m_SdfFrameOctreeRoots[sdfId];
    min_pos = m_pAccelStruct_m_origNodes[bvhNodeId].boxMin;
    max_pos = m_pAccelStruct_m_origNodes[bvhNodeId].boxMax;
    vec3 size = max_pos - min_pos;

    for (int i=0;i<8;i++)
      values[i] = m_pAccelStruct_m_SdfFrameOctreeNodes[nodeId].values[i];

    fNearFar = RayBoxIntersection2(ray_pos, SafeInverse(ray_dir), min_pos, max_pos);
    vec3 start_pos = ray_pos + fNearFar.x*ray_dir;
    d = max(size.x, max(size.y, size.z));
    start_q = (start_pos - min_pos) / d;
    qFar = (fNearFar.y - fNearFar.x) / d;
    qNear = tNear > fNearFar.x ? (tNear - fNearFar.x) / d : 0.0f;
#endif
  }
  else if (type == TYPE_SDF_FRAME_OCTREE_TEX)
  {
#ifndef DISABLE_SDF_FRAME_OCTREE_TEX
    uint32_t sdfId =  m_geomData[geomId].offset.x;
    primId = m_origNodes[bvhNodeId].leftOffset;
    nodeId = primId + m_SdfFrameOctreeTexRoots[sdfId];
    min_pos = m_origNodes[bvhNodeId].boxMin;
    max_pos = m_origNodes[bvhNodeId].boxMax;
    float3 size = max_pos - min_pos;

    for (int i=0;i<8;i++)
      values[i] = m_SdfFrameOctreeTexNodes[nodeId].values[i];

    fNearFar = RayBoxIntersection2(ray_pos, SafeInverse(ray_dir), min_pos, max_pos);
    float3 start_pos = ray_pos + fNearFar.x*ray_dir;
    d = std::max(size.x, std::max(size.y, size.z));
    start_q = (start_pos - min_pos) / d;
    qFar = (fNearFar.y - fNearFar.x) / d;
    qNear = tNear > fNearFar.x ? (tNear - fNearFar.x) / d : 0.0f;
#endif
  }
  else if (type == TYPE_SDF_SVS)
  {
#ifndef DISABLE_SDF_SVS
    uint sdfId = m_pAccelStruct_m_geomData[geomId].offset.x;
    primId = bvhNodeId;
    nodeId = primId + m_pAccelStruct_m_SdfSVSRoots[sdfId];

    float px = m_pAccelStruct_m_SdfSVSNodes[nodeId].pos_xy >> 16;
    float py = m_pAccelStruct_m_SdfSVSNodes[nodeId].pos_xy & 0x0000FFFF;
    float pz = m_pAccelStruct_m_SdfSVSNodes[nodeId].pos_z_lod_size >> 16;
    float sz = m_pAccelStruct_m_SdfSVSNodes[nodeId].pos_z_lod_size & 0x0000FFFF;
    float d_max = 2*1.73205081f/sz;

    min_pos = vec3(-1,-1,-1) + 2.0f*vec3(px,py,pz)/sz;
    max_pos = min_pos + 2.0f*vec3(1,1,1)/sz;
    vec3 size = max_pos - min_pos;

    for (int i=0;i<8;i++)
      values[i] = -d_max + 2*d_max*(1.0/255.0f)*((m_pAccelStruct_m_SdfSVSNodes[nodeId].values[i/4] >> (8*(i%4))) & 0xFF);

    fNearFar = RayBoxIntersection2(ray_pos, SafeInverse(ray_dir), min_pos, max_pos);
    vec3 start_pos = ray_pos + fNearFar.x*ray_dir;
    d = max(size.x, max(size.y, size.z));
    start_q = (start_pos - min_pos) / d;
    qFar = (fNearFar.y - fNearFar.x) / d;
    qNear = tNear > fNearFar.x ? (tNear - fNearFar.x) / d : 0.0f;
#endif
  }
}

float m_pAccelStruct_COctreeV3_LoadDistanceValuesLeafGrid(uint brickOffset, vec3 voxelPos, uint v_size, float sz_inv, in COctreeV3Header header, uint transform_code, inout float values[8]) {
#if ON_CPU==1
  assert(COctreeV3::VERSION == 5); //if version is changed, this function should be revisited, as some changes may be needed
#endif

  float vmin = 1e6f;
#ifndef DISABLE_SDF_COCTREE_V3
  uint rotIdx = transform_code & header.rot_mask;
  const uint min_range_size_uints = 2;

  //<><><><min value and range><tex_coords><distances>
  uint off_3 = 0;                                   // min value and range
  uint off_4 = off_3 + min_range_size_uints;        // texture coordinates
  uint off_5 = off_4 + 8 * header.uv_size;          // distances

  uint vals_per_int = 32 / header.bits_per_value;
  uint bits = header.bits_per_value;
  uint max_val = header.bits_per_value == 32 ? 0xFFFFFFFF : ((1 << bits) - 1);

  float add_transform = header.sim_compression > 0 ? 2*1.73205081f*sz_inv*(2*(float(transform_code & header.add_mask) / float(header.add_mask)) - 1) : 0.0f;

  float min_val = -float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_3 + 0]) / float(0xFFFFFFFFu) + add_transform;
  float range   =  (float(m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_3 + 1]) / float(0xFFFFFFFFu)) / float(max_val);

  uint vId0 = uint32_t(dot(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[rotIdx], 
                           ivec4(voxelPos.x + float(header.brick_pad),voxelPos.y + float(header.brick_pad),voxelPos.z + float(header.brick_pad),1)));
  uint vId,  dist;

  vId = vId0;
  dist = ((m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_5 + vId / vals_per_int] >> (bits * (vId % vals_per_int))) & max_val);
  values[0] = min_val + range * float(dist);
  vmin = min(values[0], vmin);

  vId = vId0 + uint(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[rotIdx].z);
  dist = ((m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_5 + vId / vals_per_int] >> (bits * (vId % vals_per_int))) & max_val);
  values[1] = min_val + range * float(dist);
  vmin = min(values[1], vmin);

  vId = vId0 + uint(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[rotIdx].y);
  dist = ((m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_5 + vId / vals_per_int] >> (bits * (vId % vals_per_int))) & max_val);
  values[2] = min_val + range * float(dist);
  vmin = min(values[2], vmin);

  vId = vId0 + uint(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[rotIdx].y) + uint(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[rotIdx].z);
  dist = ((m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_5 + vId / vals_per_int] >> (bits * (vId % vals_per_int))) & max_val);
  values[3] = min_val + range * float(dist);
  vmin = min(values[3], vmin);

  vId = vId0 + uint(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[rotIdx].x);
  dist = ((m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_5 + vId / vals_per_int] >> (bits * (vId % vals_per_int))) & max_val);
  values[4] = min_val + range * float(dist);
  vmin = min(values[4], vmin);

  vId = vId0 + uint(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[rotIdx].x) + uint(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[rotIdx].z);
  dist = ((m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_5 + vId / vals_per_int] >> (bits * (vId % vals_per_int))) & max_val);
  values[5] = min_val + range * float(dist);
  vmin = min(values[5], vmin);

  vId = vId0 + uint(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[rotIdx].x) + uint(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[rotIdx].y); 
  dist = ((m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_5 + vId / vals_per_int] >> (bits * (vId % vals_per_int))) & max_val);
  values[6] = min_val + range * float(dist);
  vmin = min(values[6], vmin);

  vId = vId0 + uint(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[rotIdx].x) + uint(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[rotIdx].y) + uint(m_pAccelStruct_m_SdfCompactOctreeRotModifiers[rotIdx].z);
  dist = ((m_pAccelStruct_m_SdfCompactOctreeV3Data[brickOffset + off_5 + vId / vals_per_int] >> (bits * (vId % vals_per_int))) & max_val);
  values[7] = min_val + range * float(dist);
  vmin = min(values[7], vmin);

  if (abs(add_transform) > 0.001f)
  {
  //printf("%u] loaded values %f %f %f %f %f %f %f %f, add = %f\n", 
  //       brickOffset + off_5, values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], add_transform);
  }

#endif
  return vmin;
}

void m_pAccelStruct_IntersectCatmulClark(in vec3 ray_pos, in vec3 ray_dir, float tNear, uint instId, uint geomId, inout CRT_Hit pHit) {
#ifndef DISABLE_CATMUL_CLARK
  // offset of catmul clark object in headers array
  uint offset = m_pAccelStruct_m_geomData[geomId].offset.x;
  // object header
  CatmulClarkHeader header = m_pAccelStruct_m_CatmulClarkHeaders[offset];
  // object type <=> catmul_clark
  uint type = m_pAccelStruct_m_geomData[geomId].type;

  // you can access your box of entire object (this is not box of bvh leave)
  vec3 min_pos = m_pAccelStruct_m_geomData[geomId].boxMin.xyz;
  vec3 max_pos = m_pAccelStruct_m_geomData[geomId].boxMax.xyz;
  vec2 tNear_tFar = m_pAccelStruct_box_intersects(min_pos, max_pos, ray_pos, ray_dir);

  // you can pass bvh leave information to this function in GeomDataCatmulClark::Intersect 
  // ...

  vec3 norm = normalize(ray_pos + tNear_tFar.x * ray_dir);
  vec2 encoded_norm = m_pAccelStruct_encode_normal(norm); // compress 3dim normal vector to 2dim vector
  
  pHit.t = tNear_tFar.x;
  pHit.primId = 0;
  pHit.geomId = geomId | (type << SH_TYPE);
  pHit.instId = instId;
  pHit.coords[0] = 0; // u texture coordinate
  pHit.coords[1] = 0; // v texture coordinate
  pHit.coords[2] = encoded_norm.x;
  pHit.coords[3] = encoded_norm.y;
#endif
}

void RecordLightRndIfNeeded(uint bounceId, vec4 rands) {}

vec3 BumpMapping(uint normalMapId, uint currMatId, vec3 n, vec3 tan, vec2 tc) {
  const uint   mflags    = m_materials[currMatId].cflags;
  const vec2 texCoordT = mulRows2x4(m_materials[currMatId].row0[1], m_materials[currMatId].row1[1], tc);
  const vec4 normalTex = texture(m_textures[normalMapId], texCoordT);
  const vec3 normalTS = NormalMapTransform(mflags, normalTex.xyz);
  
  const vec3 bitan = cross(n, tan);
  const mat3 tangentTransform = make_float3x3(tan, bitan, n);

  return normalize(inverse(tangentTransform)*normalTS);
}

uint RandomGenId(uint tid) { return tid; }

void RecordMatRndNeeded(uint bounceId, vec4 rands) {}

float LightPdfSelectRev(int a_lightId) { 
  return 1.0f/float(ubo.m_lights_size); // uniform select
}

LightSample LightSampleRev(int a_lightId, vec3 rands, vec3 illiminationPoint) {
  const uint   gtype  = m_lights[a_lightId].geomType;
  const vec2 rands2 = vec2(rands.x,rands.y);
  switch(gtype)
  {
    case LIGHT_GEOM_DIRECT: return directLightSampleRev_m_lights(a_lightId, rands2, illiminationPoint);
    case LIGHT_GEOM_SPHERE: return sphereLightSampleRev_m_lights(a_lightId, rands2);
    case LIGHT_GEOM_POINT:  return pointLightSampleRev_m_lights(a_lightId);
    case LIGHT_GEOM_ENV: 
    if(KSPEC_LIGHT_ENV != 0)
    {
      const uint offset = m_lights[a_lightId].pdfTableOffset;
      const uint sizeX = m_lights[a_lightId].pdfTableSizeX;
      const uint sizeY = m_lights[a_lightId].pdfTableSizeY;
      
      const Map2DPiecewiseSample sam = SampleMap2D(rands, offset, int(sizeX), int(sizeY));

      // apply inverse texcoord transform to get phi and theta (SKY_DOME_INV_MATRIX0 in HydraCore2)
      //
      const vec2 texCoordT = mulRows2x4(m_lights[a_lightId].samplerRow0Inv, m_lights[a_lightId].samplerRow1Inv, sam.texCoord);

      float sintheta = 0.0f;
      const vec3 sampleDir = texCoord2DToSphereMap(texCoordT, sintheta);
      const vec3 samplePos = illiminationPoint + sampleDir*1000.0f; // TODO: add sceen bounding sphere radius here
      const float  samplePdf = (sam.mapPdf * 1.0f) / (2.f * M_PI * M_PI * max(abs(sintheta), 1e-20f)); // TODO: pass computed pdf to 'LightEvalPDF'
      
      LightSample res;
      res.hasIES = false;
      res.isOmni = true;
      res.norm   = sampleDir; 
      res.pos    = samplePos;
      res.pdf    = samplePdf; // evaluated here for environment lights 
      return res;
    }
    default:                return areaLightSampleRev_m_lights(a_lightId, rands2);
  };
}

void m_pAccelStruct_OctreeAdaptBrickIntersect(uint type, const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint bvhNodeId, uint a_count, inout CRT_Hit pHit) {
#ifndef DISABLE_SDF_SBS_ADAPT
  float values[8];
  uint32_t nodeId, primId;
  float qNear, qFar;
  float2 fNearFar;
  float3 start_q;

  qNear = 1.0f;

  uint32_t sdfId =  m_geomData[geomId].offset.x;
  primId = bvhNodeId; //id of bbox in BLAS
  nodeId = primId + m_SdfSBSAdaptRoots[sdfId];
  SdfSBSAdaptHeader header = m_SdfSBSAdaptHeaders[sdfId];


  float px = m_SdfSBSAdaptNodes[nodeId].pos_xy >> 16;
  float py = m_SdfSBSAdaptNodes[nodeId].pos_xy & 0x0000FFFF;
  float pz = m_SdfSBSAdaptNodes[nodeId].pos_z_vox_size >> 16;
  float vs = m_SdfSBSAdaptNodes[nodeId].pos_z_vox_size & 0x0000FFFF;

  // voxel count
  uint3 brick_size{(m_SdfSBSAdaptNodes[nodeId].vox_count_xyz_pad >> 16) & 0x000000FF,
                   (m_SdfSBSAdaptNodes[nodeId].vox_count_xyz_pad >>  8) & 0x000000FF,
                   (m_SdfSBSAdaptNodes[nodeId].vox_count_xyz_pad      ) & 0x000000FF};
  uint3 v_size = brick_size + 2*header.brick_pad + 1;


  float d = (2.0f/SDF_SBS_ADAPT_MAX_UNITS) * vs;
  float voxel_abs_size_inv = 1.f / d;
  float3 brick_abs_size = d * float3(brick_size);
  float3 brick_min_pos = float3(-1,-1,-1) + (2.0f/SDF_SBS_ADAPT_MAX_UNITS)*float3(px,py,pz);
  float3 brick_max_pos = brick_min_pos + brick_abs_size;


  float2 brick_fNearFar = RayBoxIntersection2(ray_pos, SafeInverse(ray_dir), brick_min_pos, brick_max_pos);
  float old_t = pHit->t;
  while (brick_fNearFar.x < brick_fNearFar.y && pHit->t == old_t)
  {
    float3 hit_pos = ray_pos + brick_fNearFar.x*ray_dir;
    float3 local_pos = (hit_pos - brick_min_pos) * voxel_abs_size_inv;
    uint3  voxel_pos{(uint32_t)clamp(local_pos.x, 1e-6f, brick_size.x-1e-6f),
                     (uint32_t)clamp(local_pos.y, 1e-6f, brick_size.y-1e-6f),
                     (uint32_t)clamp(local_pos.z, 1e-6f, brick_size.z-1e-6f)};

    float3 min_pos = brick_min_pos + d*float3(voxel_pos);
    float3 max_pos = min_pos + d;
    float3 size = max_pos - min_pos;

    float vmin = 1.0f;

    if (header.aux_data == SDF_SBS_NODE_LAYOUT_ID32F_IRGB32F)
    {
      uint32_t v_off = m_SdfSBSAdaptNodes[nodeId].data_offset;
      for (int i=0;i<8;i++)
      {
        uint3 vPos = voxel_pos + uint3((i & 4) >> 2, (i & 2) >> 1, i & 1);
        uint32_t vId = vPos.x*v_size.y*v_size.z + vPos.y*v_size.z + vPos.z;
        values[i] = m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[v_off + vId]];
        vmin = std::min(vmin, values[i]);
      }
    }
    else
    {
      uint32_t v_off = m_SdfSBSAdaptNodes[nodeId].data_offset;
      uint32_t vals_per_int = 4/header.bytes_per_value; 
      uint32_t bits = 8*header.bytes_per_value;
      uint32_t max_val = header.bytes_per_value == 4 ? 0xFFFFFFFF : ((1 << bits) - 1);
      float d_max = 1.73205081f*std::max(std::max(brick_abs_size.x, brick_abs_size.y), brick_abs_size.z);
      float mult = 2*d_max/max_val;
      for (int i=0;i<8;i++)
      {
        uint3 vPos = voxel_pos + uint3((i & 4) >> 2, (i & 2) >> 1, i & 1);
        uint32_t vId = vPos.x*v_size.y*v_size.z + vPos.y*v_size.z + vPos.z;
        values[i] = -d_max + mult*((m_SdfSBSAdaptData[v_off + vId/vals_per_int] >> (bits*(vId%vals_per_int))) & max_val);
        vmin = std::min(vmin, values[i]);
      }
    }

    fNearFar = RayBoxIntersection2(ray_pos, SafeInverse(ray_dir), min_pos, max_pos);
    if (tNear < fNearFar.x && vmin <= 0.0f)
    {
      float3 start_pos = ray_pos + fNearFar.x*ray_dir;
      start_q = (start_pos - min_pos) * voxel_abs_size_inv;
      qFar = (fNearFar.y - fNearFar.x) * voxel_abs_size_inv;

      LocalSurfaceIntersection(type, ray_dir, instId, geomId, values, nodeId, primId, d, 0.0f, qFar, fNearFar, start_q, /*in */
                               pHit); /*out*/
    }

    brick_fNearFar.x += std::max(0.0f, fNearFar.y-brick_fNearFar.x) + 1e-6f;
  }

  //ray hit a brick
  if (pHit->t < old_t)
  {
    float3 pos = ray_pos + pHit->t*ray_dir;
    float3 dp = (pos - brick_min_pos)*voxel_abs_size_inv;

    if (header.aux_data == SDF_SBS_NODE_LAYOUT_DX_UV16)
    {
      uint32_t vals_per_int = 4/header.bytes_per_value;
      uint32_t t_off = m_SdfSBSAdaptNodes[nodeId].data_offset + (v_size.x*v_size.y*v_size.z+vals_per_int-1)/vals_per_int;

      pHit->coords[0] = (1-dp.x)*(1-dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+0] >> 16)) + 
                        (1-dp.x)*(1-dp.y)*(  dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+1] >> 16)) + 
                        (1-dp.x)*(  dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+2] >> 16)) + 
                        (1-dp.x)*(  dp.y)*(  dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+3] >> 16)) + 
                        (  dp.x)*(1-dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+4] >> 16)) + 
                        (  dp.x)*(1-dp.y)*(  dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+5] >> 16)) + 
                        (  dp.x)*(  dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+6] >> 16)) + 
                        (  dp.x)*(  dp.y)*(  dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+7] >> 16));

      pHit->coords[1] = (1-dp.x)*(1-dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+0] & 0xFFFF)) + 
                        (1-dp.x)*(1-dp.y)*(  dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+1] & 0xFFFF)) + 
                        (1-dp.x)*(  dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+2] & 0xFFFF)) + 
                        (1-dp.x)*(  dp.y)*(  dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+3] & 0xFFFF)) + 
                        (  dp.x)*(1-dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+4] & 0xFFFF)) + 
                        (  dp.x)*(1-dp.y)*(  dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+5] & 0xFFFF)) + 
                        (  dp.x)*(  dp.y)*(1-dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+6] & 0xFFFF)) + 
                        (  dp.x)*(  dp.y)*(  dp.z)*(1.5259022e-5f*float(m_SdfSBSAdaptData[t_off+7] & 0xFFFF));
    }
    else if (header.aux_data == SDF_SBS_NODE_LAYOUT_DX_RGB8)
    {
      uint32_t vals_per_int = 4/header.bytes_per_value;
      uint32_t t_off = m_SdfSBSAdaptNodes[nodeId].data_offset + (v_size.x*v_size.y*v_size.z+vals_per_int-1)/vals_per_int;

      float3 color = (1-dp.x)*(1-dp.y)*(1-dp.z)*float3((m_SdfSBSAdaptData[t_off+0] >> 0) & 0xFF, (m_SdfSBSAdaptData[t_off+0] >> 8) & 0xFF, (m_SdfSBSAdaptData[t_off+0] >> 16) & 0xFF) + 
                     (1-dp.x)*(1-dp.y)*(  dp.z)*float3((m_SdfSBSAdaptData[t_off+1] >> 0) & 0xFF, (m_SdfSBSAdaptData[t_off+1] >> 8) & 0xFF, (m_SdfSBSAdaptData[t_off+1] >> 16) & 0xFF) + 
                     (1-dp.x)*(  dp.y)*(1-dp.z)*float3((m_SdfSBSAdaptData[t_off+2] >> 0) & 0xFF, (m_SdfSBSAdaptData[t_off+2] >> 8) & 0xFF, (m_SdfSBSAdaptData[t_off+2] >> 16) & 0xFF) + 
                     (1-dp.x)*(  dp.y)*(  dp.z)*float3((m_SdfSBSAdaptData[t_off+3] >> 0) & 0xFF, (m_SdfSBSAdaptData[t_off+3] >> 8) & 0xFF, (m_SdfSBSAdaptData[t_off+3] >> 16) & 0xFF) + 
                     (  dp.x)*(1-dp.y)*(1-dp.z)*float3((m_SdfSBSAdaptData[t_off+4] >> 0) & 0xFF, (m_SdfSBSAdaptData[t_off+4] >> 8) & 0xFF, (m_SdfSBSAdaptData[t_off+4] >> 16) & 0xFF) + 
                     (  dp.x)*(1-dp.y)*(  dp.z)*float3((m_SdfSBSAdaptData[t_off+5] >> 0) & 0xFF, (m_SdfSBSAdaptData[t_off+5] >> 8) & 0xFF, (m_SdfSBSAdaptData[t_off+5] >> 16) & 0xFF) + 
                     (  dp.x)*(  dp.y)*(1-dp.z)*float3((m_SdfSBSAdaptData[t_off+6] >> 0) & 0xFF, (m_SdfSBSAdaptData[t_off+6] >> 8) & 0xFF, (m_SdfSBSAdaptData[t_off+6] >> 16) & 0xFF) + 
                     (  dp.x)*(  dp.y)*(  dp.z)*float3((m_SdfSBSAdaptData[t_off+7] >> 0) & 0xFF, (m_SdfSBSAdaptData[t_off+7] >> 8) & 0xFF, (m_SdfSBSAdaptData[t_off+7] >> 16) & 0xFF);

      color = clamp(floor(color + 0.5f), 0.0f, 255.0f);

      pHit->coords[0] = color.x + color.y/256.0f;
      pHit->coords[1] = color.z;
    }
    else if (header.aux_data == SDF_SBS_NODE_LAYOUT_ID32F_IRGB32F)
    {
      uint32_t t_off = m_SdfSBSAdaptNodes[nodeId].data_offset + v_size.x*v_size.y*v_size.z;

      float3 color = (1-dp.x)*(1-dp.y)*(1-dp.z)*float3(m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+0]+0], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+0]+1], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+0]+2]) + 
                     (1-dp.x)*(1-dp.y)*(  dp.z)*float3(m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+1]+0], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+1]+1], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+1]+2]) + 
                     (1-dp.x)*(  dp.y)*(1-dp.z)*float3(m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+2]+0], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+2]+1], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+2]+2]) + 
                     (1-dp.x)*(  dp.y)*(  dp.z)*float3(m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+3]+0], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+3]+1], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+3]+2]) + 
                     (  dp.x)*(1-dp.y)*(1-dp.z)*float3(m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+4]+0], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+4]+1], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+4]+2]) + 
                     (  dp.x)*(1-dp.y)*(  dp.z)*float3(m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+5]+0], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+5]+1], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+5]+2]) + 
                     (  dp.x)*(  dp.y)*(1-dp.z)*float3(m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+6]+0], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+6]+1], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+6]+2]) + 
                     (  dp.x)*(  dp.y)*(  dp.z)*float3(m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+7]+0], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+7]+1], m_SdfSBSAdaptDataF[m_SdfSBSAdaptData[t_off+7]+2]);

      color = clamp(floor(255.0f*color + 0.5f), 0.0f, 255.0f);

      pHit->coords[0] = color.x + color.y/256.0f;
      pHit->coords[1] = color.z;
    }
  }
#endif
}

void m_pAccelStruct_IntersectAllSdfsInLeaf(const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint a_start, uint a_count, inout CRT_Hit pHit) {

  uint type = m_pAccelStruct_m_geomData[geomId].type;
  uint sdfId = 0;
  uint primId = 0;

  vec3 min_pos = vec3(0,0,0), max_pos = vec3(0,0,0);

  switch (type)
  {
#ifndef DISABLE_SDF_GRID
  case TYPE_SDF_GRID:
    sdfId = m_geomData[geomId].offset.x;
    primId = 0;
    min_pos = float3(-1,-1,-1);
    max_pos = float3( 1, 1, 1);
    break;
#endif
  default:
    break;
  }

  float l = length(ray_dir);
  vec3 dir = ray_dir/l;
  SdfHit hit = m_pAccelStruct_sdf_sphere_tracing(type, sdfId, min_pos, max_pos, tNear, ray_pos, dir, m_pAccelStruct_need_normal());
  if (hit.hit_pos.w > 0)
  {
    float t = length(hit.hit_pos.xyz-ray_pos)/l;
    if (t > tNear && t < pHit.t)
    {
      vec3 n = normalize(matmul4x3(m_pAccelStruct_m_instanceData[instId].transformInvTransposed, hit.hit_norm.xyz));
      vec2 encoded_norm = m_pAccelStruct_encode_normal(n);

      pHit.t         = t;
      pHit.primId    = primId;
      pHit.instId    = instId;
      pHit.geomId    = geomId | (type << SH_TYPE);  
      pHit.coords[0] = 0;
      pHit.coords[1] = 0;
      pHit.coords[2] = encoded_norm.x;
      pHit.coords[3] = encoded_norm.y;

      if (ubo.m_pAccelStruct_m_preset.render_mode == MULTI_RENDER_MODE_ST_ITERATIONS)
        pHit.primId = uint32_t(hit.hit_norm.w);
    }
  }
}

bool hasNonSpecular(uint a_flags) { return (a_flags & RAY_FLAG_HAS_NON_SPEC)   != 0; }

uint BlendSampleAndEval(uint a_materialId, uint tid, uint bounce, uint layer, vec4 wavelengths, inout RandomGen a_gen, vec3 v, vec3 n, vec2 tc, inout MisData a_misPrev, inout BsdfSample a_pRes) {
  const vec2 texCoordT = mulRows2x4(m_materials[a_materialId].row0[0], m_materials[a_materialId].row1[0], tc);
  const uint   texId     = m_materials[a_materialId].texid[0];
  const vec4 weightDat = texture(m_textures[texId], texCoordT);
  const float  weightTex = weightDat.x;
  const float  weight    = m_materials[a_materialId].data[BLEND_WEIGHT] * weightTex;

  const uint matId1 = m_materials[a_materialId].datai[0];
  const uint matId2 = m_materials[a_materialId].datai[1];

  uint selectedMatId = matId1;
  const float select = GetRandomNumbersMatB(tid, a_gen, int(bounce), int(layer));
  RecordBlendRndNeeded(bounce, layer, select);

  if(select < weight)
  {
    a_pRes.pdf *= weight;
    a_pRes.val *= weight;
    selectedMatId = matId2;
  }
  else
  {
    a_pRes.pdf *= 1.0f - weight;
    a_pRes.val *= 1.0f - weight;
    selectedMatId = matId1;
  }

  return selectedMatId;
}

float m_pAccelStruct_load_tricubic_distance_values(uint nodeId, vec3 voxelPos, uint v_size, float sz_inv, in SdfSBSHeader header, inout float values[64]) {
  float vmin = 1e6f;
#ifndef DISABLE_SDF_SBS
  if (header.aux_data == SDF_SBS_NODE_LAYOUT_ID32F_IRGB32F ||
      header.aux_data == SDF_SBS_NODE_LAYOUT_ID32F_IRGB32F_IN)
  {
    uint v_off = m_pAccelStruct_m_SdfSBSNodes[nodeId].data_offset;
    
    vec3 p0 = vec3(ivec3(voxelPos)) - 1;

    for (int x = 0; x < 4; x++)
    {
      for (int y = 0; y < 4; y++)
      {
        for (int z = 0; z < 4; z++)
        {
          vec3 vPos = p0 + vec3(x,y,z);
          uint vId = SBS_v_to_i(vPos.x, vPos.y, vPos.z, v_size, header.brick_pad); 
          values[16 * z + 4 * y + x] = m_pAccelStruct_m_SdfSBSDataF[m_pAccelStruct_m_SdfSBSData[v_off + vId]];
          vmin = min(vmin, values[16 * z + 4 * y + x]);
        }
      }
    }
  }
#endif
  return vmin;
}

vec4 SampleMatParamSpectrum(uint matId, vec4 a_wavelengths, uint paramId, uint paramSpecId) {  
  vec4 res = vec4(m_materials[matId].data[paramId]);
  if(a_wavelengths[0] == 0.0f)
    return res;

  const uint specId = m_materials[matId].spdid[paramSpecId];
  if(specId < 0xFFFFFFFF)
  {
    const uvec2 data = m_spec_offset_sz[specId];
    const uint offset = data.x;
    const uint size   = data.y;
    //res = SampleSpectrum(m_wavelengths.data() + offset, m_spec_values.data() + offset, a_wavelengths, size);
    res = SampleUniformSpectrum_m_spec_values(offset, a_wavelengths, size);
  }

  return res;
}

vec4 SampleMatColorSpectrumTexture(uint matId, vec4 a_wavelengths, uint paramId, uint paramSpecId, vec2 texCoords) {  
  vec4 res = m_materials[matId].colors[paramId];
  if(a_wavelengths[0] == 0.0f)
    return res;

  const uint specId = m_materials[matId].spdid[paramSpecId];
  if(KSPEC_SPECTRAL_RENDERING !=0 && specId < 0xFFFFFFFF)
  {
    const uvec2 data = m_spec_offset_sz[specId];
    const uint  offset = data.x;
    const uint  size   = data.y;

    res = SampleUniformSpectrum_m_spec_values(offset, a_wavelengths, size);
    
    if(KSPEC_SPD_TEX != 0) // check if spectrum is represented as textures
    {
      const uvec2 tex_data = m_spec_tex_offset_sz[specId];
      const uint tex_offset = tex_data.x;
      const uint tex_size   = tex_data.y;
      if(tex_size > 0)
      {
        for(int i = 0; i < 4; ++i)
        {
          if (a_wavelengths[i] < float(m_spec_tex_ids_wavelengths[tex_offset].y) ||
              a_wavelengths[i] > float(m_spec_tex_ids_wavelengths[tex_offset + tex_size - 1].y) )
          {
            res[i] = 0.0f;
            continue;
          }

          uint o = BinarySearchU2_m_spec_tex_ids_wavelengths(tex_offset, tex_size, a_wavelengths[i]);

          uint texID1 = m_spec_tex_ids_wavelengths[tex_offset + o + 0].x;
          uint texID2 = m_spec_tex_ids_wavelengths[tex_offset + o + 1].x;

          const vec2 texCoordT = mulRows2x4(m_materials[matId].row0[0], m_materials[matId].row1[0], texCoords);
          const vec4 texColor1 = texture(m_textures[texID1], texCoordT);
          const vec4 texColor2 = texture(m_textures[texID2], texCoordT);
  
          float t = (a_wavelengths[i] - float(m_spec_tex_ids_wavelengths[tex_offset + o].y)) / 
                    float(m_spec_tex_ids_wavelengths[tex_offset + o + 1].y - m_spec_tex_ids_wavelengths[tex_offset + o].y );
                    
          vec4 outColor = mix(texColor1, texColor2, t);

          res[i] = outColor.x;
        }
      }
    }
  }

  return res;
}

SdfHit m_pAccelStruct_sdf_sphere_tracing(uint type, uint sdf_id, in vec3 min_pos, in vec3 max_pos, float tNear, in vec3 pos, in vec3 dir, bool need_norm) {
  const float EPS = 1e-5;

  SdfHit hit;
  hit.hit_pos = vec4(0,0,0,-1);
  hit.hit_norm = vec4(1,0,0,0);
  vec2 tNear_tFar = m_pAccelStruct_box_intersects(min_pos, max_pos, pos, dir);
  float t = max(tNear, tNear_tFar.x);
  float tFar = tNear_tFar.y;
  if (t > tFar)
    return hit;
  
  int iter = 0;
  float d = m_pAccelStruct_eval_distance_sdf(type, sdf_id, pos + t * dir);
  while (iter < 1000 && d > EPS && t < tFar)
  {
    t += d + EPS;
    d = m_pAccelStruct_eval_distance_sdf(type, sdf_id, pos + t * dir);
    iter++;
  }

  if (d > EPS)
    return hit;

  vec3 p0 = pos + t * dir;
  vec3 norm = vec3(0,0,1);
  if (need_norm)
  {
    const float h = 0.001;
    float ddx = (m_pAccelStruct_eval_distance_sdf(type, sdf_id, p0 + vec3(h,0,0)) -
                 m_pAccelStruct_eval_distance_sdf(type, sdf_id, p0 + vec3(-h,0,0))) /
                (2 * h);
    float ddy = (m_pAccelStruct_eval_distance_sdf(type, sdf_id, p0 + vec3(0,h,0)) -
                 m_pAccelStruct_eval_distance_sdf(type, sdf_id, p0 + vec3(0,-h,0))) /
                (2 * h);
    float ddz = (m_pAccelStruct_eval_distance_sdf(type, sdf_id, p0 + vec3(0,0,h)) -
                 m_pAccelStruct_eval_distance_sdf(type, sdf_id, p0 + vec3(0,0,-h))) /
                (2 * h);

    norm = normalize(vec3(ddx,ddy,ddz));
    // fprintf(stderr, "st %d (%f %f %f)\n", iter, surface_normal->x, surface_normal->y, surface_normal->z);
  }
  // fprintf(stderr, "st %d (%f %f %f)", iter, p0.x, p0.y, p0.z);
  hit.hit_pos = vec4(p0, 1);
  hit.hit_norm = vec4(norm, float(iter));
  return hit;
}

vec4 GetRandomNumbersMats(uint tid, inout RandomGen a_gen, int a_bounce) { return rndFloat4_Pseudo(a_gen); }

NURBS_HitInfo m_pAccelStruct_ray_nurbs_newton_intersection(in vec3 pos, in vec3 ray, vec2 uv, NURBSHeader h) {
  const int max_steps = 16;
  const float EPS = 1e-3f;

  vec3 ortho_dir1 = (abs(ray.x) > abs(ray.y) && abs(ray.x) > abs(ray.z)) 
                    ? vec3(-ray.y,ray.x,0) 
                    : vec3(0,-ray.z,ray.y);
  vec3 ortho_dir2 = normalize(cross(ortho_dir1, ray));
  ortho_dir1 = normalize(cross(ray, ortho_dir2));
  // assert(dot(ortho_dir1, ortho_dir2) < 1e-2f);
  // assert(dot(ortho_dir1, ray) < 1e-2f);
  // assert(dot(ortho_dir2, ray) < 1e-2f);

  vec4 P1 = vec4(ortho_dir1, -dot(ortho_dir1, pos));
  vec4 P2 = vec4(ortho_dir2, -dot(ortho_dir2, pos));
  // assert(dot(P1, to_float4(pos, 1.0f)) < 1e-2);
  // assert(dot(P2, to_float4(pos, 1.0f)) < 1e-2);

  vec4 Sw = m_pAccelStruct_rbezier_grid_point(uv.x, uv.y, h);
  vec4 surf_point = Sw;
  surf_point /= surf_point.w;
  vec2 D = project2planes(P1, P2, surf_point); 

  NURBS_HitInfo hit_info;
  hit_info.hitten = false;

  int steps_left = max_steps-1;
  while(length(D) > EPS && steps_left > 0) {
    --steps_left;

    vec2 J[2] = { 
      project2planes(P1, P2, m_pAccelStruct_rbezier_grid_uder(uv.x, uv.y, Sw, h)), //col1
      project2planes(P1, P2, m_pAccelStruct_rbezier_grid_vder(uv.x, uv.y, Sw, h)) //col2
    };

    float det = J[0][0]*J[1][1] - J[0][1] * J[1][0];

    vec2 J_inversed[2] = {
      { J[1][1]/det, -J[0][1]/det },
      { -J[1][0]/det, J[0][0]/det }
    };

    uv = uv - (J_inversed[0]*D[0]+J_inversed[1]*D[1]);
    uv.x = clamp(uv.x, 0.0f, 1.0f);
    uv.y = clamp(uv.y, 0.0f, 1.0f);
    // assert(0 <= uv.x && uv.x <= 1);
    // assert(0 <= uv.y && uv.y <= 1);

    Sw = m_pAccelStruct_rbezier_grid_point(uv.x, uv.y, h);
    surf_point = Sw;
    surf_point /= surf_point.w;
    vec2 new_D = project2planes(P1, P2, surf_point);
    
    if (length(new_D) > length(D))
      return hit_info; // hitten = false
    
    D = new_D;
  }

  if (length(D) > EPS)
    return hit_info; // hitten = false;
  
  vec3 uder = (m_pAccelStruct_rbezier_grid_uder(uv.x, uv.y, Sw, h)).xyz;
  vec3 vder = (m_pAccelStruct_rbezier_grid_vder(uv.x, uv.y, Sw, h)).xyz;
  vec3 normal = normalize(cross(uder, vder));

  hit_info.hitten = true;
  hit_info.point = surf_point.xyz;
  hit_info.normal = normal;
  hit_info.uv = uv;
  return hit_info;
}

vec4 m_pAccelStruct_rbezier_grid_uder(float u, float v, in vec4 Sw, NURBSHeader h) {
  int uoffset = uknots_offset(h);
  int voffset = vknots_offset(h);
  int uspan = m_pAccelStruct_find_span(u, uoffset, h.uknots_cnt, h);
  int vspan = m_pAccelStruct_find_span(v, voffset, h.vknots_cnt, h);
  float umin = m_pAccelStruct_knot(uspan, uoffset), umax = m_pAccelStruct_knot(uspan+1, uoffset);
  float vmin = m_pAccelStruct_knot(vspan, voffset), vmax = m_pAccelStruct_knot(vspan+1, voffset);
  u = (u-umin)/(umax-umin);
  v = (v-vmin)/(vmax-vmin);
  vec4 surf_der = m_pAccelStruct_rbezier_surface_uder(u, v, Sw, pts_offset(h, uspan, vspan), h);
  return surf_der * (1.0f/(umax-umin));
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
layout( push_constant ) uniform kernelArgs
{
  uint channels;
  uint iNumElementsX; 
  uint iNumElementsY; 
  uint iNumElementsZ; 
  uint tFlagsMask;    
} kgenArgs;

///////////////////////////////////////////////////////////////// subkernels here
void kernel_CopyColorToOutput_out_color(uint tid, uint channels, in vec4 a_accumColor, in RandomGen gen, uint out_colorOffset) 
{
  
  if(tid >= ubo.m_maxThreadId)
    return;
  
  const vec4 color = a_accumColor;

  if(channels == 4)
  {
    out_color[tid*4+0 + out_colorOffset] += color[0];
    out_color[tid*4+1 + out_colorOffset] += color[1];
    out_color[tid*4+2 + out_colorOffset] += color[2];
    out_color[tid*4+3 + out_colorOffset] += color[3];
  }
  else if(channels == 1)
    out_color[tid + out_colorOffset] += color[0];

  m_randomGens[RandomGenId(tid)] = gen;

}

void kernel_InitEyeRayFromInput_in_rayPosAndNear_in_rayDirAndFar(uint tid, uint in_rayPosAndNearOffset, uint in_rayDirAndFarOffset, inout vec4 rayPosAndNear, inout vec4 rayDirAndFar, inout vec4 accumColor, inout vec4 accumuThoroughput, inout RandomGen gen, inout uint rayFlags, inout MisData misData, inout vec4 wavelengths, inout float time) 
{
  
  if(tid >= ubo.m_maxThreadId)
    return;

  accumColor        = vec4(0, 0, 0, 0);
  accumuThoroughput = vec4(1, 1, 1, 1);
  rayFlags          = 0;
  misData           = makeInitialMisData();  

  //const int x = int(tid) % m_winWidth;
  //const int y = int(tid) / m_winHeight;

  const RayPosAndW rayPosData = in_rayPosAndNear[tid + in_rayPosAndNearOffset];
  const RayDirAndT rayDirData = in_rayDirAndFar[tid + in_rayDirAndFarOffset];

  vec3 rayPos = vec3(rayPosData.origin[0],rayPosData.origin[1],rayPosData.origin[2]);
  vec3 rayDir = vec3(rayDirData.direction[0],rayDirData.direction[1],rayDirData.direction[2]);
  transform_ray3f(ubo.m_worldViewInv, rayPos, rayDir);

  if(KSPEC_SPECTRAL_RENDERING !=0 && ubo.m_spectral_mode != 0)
  {
    wavelengths = vec4(rayPosData.wave);
    //const uint2 wavesXY = unpackXY1616(rayPosData.waves01);
    //const uint2 wavesZW = unpackXY1616(rayDirData.waves23);
    //const float scale = (1.0f/65535.0f)*(LAMBDA_MAX - LAMBDA_MIN);
    //*wavelengths = float4(float(wavesXY[0])*scale + LAMBDA_MIN,
    //                      float(wavesXY[1])*scale + LAMBDA_MIN,
    //                      float(wavesZW[0])*scale + LAMBDA_MIN,
    //                      float(wavesZW[1])*scale + LAMBDA_MIN);
  }
  else
    wavelengths = vec4(0,0,0,0);

  rayPosAndNear = vec4(rayPos, 0.0f);
  rayDirAndFar  = vec4(rayDir, FLT_MAX);
  time          = rayDirData.time;
  gen           = m_randomGens[RandomGenId(tid)];

}

void kernel_NextBounce(uint tid, uint bounce, in vec4 in_hitPart1, in vec4 in_hitPart2, in vec4 in_hitPart3, in uint in_instId, in vec4 in_shadeColor, inout vec4 rayPosAndNear, inout vec4 rayDirAndFar, in vec4 wavelengths, inout vec4 accumColor, inout vec4 accumThoroughput, inout RandomGen a_gen, inout MisData misPrev, inout uint rayFlags) 
{
  
  if(tid >= ubo.m_maxThreadId)
    return;
  const uint currRayFlags = rayFlags;
  if(isDeadRay(currRayFlags))
    return;
    
  const uint matId = extractMatId(currRayFlags);

  // process surface hit case
  //
  const vec3 ray_dir = rayDirAndFar.xyz;
  const vec3 ray_pos = rayPosAndNear.xyz;
  const vec4 lambda = wavelengths;
  
  const vec4 data1 = in_hitPart1;
  const vec4 data2 = in_hitPart2;
  
  SurfaceHit hit;
  hit.pos  = data1.xyz;
  hit.norm = data2.xyz;
  hit.tang = in_hitPart3.xyz;
  hit.uv   = vec2(data1.w,data2.w);

  const float hitDist = in_hitPart3.w;
  
  const MisData prevBounce = misPrev;
  const float   prevPdfW   = prevBounce.matSamplePdf;

  // process light hit case
  //
  if(m_materials[matId].mtype == MAT_TYPE_LIGHT_SOURCE)
  {
    const uint   texId     = m_materials[matId].texid[0];
    const vec2 texCoordT = mulRows2x4(m_materials[matId].row0[0], m_materials[matId].row1[0], hit.uv);
    const vec4 texColor = texture(m_textures[texId], texCoordT);
    const uint   lightId   = m_instIdToLightInstId[in_instId]; 
    
    const vec4 emissColor = m_materials[matId].colors[EMISSION_COLOR];
    vec4 lightIntensity = emissColor * texColor;

    if(lightId != 0xFFFFFFFF)
    {
      const float lightCos = dot(rayDirAndFar.xyz, m_lights[lightId].norm.xyz);
      const float lightDirectionAtten = (lightCos < 0.0f || m_lights[lightId].geomType == LIGHT_GEOM_SPHERE) ? 1.0f : 0.0f;
      lightIntensity = LightIntensity(lightId, lambda, ray_pos, rayDirAndFar.xyz)*lightDirectionAtten;
    }

    float misWeight = 1.0f;
    if(ubo.m_intergatorType == INTEGRATOR_MIS_PT) 
    {
      if(bounce > 0 && lightId != 0xFFFFFFFF)
      {
        const float lgtPdf  = LightPdfSelectRev(int(lightId)) * LightEvalPDF(int(lightId), ray_pos, ray_dir, hit.pos, hit.norm, 1.0f);
        misWeight           = misWeightHeuristic(prevPdfW, lgtPdf);
        if (prevPdfW <= 0.0f) // specular bounce
          misWeight = 1.0f;
      }
    }
    else if(ubo.m_intergatorType == INTEGRATOR_SHADOW_PT && hasNonSpecular(currRayFlags))
      misWeight = 0.0f;
    
    const bool isDirectLight = !hasNonSpecular(currRayFlags);
    const bool isFirstNonSpec = (currRayFlags & RAY_FLAG_FIRST_NON_SPEC) != 0;
    if(ubo.m_renderLayer == FB_INDIRECT && (isDirectLight || isFirstNonSpec))
      misWeight = 0.0f;

    vec4 currAccumColor = accumColor;
    vec4 currAccumThroughput = accumThoroughput;
    
    currAccumColor += currAccumThroughput * lightIntensity * misWeight;
   
    accumColor = currAccumColor;
    rayFlags   = currRayFlags | (RAY_FLAG_IS_DEAD | RAY_FLAG_HIT_LIGHT);
    return;
  }
  
  const uint bounceTmp    = bounce;
  const BsdfSample matSam = MaterialSampleAndEval(matId, tid, bounceTmp, lambda, a_gen, (-1.0f)*ray_dir, hit.norm, hit.tang, hit.uv, misPrev, currRayFlags);
  const vec4 bxdfVal = matSam.val * (1.0f / max(matSam.pdf, 1e-20f));
  const float  cosTheta   = abs(dot(matSam.dir, hit.norm)); 

  MisData nextBounceData      = misPrev;        // remember current pdfW for next bounce
  nextBounceData.matSamplePdf = (matSam.flags & RAY_EVENT_S) != 0 ? -1.0f : matSam.pdf; 
  nextBounceData.cosTheta     = cosTheta;   
  misPrev                    = nextBounceData;

  if(ubo.m_intergatorType == INTEGRATOR_STUPID_PT)
  {
    accumThoroughput *= cosTheta * bxdfVal; 
  }
  else if(ubo.m_intergatorType == INTEGRATOR_SHADOW_PT || ubo.m_intergatorType == INTEGRATOR_MIS_PT)
  {
    const vec4 currThoroughput = accumThoroughput;
    const vec4 shadeColor = in_shadeColor;
    vec4 currAccumColor = accumColor;

    currAccumColor += currThoroughput * shadeColor;
    accumColor       = currAccumColor;
    accumThoroughput = currThoroughput*cosTheta*bxdfVal; 
  }

  // compute point on the other side of the surface in case of transmission
  if((matSam.flags & RAY_EVENT_T) != 0)
  {
    hit.pos = hit.pos + hitDist * ray_dir * 2 * 1e-6f;
  }  

  rayPosAndNear = vec4(OffsRayPos(hit.pos, hit.norm, matSam.dir), 0.0f); // todo: use flatNormal for offset
  rayDirAndFar  = vec4(matSam.dir, FLT_MAX);
  
  uint nextFlags = ((currRayFlags & ~RAY_FLAG_FIRST_NON_SPEC) | matSam.flags); // always force reset RAY_FLAG_FIRST_NON_SPEC;
  if(ubo.m_renderLayer == FB_DIRECT && hasNonSpecular(currRayFlags))   // NOTE: use currRayFlags for check, not nextFlags because of MIS: a ray may hit light source in next bounce
    nextFlags |= RAY_FLAG_IS_DEAD;                                 //       but if we already have non specular bounce previously, definitely can stop  
  else if(!hasNonSpecular(currRayFlags) && hasNonSpecular(nextFlags))
    nextFlags |= RAY_FLAG_FIRST_NON_SPEC;
  rayFlags      = nextFlags;                                   

}

void kernel_RayTrace2(uint tid, uint bounce, in vec4 rayPosAndNear, in vec4 rayDirAndFar, in float a_time, inout vec4 out_hit1, inout vec4 out_hit2, inout vec4 out_hit3, inout uint out_instId, inout uint rayFlags) 
{
  
  if(tid >= ubo.m_maxThreadId)
    return;
  uint currRayFlags = rayFlags;
  if(isDeadRay(currRayFlags))
    return;

  const vec4 rayPos = rayPosAndNear;
  const vec4 rayDir = rayDirAndFar ;
  const float  time   = a_time;

  const CRT_Hit hit   = m_pAccelStruct_RayQuery_NearestHitMotion(rayPos, rayDir, time);
  RecordRayHitIfNeeded(bounce, hit);

  if(hit.geomId != uint32_t(-1))
  {
const uint type = (hit.geomId >> SH_TYPE);
    const uint geomId = hit.geomId & GEOM_ID_MASK;
    const vec3 hitPos = rayPos.xyz + hit.t * (1.f - 1e-6f) * rayDir.xyz;

#ifdef LITERT_RENDERER
    if (type == TYPE_MESH_TRIANGLE)
#endif
    {
      const vec2 uv = vec2(hit.coords[0],hit.coords[1]);
      
      // slightly undershoot the intersection to prevent self-intersection and other bugs

      // const float3 overHit  = to_float3(rayPos) + hit.t * (1.f + 1e-6f) * to_float3(rayDir);

      // alternative, you may consider Johannes Hanika solution from  Ray Tracing Gems2  
      /////////////////////////////////////////////////////////////////////////////////
      // // get distance vectors from triangle vertices
      // vec3 tmpu = P - A, tmpv = P - B, tmpw = P - C
      // // project these onto the tangent planes
      // // defined by the shading normals
      // float dotu = min (0.0, dot(tmpu , nA))
      // float dotv = min (0.0, dot(tmpv , nB))
      // float dotw = min (0.0, dot(tmpw , nC))
      // tmpu -= dotu*nA
      // tmpv -= dotv*nB
      // tmpw -= dotw*nC
      // // finally P' is the barycentric mean of these three
      // vec3 Pp = P + u*tmpu + v*tmpv + w*tmpw
      /////////////////////////////////////////////////////////////////////////////////

      const uint triOffset  = m_matIdOffsets[geomId];
      const uint vertOffset = m_vertOffset  [geomId];
    
      const uint A = m_triIndices[(triOffset + hit.primId)*3 + 0];
      const uint B = m_triIndices[(triOffset + hit.primId)*3 + 1];
      const uint C = m_triIndices[(triOffset + hit.primId)*3 + 2];

      const vec4 data1 = (1.0f - uv.x - uv.y)*m_vNorm4f[A + vertOffset] + uv.y*m_vNorm4f[B + vertOffset] + uv.x*m_vNorm4f[C + vertOffset];
      const vec4 data2 = (1.0f - uv.x - uv.y)*m_vTang4f[A + vertOffset] + uv.y*m_vTang4f[B + vertOffset] + uv.x*m_vTang4f[C + vertOffset];
      vec2 hitTexCoord = vec2(data1.w,data2.w);

      vec3 hitNorm,  hitTang;
// #ifdef LITERT_RENDERER
//       if (m_pAccelStruct->().mesh_normal_mode == MESH_NORMAL_MODE_GEOMETRY)
//       {
//         //normals for are calculated along with the hit calculation
//         const float3 n(hit.coords[2], hit.coords[3], sqrt(max(0.0f, 1-hit.coords[2]*hit.coords[2] - hit.coords[3]*hit.coords[3])));
//         const float len = length(n);
//         hitNorm = len > 1e-9f ? n / len : float3(1.0f, 0.0f, 0.0f);

//         //it is not always good, but we do not expect that tangent will be used at all
//         hitTang = float3(0.0f, 1.0f, 0.0f);
//       }
//       else
// #endif
      {
        hitNorm     = data1.xyz;
        hitTang     = data2.xyz;

        // transform surface point with matrix and flip normal if needed
        //
        hitNorm = mul3x3(m_normMatrices[hit.instId], hitNorm);
        hitTang = mul3x3(m_normMatrices[hit.instId], hitTang);
      }
    
      if(ubo.m_normMatrices2_size > 0)
      {
        vec3 hitNorm2 = mul3x3(m_normMatrices2[hit.instId], hitNorm);
        vec3 hitTang2 = mul3x3(m_normMatrices2[hit.instId], hitTang);

        hitNorm = mix(hitNorm, hitNorm2, time);
        hitTang = mix(hitTang, hitTang2, time);
      }

      hitNorm = normalize(hitNorm);
      hitTang = normalize(hitTang);
      
      const float flipNorm = dot(rayDir.xyz, hitNorm) > 0.001f ? -1.0f : 1.0f; // beware of transparent materials which use normal sign to identity "inside/outside" glass for example
      hitNorm              = flipNorm * hitNorm;
      hitTang              = flipNorm * hitTang; // do we need this ??

      if (flipNorm < 0.0f) currRayFlags |=  RAY_FLAG_HAS_INV_NORMAL;
      else                 currRayFlags &= ~RAY_FLAG_HAS_INV_NORMAL;
      
      const uint midOriginal = m_matIdByPrimId[m_matIdOffsets[geomId] + hit.primId];
      const uint midRemaped  = RemapMaterialId(midOriginal, int(hit.instId));

      rayFlags              = packMatId(currRayFlags, midRemaped);
      out_hit1              = vec4(hitPos, hitTexCoord.x); 
      out_hit2              = vec4(hitNorm, hitTexCoord.y);
      out_hit3              = vec4(hitTang, hit.t);
      out_instId            = hit.instId;
    }
#ifdef LITERT_RENDERER
    else
    {
      //no normal flip/remap on SDFs and other obscure stuff
      currRayFlags &= ~RAY_FLAG_HAS_INV_NORMAL;

      //only one material per geometry without remaps
      const uint matId = m_matIdByPrimId[m_matIdOffsets[geomId]];

      //no texture coordinates, only constant color materials
      const vec2 tc = vec2(0,0);

      //normals for SDFs are calculated along with the hit calculation
      const vec3 n = decode_normal(vec2(hit.coords[2],hit.coords[3]));
    
      const float len = length(n);
      const vec3 hitNorm = len > 1e-9f ? n / len : vec3(1.0f,0.0f,0.0f);

      //it is not always good, but we do not expect that tangent will be used at all
      const vec3 hitTang = normalize(cross(hitNorm, vec3(0.0f,1.0f,0.0f)));

      rayFlags              = packMatId(currRayFlags, matId);
      out_hit1              = vec4(hitPos, tc.x); 
      out_hit2              = vec4(hitNorm, tc.y);
      out_hit3              = vec4(hitTang, hit.t);
      out_instId            = hit.instId;
    }
#endif
  }
  else
  {
    const uint flagsToAdd = (bounce == 0) ? (RAY_FLAG_PRIME_RAY_MISS | RAY_FLAG_IS_DEAD | RAY_FLAG_OUT_OF_SCENE) : (RAY_FLAG_IS_DEAD | RAY_FLAG_OUT_OF_SCENE);
    rayFlags             = currRayFlags | flagsToAdd;
  }

}

void kernel_SampleLightSource(uint tid, in vec4 rayPosAndNear, in vec4 rayDirAndFar, in vec4 wavelengths, in vec4 in_hitPart1, in vec4 in_hitPart2, in vec4 in_hitPart3, in uint rayFlags, in float a_time, uint bounce, inout RandomGen a_gen, inout vec4 out_shadeColor) 
{
  
  if(tid >= ubo.m_maxThreadId)
    return;
  const uint currRayFlags = rayFlags;
  if(isDeadRay(currRayFlags))
    return;
    
  const uint matId = extractMatId(currRayFlags);
  const vec3 ray_dir = rayDirAndFar.xyz;
  
  const vec4 data1 = in_hitPart1;
  const vec4 data2 = in_hitPart2;
  const vec4 lambda = wavelengths;

  SurfaceHit hit;
  hit.pos  = data1.xyz;
  hit.norm = data2.xyz;
  hit.tang = in_hitPart3.xyz;
  hit.uv   = vec2(data1.w,data2.w);
  
  const int bounceTmp = int(bounce); 
  const vec4 rands = GetRandomNumbersLgts(tid, a_gen, bounceTmp); 
  const int lightId  = min(int(floor(rands.w * float(ubo.m_lights_size))), int(ubo.m_lights_size - 1u));
  RecordLightRndIfNeeded(bounce, rands); 

  if(lightId < 0) // no lights or invalid light id
  {
    out_shadeColor = vec4(0.0f,0.0f,0.0f,0.0f);
    return;
  }
  
  const LightSample lSam = LightSampleRev(lightId, rands.xyz, hit.pos);
  const float  hitDist   = sqrt(dot(hit.pos - lSam.pos, hit.pos - lSam.pos));

  const vec3 shadowRayDir = normalize(lSam.pos - hit.pos); // explicitSam.direction;
  const vec3 shadowRayPos = hit.pos + hit.norm * max(maxcomp(hit.pos), 1.0f)*5e-6f; // TODO: see Ray Tracing Gems, also use flatNormal for offset

  float time = a_time;
  const bool inIllumArea = (dot(shadowRayDir, lSam.norm) < 0.0f) || lSam.isOmni || lSam.hasIES;
  const bool needShade = inIllumArea && !m_pAccelStruct_RayQuery_AnyHitMotion(vec4(shadowRayPos, 0.0f), vec4(shadowRayDir, hitDist*0.9995f), time); /// (!!!) expression-way, RT pipeline bug work around, if change check test_213
  RecordShadowHitIfNeeded(bounce, needShade);

  if(needShade) /// (!!!) expression-way to compute 'needShade', RT pipeline bug work around, if change check test_213
  {
    const BsdfEval bsdfV    = MaterialEval(matId, lambda, shadowRayDir, (-1.0f)*ray_dir, hit.norm, hit.tang, hit.uv);
    float cosThetaOut       = max(dot(shadowRayDir, hit.norm), 0.0f);
    
    float      lgtPdfW      = LightPdfSelectRev(lightId) * LightEvalPDF(lightId, shadowRayPos, shadowRayDir, lSam.pos, lSam.norm, lSam.pdf);
    float      misWeight    = (ubo.m_intergatorType == INTEGRATOR_MIS_PT) ? misWeightHeuristic(lgtPdfW, bsdfV.pdf) : 1.0f;
    const bool isDirect = (m_lights[lightId].geomType == LIGHT_GEOM_DIRECT); 
    const bool isPoint = (m_lights[lightId].geomType == LIGHT_GEOM_POINT); 
    
    if(isDirect)
    {
      misWeight = 1.0f;
      lgtPdfW   = 1.0f;
    }
    else if(isPoint)
      misWeight = 1.0f;

    const bool isDirectLight = !hasNonSpecular(currRayFlags);
    if((ubo.m_renderLayer == FB_DIRECT   && !isDirectLight) || 
       (ubo.m_renderLayer == FB_INDIRECT && isDirectLight)) // skip some number of bounces if this is set
      misWeight = 0.0f;
      
    
    const vec4 lightColor = LightIntensity(uint(lightId), lambda, shadowRayPos, shadowRayDir);
    out_shadeColor = (lightColor * bsdfV.val / lgtPdfW) * cosThetaOut * misWeight;
  }
  else
    out_shadeColor = vec4(0.0f,0.0f,0.0f,0.0f);

}

void kernel_HitEnvironment(uint tid, in uint rayFlags, in vec4 rayDirAndFar, in MisData a_prevMisData, in vec4 accumThoroughput, inout vec4 accumColor) 
{
  
  if(tid >= ubo.m_maxThreadId)
    return;
  const uint currRayFlags = rayFlags;
  if(!isOutOfScene(currRayFlags))
    return;
  
  float envPdf = 1.0f;
  vec4 envColor = EnvironmentColor(rayDirAndFar.xyz, envPdf);

  const MisData misPrev = a_prevMisData;
  const bool isSpec = isSpecular(misPrev);
  const bool exitZero = (currRayFlags & RAY_FLAG_PRIME_RAY_MISS) != 0;

  if(ubo.m_intergatorType == INTEGRATOR_MIS_PT && ubo.m_envEnableSam != 0 && !isSpec && !exitZero)
  {
    float lgtPdf    = LightPdfSelectRev(int(ubo.m_envLightId))*envPdf;
    float bsdfPdf   = misPrev.matSamplePdf;
    float misWeight = misWeightHeuristic(bsdfPdf, lgtPdf); // (bsdfPdf*bsdfPdf) / (lgtPdf*lgtPdf + bsdfPdf*bsdfPdf);
    envColor *= misWeight;    
  }
  else if(ubo.m_intergatorType == INTEGRATOR_SHADOW_PT && ubo.m_envEnableSam != 0)
  {
    envColor = vec4(0.0f);
  }
  
  const uint camBackId = ubo.m_envCamBackId;
  if(exitZero && camBackId != uint(-1)) // apply camera back color to ray
  {
    const uint XY = m_packedXY[tid];
    const uint x  = (XY & 0x0000FFFF);
    const uint y  = (XY & 0xFFFF0000) >> 16;

    const vec2 texCoord = vec2((float(x) + 0.5f)/float(ubo.m_winWidth),(float(y) + 0.5f)/float(ubo.m_winHeight));

    envColor = texture(m_textures[camBackId], texCoord);
  }
 
  if(ubo.m_intergatorType == INTEGRATOR_STUPID_PT)     // todo: when explicit sampling will be added, disable contribution here for 'INTEGRATOR_SHADOW_PT'
    accumColor = (accumThoroughput) * envColor;
  else
    accumColor += (accumThoroughput) * envColor;

}

///////////////////////////////////////////////////////////////// subkernels here

void main()
{
  ///////////////////////////////////////////////////////////////// prolog
  const uint tid = uint(gl_GlobalInvocationID[0]); 
  ///////////////////////////////////////////////////////////////// prolog

  
  vec4 accumColor,  accumThroughput;
  vec4 rayPosAndNear,  rayDirAndFar;
  vec4 wavelengths;
  RandomGen gen; 
  MisData   mis;
  uint      rayFlags;
  float     time;
  kernel_InitEyeRayFromInput_in_rayPosAndNear_in_rayDirAndFar(tid, 0, 0, rayPosAndNear, rayDirAndFar, accumColor, accumThroughput, gen, rayFlags, mis, wavelengths, time);
  
  for(uint depth = 0; depth < ubo.m_traceDepth; depth++) 
  {
    vec4 shadeColor,  hitPart1,  hitPart2,  hitPart3;
    uint instId;
    kernel_RayTrace2(tid, depth, rayPosAndNear, rayDirAndFar, time, 
                     hitPart1, hitPart2, hitPart3, instId, rayFlags);
    if(isDeadRay(rayFlags))
      break;
    
    kernel_SampleLightSource(tid, rayPosAndNear, rayDirAndFar, wavelengths, hitPart1, hitPart2, hitPart3, rayFlags, time,
                             depth, gen, shadeColor);

    kernel_NextBounce(tid, depth, hitPart1, hitPart2, hitPart3, instId, shadeColor, rayPosAndNear, rayDirAndFar,
                      wavelengths, accumColor, accumThroughput, gen, mis, rayFlags);

    if(isDeadRay(rayFlags))
      break;
  }

  kernel_HitEnvironment(tid, rayFlags, rayDirAndFar, mis, accumThroughput,
                        accumColor);
  
  //////////////////////////////////////////////////// same as for PathTrace

  kernel_CopyColorToOutput_out_color(tid, kgenArgs.channels, accumColor, gen, 0);

}

